{"nodes":[{"content":"How to: Use ForEach to Remove Items in a BlockingCollection","pos":[12,71]},{"content":"How to: Use ForEach to Remove Items in a BlockingCollection","pos":[87,146]},{"pos":[158,173],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":"How to: Use ForEach to Remove Items in a BlockingCollection","pos":[377,436]},{"content":"In addition to taking items from a <bpt id=\"p1\">[</bpt>BlockingCollection<ph id=\"ph1\">&amp;lt;</ph>T<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> by using the <ph id=\"ph3\">`Take`</ph> and <ph id=\"ph4\">`TryTake`</ph> methods, you can also use a <ph id=\"ph5\">`foreach`</ph> loop to remove items until adding is completed and the collection is empty.","pos":[438,745],"source":"In addition to taking items from a [BlockingCollection&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1) by using the `Take` and `TryTake` methods, you can also use a `foreach` loop to remove items until adding is completed and the collection is empty."},{"content":"This is called a mutating enumeration or consuming enumeration because, unlike a typical <ph id=\"ph1\">`foreach`</ph> loop, this enumerator modifies the source collection by removing items.","pos":[746,916],"source":" This is called a mutating enumeration or consuming enumeration because, unlike a typical `foreach` loop, this enumerator modifies the source collection by removing items."},{"content":"Example","pos":[921,928]},{"pos":[930,1041],"content":"The following example shows how to remove all the items in a <ph id=\"ph1\">`BlockingCollection&lt;T&gt;`</ph> by using a <ph id=\"ph2\">`foreach`</ph> loop.","source":"The following example shows how to remove all the items in a `BlockingCollection<T>` by using a `foreach` loop."},{"content":"This example uses a <ph id=\"ph1\">`foreach`</ph> loop with the <ph id=\"ph2\">`BlockingCollection&lt;T&gt;.GetConsumingEnumerable`</ph> method in the consuming thread, which causes each item to be removed from the collection as it is enumerated.","pos":[4119,4319],"source":"This example uses a `foreach` loop with the `BlockingCollection<T>.GetConsumingEnumerable` method in the consuming thread, which causes each item to be removed from the collection as it is enumerated."},{"content":"limits the maximum number of items that are in the collection at any time.","pos":[4344,4418]},{"content":"Enumerating the collection in this way blocks the consumer thread if no items are available or if the collection is empty.","pos":[4419,4541]},{"content":"In this example blocking is not a concern because the producer thread adds items faster than they can be consumed.","pos":[4542,4656]},{"content":"There is no guarantee that the items are enumerated in the same order in which they are added by the producer threads.","pos":[4659,4777]},{"content":"To enumerate the collection without modifying it, just use <ph id=\"ph1\">`foreach`</ph> without the <ph id=\"ph2\">`GetConsumingEnumerable`</ph> method.","pos":[4779,4892],"source":"To enumerate the collection without modifying it, just use `foreach` without the `GetConsumingEnumerable` method."},{"content":"However, it is important to understand that this kind of enumeration represents a snapshot of the collection at a precise point in time.","pos":[4893,5029]},{"content":"If other threads are adding or removing items concurrently while you are executing the loop, then the loop might not represent the actual state of the collection.","pos":[5030,5192]},{"content":"See Also","pos":[5197,5205]},{"content":"System.Collections.Concurrent","pos":[5208,5237]},{"content":"BlockingCollection Overview","pos":[5315,5342]}],"content":"---\ntitle: \"How to: Use ForEach to Remove Items in a BlockingCollection\"\ndescription: \"How to: Use ForEach to Remove Items in a BlockingCollection\"\nkeywords: .NET, .NET Core\nauthor: mairaw\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: f3db5825-b5c9-4e8b-80bc-e11760d9523e\n---\n\n# How to: Use ForEach to Remove Items in a BlockingCollection\n\nIn addition to taking items from a [BlockingCollection&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1) by using the `Take` and `TryTake` methods, you can also use a `foreach` loop to remove items until adding is completed and the collection is empty. This is called a mutating enumeration or consuming enumeration because, unlike a typical `foreach` loop, this enumerator modifies the source collection by removing items.\n\n## Example\n\nThe following example shows how to remove all the items in a `BlockingCollection<T>` by using a `foreach` loop. \n\n```csharp\nusing System;\nusing System.Collections.Concurrent;\nusing System.Diagnostics;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nclass Example\n{\n   // Limit the collection size to 2000 items at any given time.\n   // Set itemsToProduce to > 500 to hit the limit.\n   const int upperLimit = 1000;\n\n   // Adjust this number to see how it impacts the producing-consuming pattern.\n   const int itemsToProduce = 100;\n\n   static BlockingCollection<long> collection = new BlockingCollection<long>(upperLimit);\n\n   // Variables for diagnostic output only.\n   static Stopwatch sw = new Stopwatch();\n   static int totalAdditions = 0;\n\n   // Counter for synchronizing producers.\n   static int producersStillRunning = 2;\n\n   static void Main()\n   {\n       // Start the stopwatch.\n       sw.Start();\n\n       // Queue the Producer threads. Store in an array\n       // for use with ContinueWhenAll\n       Task[] producers = new Task[2];\n       producers[0] = Task.Run(() => RunProducer(\"A\", 0));\n       producers[1] = Task.Run(() => RunProducer(\"B\", itemsToProduce));\n\n       // Create a cleanup task that will call CompleteAdding after\n       // all producers are done adding items.\n       Task cleanup = Task.Factory.ContinueWhenAll(producers, (p) => collection.CompleteAdding());\n\n       // Queue the Consumer thread. Put this call\n       // before Parallel.Invoke to begin consuming as soon as\n       // the producers add items.\n       Task.Run(() => RunConsumer());\n\n       // Keep the console window open while the\n       // consumer thread completes its output.\n       Console.ReadKey(true);\n   }\n\n   static void RunProducer(string ID, int start)\n   {\n\n       int additions = 0;\n       for (int i = start; i < start + itemsToProduce; i++)\n       {\n           // The data that is added to the collection.\n           long ticks = sw.ElapsedTicks;\n\n           // Display additions and subtractions.\n           Console.WriteLine(\"{0} adding tick value {1}. item# {2}\", ID, ticks, i);\n\n           if(!collection.IsAddingCompleted)\n               collection.Add(ticks);\n\n           // Counter for demonstration purposes only.\n           additions++;\n\n           // Uncomment this line to\n           // slow down the producer threads     ing.\n           Thread.SpinWait(100000);\n       }\n\n       Interlocked.Add(ref totalAdditions, additions);\n       Console.WriteLine(\"{0} is done adding: {1} items\", ID, additions);\n   }\n\n   static void RunConsumer()\n   {\n       // GetConsumingEnumerable returns the enumerator for the\n       // underlying collection.\n       int subtractions = 0;\n       foreach (var item in collection.GetConsumingEnumerable())\n       {\n           Console.WriteLine(\"Consuming tick value {0} : item# {1} : current count = {2}\",\n                   item.ToString(\"D18\"), subtractions++, collection.Count);\n       }\n\n       Console.WriteLine(\"Total added: {0} Total consumed: {1} Current count: {2} \",\n                           totalAdditions, subtractions, collection.Count);\n       sw.Stop();\n\n       Console.WriteLine(\"Press any key to exit\");\n   }\n}\n\n```\n\nThis example uses a `foreach` loop with the `BlockingCollection<T>.GetConsumingEnumerable` method in the consuming thread, which causes each item to be removed from the collection as it is enumerated. `BlockingCollection<T>` limits the maximum number of items that are in the collection at any time. Enumerating the collection in this way blocks the consumer thread if no items are available or if the collection is empty. In this example blocking is not a concern because the producer thread adds items faster than they can be consumed. \n\nThere is no guarantee that the items are enumerated in the same order in which they are added by the producer threads.\n\nTo enumerate the collection without modifying it, just use `foreach` without the `GetConsumingEnumerable` method. However, it is important to understand that this kind of enumeration represents a snapshot of the collection at a precise point in time. If other threads are adding or removing items concurrently while you are executing the loop, then the loop might not represent the actual state of the collection.\n\n## See Also\n\n[System.Collections.Concurrent](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)\n\n[BlockingCollection Overview](blockingcollection-overview.md)\n"}