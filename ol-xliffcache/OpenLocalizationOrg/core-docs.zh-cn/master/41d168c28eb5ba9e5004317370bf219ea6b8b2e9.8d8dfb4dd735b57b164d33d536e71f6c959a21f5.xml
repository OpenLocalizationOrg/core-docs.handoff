{"nodes":[{"pos":[11,44],"content":".NET Core CLI extensibility model","needQuote":true,"nodes":[{"content":".NET Core CLI extensibility model","pos":[0,33]}]},{"pos":[59,92],"content":".NET Core CLI extensibility model","needQuote":true,"nodes":[{"content":".NET Core CLI extensibility model","pos":[0,33]}]},{"pos":[104,119],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":".NET Core CLI extensibility model","pos":[323,356]},{"content":"Overview","pos":[362,370]},{"content":"This document will cover the main ways how to extend the CLI tools and explain the scenarios that drive each of them.","pos":[371,488]},{"content":"It will the outline how to consume the tools as well as provide short notes on how to build both types of tools.","pos":[489,602],"source":" \nIt will the outline how to consume the tools as well as provide short notes on how to build both types of tools."},{"content":"How to extend CLI tools","pos":[608,631]},{"content":"The CLI tools can be extended in two main ways:","pos":[632,679]},{"content":"Via NuGet packages on a per-project basis","pos":[684,725]},{"content":"Via the system's PATH","pos":[729,750]},{"content":"The two extensibility mechanisms outlined above are not exclusive; you can use both or just one.","pos":[752,848]},{"content":"Which one to pick depends largely on what is the goal you are trying to achieve with your extension.","pos":[849,950],"source":" Which one to pick \ndepends largely on what is the goal you are trying to achieve with your extension."},{"content":"Per-project based extensibility","pos":[955,986]},{"content":"Per-project tools are <bpt id=\"p1\">[</bpt>portable console applications<ept id=\"p1\">](../app-types.md)</ept> that are distributed as NuGet packages.","pos":[987,1097],"source":"Per-project tools are [portable console applications](../app-types.md) that are distributed as NuGet packages."},{"content":"Tools are only available in the context of the project that references them and for which they are restored; invocation outside of the context of the project (for example, outside of the directory that contains the project) will fail as the command will not be able to be found.","pos":[1098,1379],"source":" Tools are \nonly available in the context of the project that references them and for which they are restored; invocation outside \nof the context of the project (for example, outside of the directory that contains the project) will fail as the command will \nnot be able to be found."},{"content":"These tools are perfect for build servers as well, since nothing outside of <ph id=\"ph1\">`project.json`</ph> is needed.","pos":[1381,1482],"source":"These tools are perfect for build servers as well, since nothing outside of `project.json` is needed."},{"content":"The build process runs restore for the project it builds and tools will be available.","pos":[1483,1569],"source":" The build process \nruns restore for the project it builds and tools will be available."},{"content":"Language projects, such as F#, are also in this category; after all, each project can only be written in one specific language.","pos":[1570,1698],"source":" Language projects, such as F#, are also in this \ncategory; after all, each project can only be written in one specific language."},{"content":"Finally, this extensibility model provides support for creation of tools that need access to the built output of the project.","pos":[1701,1827],"source":"Finally, this extensibility model provides support for creation of tools that need access to the built output of the \nproject."},{"content":"For instance, various Razor view tools in <bpt id=\"p1\">[</bpt>ASP.NET<ept id=\"p1\">](https://www.asp.net/)</ept> MVC applications fall into this category.","pos":[1828,1944],"source":" For instance, various Razor view tools in [ASP.NET](https://www.asp.net/) MVC applications fall into this \ncategory."},{"content":"Consuming per-project tools","pos":[1951,1978]},{"content":"Consuming these tools requires you to add a <ph id=\"ph1\">`tools`</ph> node to your <ph id=\"ph2\">`project.json`</ph>.","pos":[1979,2059],"source":"Consuming these tools requires you to add a `tools` node to your `project.json`."},{"content":"Inside the <ph id=\"ph1\">`tools`</ph> node, you reference the package in which the tool resides.","pos":[2060,2137],"source":" Inside the `tools` node, you reference\nthe package in which the tool resides."},{"content":"After running <ph id=\"ph1\">`dotnet restore`</ph>, the tool and its dependencies are restored.","pos":[2138,2213],"source":" After running `dotnet restore`, the tool and its dependencies are restored."},{"content":"For tools that need to load the build output of the project for execution, there is usually another dependency which is listed under the regular dependencies in the project file.","pos":[2216,2395],"source":"For tools that need to load the build output of the project for execution, there is usually another dependency which is \nlisted under the regular dependencies in the project file."},{"content":"This means that tools that load project's code have two components:","pos":[2396,2464],"source":" This means that tools that load project's code have two \ncomponents:"},{"content":"The \"tools\" main invoker","pos":[2470,2494]},{"content":"Any number of other tools that contain the logic to work with","pos":[2498,2559]},{"content":"Why two things?","pos":[2562,2577]},{"content":"Tools that need to load the build output of a project need to have unified dependency graph with the project they are working.","pos":[2578,2705],"source":" Tools that need to load the build output of a project need to have unified dependency graph with the \nproject they are working."},{"content":"By adding the dependency bit, we enable NuGet to resolve these dependencies as a unified graph.","pos":[2706,2802],"source":" By adding the dependency bit, we enable NuGet to resolve these dependencies as a unified \ngraph."},{"content":"The invoker is there because it needs to reason about the location as well as the frameworks of the dependency tool.","pos":[2803,2920],"source":" The invoker is there because it needs to reason about the location as well as the frameworks of the dependency \ntool."},{"content":"The invoker can accept all of the redirection arguments (<ph id=\"ph1\">`-c`</ph>, <ph id=\"ph2\">`-o`</ph>, <ph id=\"ph3\">`-b`</ph>) that the user specifies and finds the dependency tool; it can also implement any policies for cases where multiple dependency tools exist for multiple frameworks (that is, does it run all of them, just one, etc.) In general, logic can be shared between these two tools any way that is needed.","pos":[2921,3291],"source":" The invoker can accept all of the redirection arguments (`-c`, `-o`, `-b`) that the user specifies and finds the \ndependency tool; it can also implement any policies for cases where multiple dependency tools exist for multiple \nframeworks (that is, does it run all of them, just one, etc.) In general, logic can be shared between these two tools any way \nthat is needed."},{"content":"Let's review an example of adding a simple tools-only tool to a simple project.","pos":[3294,3373]},{"content":"Given an example command called <ph id=\"ph1\">`dotnet-api-search`</ph> that allows you to search through the NuGet packages for the specified API, here is a console application's <ph id=\"ph2\">`project.json`</ph> file that uses that tool:","pos":[3374,3576],"source":" Given an example command called \n`dotnet-api-search` that allows you to search through the NuGet packages for the specified \nAPI, here is a console application's `project.json` file that uses that tool:"},{"content":"The <ph id=\"ph1\">`tools`</ph> node is structured in a similar way as the <ph id=\"ph2\">`dependencies`</ph> node.","pos":[4008,4083],"source":"The `tools` node is structured in a similar way as the `dependencies` node."},{"content":"It needs the package ID of the package containing the tool and its version at the very least.","pos":[4084,4178],"source":" It needs the package ID of the package \ncontaining the tool and its version at the very least."},{"content":"In the example above, we can see that there is another statement, the <ph id=\"ph1\">`imports`</ph> one.","pos":[4179,4264],"source":" In the example above, we can see that there is another statement, \nthe `imports` one."},{"content":"This influences the tool's restore process and specifies that the tool is also compatible, in addition to any targeted frameworks the tools has, with <ph id=\"ph1\">`dnxcore50`</ph> target.","pos":[4265,4435],"source":" This influences the tool's restore process and specifies that the tool is also compatible, in \naddition to any targeted frameworks the tools has, with `dnxcore50` target."},{"content":"For more information you can consult the <bpt id=\"p1\">[</bpt>project.json reference<ept id=\"p1\">](project-json.md)</ept>.","pos":[4436,4520],"source":" For more information you can \nconsult the [project.json reference](project-json.md)."},{"content":"Building tools","pos":[4526,4540]},{"content":"As mentioned, tools are just portable console applications.","pos":[4541,4600]},{"content":"You would build one as you would build any console application.","pos":[4601,4664]},{"content":"After you build it, you would use <bpt id=\"p1\">[</bpt><ph id=\"ph1\">`dotnet pack`</ph><ept id=\"p1\">](dotnet-pack.md)</ept> command to create a NuGet package (nupkg) that contains your code, information about its dependencies and so on.","pos":[4665,4845],"source":" \nAfter you build it, you would use [`dotnet pack`](dotnet-pack.md) command to create a NuGet package (nupkg) that contains \nyour code, information about its dependencies and so on."},{"content":"The package name can be whatever the author wants, but the application inside, the actual tool binary, has to conform to the convention of <ph id=\"ph1\">`dotnet-&lt;command&gt;`</ph> in order for <ph id=\"ph2\">`dotnet`</ph> to be able to invoke it.","pos":[4846,5052],"source":" The package name can be whatever the author wants, but the \napplication inside, the actual tool binary, has to conform to the convention of `dotnet-<command>` in order for `dotnet` \nto be able to invoke it."},{"content":"Since tools are portable applications, the user consuming the tool has to have the version of the .NET Core libraries that the tool was built against in order to run the tool.","pos":[5055,5231],"source":"Since tools are portable applications, the user consuming the tool has to have the version of the .NET Core libraries \nthat the tool was built against in order to run the tool."},{"content":"Any other dependency that the tool uses and that is not contained within the .NET Core libraries is restored and placed in the NuGet cache.","pos":[5232,5372],"source":" Any other dependency that the tool uses and that is not \ncontained within the .NET Core libraries is restored and placed in the NuGet cache."},{"content":"The entire tool is, therefore, run using the assemblies from the .NET Core libraries as well as assemblies from the NuGet cache.","pos":[5373,5502],"source":" The entire tool is, therefore, run \nusing the assemblies from the .NET Core libraries as well as assemblies from the NuGet cache."},{"content":"These kind of tools have a dependency graph that is completely separate from the dependency graph of the project that uses them.","pos":[5505,5634],"source":"These kind of tools have a dependency graph that is completely separate from the dependency graph of the project that \nuses them."},{"content":"The restore process will first restore the project's dependencies, and will then restore each of the tools and their dependencies.","pos":[5635,5766],"source":" The restore process will first restore the project's dependencies, and will then restore each of the tools and \ntheir dependencies."},{"content":"You can find richer examples and different combinations of this in the <bpt id=\"p1\">[</bpt>.NET Core CLI repo<ept id=\"p1\">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestProjects)</ept>.","pos":[5769,5940],"source":"You can find richer examples and different combinations of this in the [.NET Core CLI repo](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestProjects)."},{"content":"You can also see the <bpt id=\"p1\">[</bpt>implementation of tools used<ept id=\"p1\">](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages)</ept> in the same repo.","pos":[5941,6090],"source":" \nYou can also see the [implementation of tools used](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages) in the same repo."},{"content":"Building tools that load project's build outputs for execution is slightly different.","pos":[6093,6178]},{"content":"As stated, for these kinds of tools there are two components:","pos":[6179,6241],"source":" As stated, for these kinds of \ntools there are two components:"},{"content":"A dispatcher tool that the user invokes","pos":[6246,6285]},{"content":"A framework-specific dependency that contains the logic on how to find the build outputs and what to do with it","pos":[6289,6400]},{"content":"A prime example of this are <bpt id=\"p1\">[</bpt>Entity Framework (EF)<ept id=\"p1\">](https://github.com/aspnet/EntityFramework)</ept> commands as well as the <bpt id=\"p2\">[</bpt><ph id=\"ph1\">`dotnet test`</ph><ept id=\"p2\">](dotnet-test.md)</ept> command.","pos":[6402,6561],"source":"A prime example of this are [Entity Framework (EF)](https://github.com/aspnet/EntityFramework) commands as well as the [`dotnet test`](dotnet-test.md) command."},{"content":"In both cases, there is a tool that is referenced in the <ph id=\"ph1\">`tools`</ph> node of the <ph id=\"ph2\">`project.json`</ph> and that is the main dispatcher.","pos":[6562,6687],"source":" In both \ncases, there is a tool that is referenced in the `tools` node of the `project.json` and that is the main dispatcher."},{"content":"The user invokes this tool on the command line.","pos":[6688,6736],"source":" The \nuser invokes this tool on the command line."},{"content":"The second piece of the puzzle is the dependency that is given in the project's main dependencies (either root ones or framework-specific ones).","pos":[6737,6882],"source":" The second piece of the puzzle is the dependency that is given in the \nproject's main dependencies (either root ones or framework-specific ones)."},{"content":"This package contains the actual logic of the tool.","pos":[6883,6935],"source":" This package contains the actual logic of \nthe tool."},{"content":"The package is a normal dependency, thus it will be restored as part of the restore process for the project.","pos":[6936,7044]},{"content":"Unlike the previous kind of tools, these tool are actually part of the graph of the project that consumes them.","pos":[7047,7158]},{"content":"This is because they need access to the project's code and potentially all of its dependencies.","pos":[7159,7255],"source":" This is \nbecause they need access to the project's code and potentially all of its dependencies."},{"content":"For instance, the EF tools need this because they need to scan the assemblies to find the code they need, such as migrations.","pos":[7256,7382],"source":" For instance, the EF tools need \nthis because they need to scan the assemblies to find the code they need, such as migrations."},{"content":"Another reason why this two-pronged solution exists is to allow a cleaner invocation model.","pos":[7386,7477]},{"content":"Most CLI commands that drop certain artifacts on disk (for example, <ph id=\"ph1\">`dotnet build`</ph>, <ph id=\"ph2\">`dotnet publish`</ph>) allow users to redirect the outputs to a different path using the <ph id=\"ph3\">`--output`</ph> argument or <ph id=\"ph4\">`--build-base-path`</ph> argument or <ph id=\"ph5\">`--configuration`</ph> argument.","pos":[7478,7730],"source":" Most CLI commands that \ndrop certain artifacts on disk (for example, `dotnet build`, `dotnet publish`) allow users to redirect the outputs to a different \npath using the `--output` argument or `--build-base-path` argument or `--configuration` argument."},{"content":"For EF tools, for example, to be able to find the build output of your project, you would have to provide the same arguments with the same values to <bpt id=\"p1\">*</bpt>both<ept id=\"p1\">*</ept> <ph id=\"ph1\">`dotnet`</ph> driver as well as the <ph id=\"ph2\">`ef`</ph> command.","pos":[7731,7933],"source":" For EF tools, for \nexample, to be able to find the build output of your project, you would have to provide the same arguments with the same \nvalues to *both* `dotnet` driver as well as the `ef` command."},{"content":"With the invocation model, the users pass any arguments to the dispatcher tool which can then use that to find the needed binary that contains the logic in the output directories.","pos":[7934,8114],"source":" With the invocation model, the users pass any arguments to \nthe dispatcher tool which can then use that to find the needed binary that contains the logic in the output directories."},{"pos":[8117,8221],"content":"A good example of this approach can be found in the <bpt id=\"p1\">[</bpt>.NET Core CLI repo<ept id=\"p1\">](https://github.com/dotnet/cli)</ept>:","source":"A good example of this approach can be found in the [.NET Core CLI repo](https://github.com/dotnet/cli):"},{"content":"Sample project.json file","pos":[8226,8250]},{"content":"Implementation of the dispatcher","pos":[8396,8428]},{"content":"Implementation of the framework-specific dependency","pos":[8543,8594]},{"content":"PATH-based extensibility","pos":[8709,8733]},{"content":"PATH-based extensibility is usually used for development machines where you need a tool that conceptually covers more than a single project.","pos":[8734,8875],"source":"PATH-based extensibility is usually used for development machines where you need a tool that conceptually covers more \nthan a single project."},{"content":"The main drawback of this extensions mechanism is that it is tied to the machine where the tool exists.","pos":[8876,8980],"source":" The main drawback of this extensions mechanism is that it is tied to the machine where the \ntool exists."},{"content":"If you need it on another machine, you would have to deploy it.","pos":[8981,9044]},{"content":"This pattern of CLI toolset extensibility is very simple.","pos":[9046,9103]},{"content":"As covered in the <bpt id=\"p1\">[</bpt>.NET Core CLI overview<ept id=\"p1\">](index.md)</ept>, <ph id=\"ph1\">`dotnet`</ph> driver can run any command that is named after the <ph id=\"ph2\">`dotnet &lt;command&gt;`</ph> convention.","pos":[9104,9249],"source":" As covered in the [.NET Core CLI overview](index.md), `dotnet` driver \ncan run any command that is named after the `dotnet <command>` convention."},{"content":"The default resolution logic will first probe several locations and will finally fall to the system PATH.","pos":[9250,9356],"source":" The default resolution logic will first \nprobe several locations and will finally fall to the system PATH."},{"content":"If the requested command exists in the system PATH and is a binary that can be invoked, <ph id=\"ph1\">`dotnet`</ph> driver will invoke it.","pos":[9357,9477],"source":" If the requested command exists in the system PATH \nand is a binary that can be invoked, `dotnet` driver will invoke it."},{"content":"The binary can be pretty much anything that the operating system can execute.","pos":[9480,9557]},{"content":"On Unix systems, this means anything that has the execute bit set via <ph id=\"ph1\">`chmod +x`</ph>.","pos":[9558,9640],"source":" On Unix systems, this means anything that \nhas the execute bit set via `chmod +x`."},{"content":"On Windows it means anything that Windows knows how to run.","pos":[9641,9700]},{"content":"As an example, let's take a look at a very simple implementation of a <ph id=\"ph1\">`dotnet clean`</ph> command.","pos":[9703,9796],"source":"As an example, let's take a look at a very simple implementation of a `dotnet clean` command."},{"content":"We will use <ph id=\"ph1\">`bash`</ph> to implement this command.","pos":[9797,9843],"source":" We will use `bash` to \nimplement this command."},{"content":"The command will simply delete the <ph id=\"ph1\">`bin/`</ph> and <ph id=\"ph2\">`obj/`</ph> directories in the current directory.","pos":[9844,9934],"source":" The command will simply delete the `bin/` and `obj/` directories in the current directory."},{"content":"If the <ph id=\"ph1\">`--lock`</ph> argument is passed to it, it will also delete <ph id=\"ph2\">`project.lock.json`</ph> file.","pos":[9935,10023],"source":" If \nthe `--lock` argument is passed to it, it will also delete `project.lock.json` file."},{"content":"The entirety of the command is given below.","pos":[10024,10068],"source":" The entirety of the command is \ngiven below."},{"content":"On macOS, we can save this script as <ph id=\"ph1\">`dotnet-clean`</ph> and set its executable bit with <ph id=\"ph2\">`chmod +x dotnet-clean`</ph>.","pos":[10255,10363],"source":"On macOS, we can save this script as `dotnet-clean` and set its executable bit with `chmod +x dotnet-clean`."},{"content":"We can then create a symbolic link to it in <ph id=\"ph1\">`/usr/local/bin`</ph> using the command <ph id=\"ph2\">`ln -s dotnet-clean /usr/local/bin/`</ph>.","pos":[10364,10481],"source":" We can then \ncreate a symbolic link to it in `/usr/local/bin` using the command `ln -s dotnet-clean /usr/local/bin/`."},{"content":"This will make it possible to invoke the clean command using the <ph id=\"ph1\">`dotnet clean`</ph> syntax.","pos":[10482,10570],"source":" This will make \nit possible to invoke the clean command using the `dotnet clean` syntax."},{"content":"You can test this by creating an app, running <ph id=\"ph1\">`dotnet build`</ph> on it and then running <ph id=\"ph2\">`dotnet clean`</ph>.","pos":[10571,10671],"source":" You can test this by creating an app, running \n`dotnet build` on it and then running `dotnet clean`."},{"content":"Conclusion","pos":[10677,10687]},{"content":"The .NET Core CLI tools allow two main extensibility points.","pos":[10688,10748]},{"content":"The per-project tools are contained within the project's context, but they allow easy installation through restoration.","pos":[10749,10869],"source":" The per-project tools are contained within the project's \ncontext, but they allow easy installation through restoration."},{"content":"PATH-based tools are good for general, cross-project tools that are usable on a single machine.","pos":[10870,10966],"source":" PATH-based tools are good for general, cross-project \ntools that are usable on a single machine."}],"content":"---\ntitle: .NET Core CLI extensibility model \ndescription: .NET Core CLI extensibility model \nkeywords: .NET, .NET Core\nauthor: mairaw\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: 1bebd25a-120f-48d3-8c25-c89965afcbcd\n---\n\n# .NET Core CLI extensibility model \n\n## Overview\nThis document will cover the main ways how to extend the CLI tools and explain the scenarios that drive each of them. \nIt will the outline how to consume the tools as well as provide short notes on how to build both types of tools. \n\n## How to extend CLI tools\nThe CLI tools can be extended in two main ways:\n\n1. Via NuGet packages on a per-project basis\n2. Via the system's PATH\n\nThe two extensibility mechanisms outlined above are not exclusive; you can use both or just one. Which one to pick \ndepends largely on what is the goal you are trying to achieve with your extension.\n\n## Per-project based extensibility\nPer-project tools are [portable console applications](../app-types.md) that are distributed as NuGet packages. Tools are \nonly available in the context of the project that references them and for which they are restored; invocation outside \nof the context of the project (for example, outside of the directory that contains the project) will fail as the command will \nnot be able to be found.\n\nThese tools are perfect for build servers as well, since nothing outside of `project.json` is needed. The build process \nruns restore for the project it builds and tools will be available. Language projects, such as F#, are also in this \ncategory; after all, each project can only be written in one specific language. \n\nFinally, this extensibility model provides support for creation of tools that need access to the built output of the \nproject. For instance, various Razor view tools in [ASP.NET](https://www.asp.net/) MVC applications fall into this \ncategory. \n\n### Consuming per-project tools\nConsuming these tools requires you to add a `tools` node to your `project.json`. Inside the `tools` node, you reference\nthe package in which the tool resides. After running `dotnet restore`, the tool and its dependencies are restored. \n\nFor tools that need to load the build output of the project for execution, there is usually another dependency which is \nlisted under the regular dependencies in the project file. This means that tools that load project's code have two \ncomponents: \n\n1. The \"tools\" main invoker\n2. Any number of other tools that contain the logic to work with \n\nWhy two things? Tools that need to load the build output of a project need to have unified dependency graph with the \nproject they are working. By adding the dependency bit, we enable NuGet to resolve these dependencies as a unified \ngraph. The invoker is there because it needs to reason about the location as well as the frameworks of the dependency \ntool. The invoker can accept all of the redirection arguments (`-c`, `-o`, `-b`) that the user specifies and finds the \ndependency tool; it can also implement any policies for cases where multiple dependency tools exist for multiple \nframeworks (that is, does it run all of them, just one, etc.) In general, logic can be shared between these two tools any way \nthat is needed. \n\nLet's review an example of adding a simple tools-only tool to a simple project. Given an example command called \n`dotnet-api-search` that allows you to search through the NuGet packages for the specified \nAPI, here is a console application's `project.json` file that uses that tool:\n\n```json\n{\n    \"version\": \"1.0.0\",\n    \"compilationOptions\": {\n        \"emitEntryPoint\": true\n    },\n    \"dependencies\": {\n        \"Microsoft.NETCore.App\": {\n            \"type\": \"platform\",\n            \"version\": \"1.0.0\"\n        }\n    },\n    \"tools\": {\n        \"dotnet-api-search\": {\n            \"version\": \"1.0.0\",\n            \"imports\": [\"dnxcore50\"]\n        }\n    },\n    \"frameworks\": {\n        \"netcoreapp1.0\": {}\n    }\n}\n```\n\nThe `tools` node is structured in a similar way as the `dependencies` node. It needs the package ID of the package \ncontaining the tool and its version at the very least. In the example above, we can see that there is another statement, \nthe `imports` one. This influences the tool's restore process and specifies that the tool is also compatible, in \naddition to any targeted frameworks the tools has, with `dnxcore50` target. For more information you can \nconsult the [project.json reference](project-json.md).\n\n### Building tools\nAs mentioned, tools are just portable console applications. You would build one as you would build any console application. \nAfter you build it, you would use [`dotnet pack`](dotnet-pack.md) command to create a NuGet package (nupkg) that contains \nyour code, information about its dependencies and so on. The package name can be whatever the author wants, but the \napplication inside, the actual tool binary, has to conform to the convention of `dotnet-<command>` in order for `dotnet` \nto be able to invoke it. \n\nSince tools are portable applications, the user consuming the tool has to have the version of the .NET Core libraries \nthat the tool was built against in order to run the tool. Any other dependency that the tool uses and that is not \ncontained within the .NET Core libraries is restored and placed in the NuGet cache. The entire tool is, therefore, run \nusing the assemblies from the .NET Core libraries as well as assemblies from the NuGet cache. \n\nThese kind of tools have a dependency graph that is completely separate from the dependency graph of the project that \nuses them. The restore process will first restore the project's dependencies, and will then restore each of the tools and \ntheir dependencies. \n\nYou can find richer examples and different combinations of this in the [.NET Core CLI repo](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestProjects). \nYou can also see the [implementation of tools used](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages) in the same repo. \n\nBuilding tools that load project's build outputs for execution is slightly different. As stated, for these kinds of \ntools there are two components:\n\n1. A dispatcher tool that the user invokes\n2. A framework-specific dependency that contains the logic on how to find the build outputs and what to do with it\n\nA prime example of this are [Entity Framework (EF)](https://github.com/aspnet/EntityFramework) commands as well as the [`dotnet test`](dotnet-test.md) command. In both \ncases, there is a tool that is referenced in the `tools` node of the `project.json` and that is the main dispatcher. The \nuser invokes this tool on the command line. The second piece of the puzzle is the dependency that is given in the \nproject's main dependencies (either root ones or framework-specific ones). This package contains the actual logic of \nthe tool. The package is a normal dependency, thus it will be restored as part of the restore process for the project. \n\nUnlike the previous kind of tools, these tool are actually part of the graph of the project that consumes them. This is \nbecause they need access to the project's code and potentially all of its dependencies. For instance, the EF tools need \nthis because they need to scan the assemblies to find the code they need, such as migrations.  \n\nAnother reason why this two-pronged solution exists is to allow a cleaner invocation model. Most CLI commands that \ndrop certain artifacts on disk (for example, `dotnet build`, `dotnet publish`) allow users to redirect the outputs to a different \npath using the `--output` argument or `--build-base-path` argument or `--configuration` argument. For EF tools, for \nexample, to be able to find the build output of your project, you would have to provide the same arguments with the same \nvalues to *both* `dotnet` driver as well as the `ef` command. With the invocation model, the users pass any arguments to \nthe dispatcher tool which can then use that to find the needed binary that contains the logic in the output directories. \n\nA good example of this approach can be found in the [.NET Core CLI repo](https://github.com/dotnet/cli):\n\n* [Sample project.json file](https://github.com/dotnet/cli/blob/rel/1.0.0-preview2/TestAssets/DesktopTestProjects/AppWithDirectDependencyDesktopAndPortable/project.json)\n* [Implementation of the dispatcher](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages/dotnet-dependency-tool-invoker)\n* [Implementation of the framework-specific dependency](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages/dotnet-desktop-and-portable)\n\n\n### PATH-based extensibility\nPATH-based extensibility is usually used for development machines where you need a tool that conceptually covers more \nthan a single project. The main drawback of this extensions mechanism is that it is tied to the machine where the \ntool exists. If you need it on another machine, you would have to deploy it.\n\nThis pattern of CLI toolset extensibility is very simple. As covered in the [.NET Core CLI overview](index.md), `dotnet` driver \ncan run any command that is named after the `dotnet <command>` convention. The default resolution logic will first \nprobe several locations and will finally fall to the system PATH. If the requested command exists in the system PATH \nand is a binary that can be invoked, `dotnet` driver will invoke it. \n\nThe binary can be pretty much anything that the operating system can execute. On Unix systems, this means anything that \nhas the execute bit set via `chmod +x`. On Windows it means anything that Windows knows how to run. \n\nAs an example, let's take a look at a very simple implementation of a `dotnet clean` command. We will use `bash` to \nimplement this command. The command will simply delete the `bin/` and `obj/` directories in the current directory. If \nthe `--lock` argument is passed to it, it will also delete `project.lock.json` file. The entirety of the command is \ngiven below. \n\n```bash\n#!/bin/bash\n\n# Delete the bin and obj dirs\nrm -rf bin/ obj/\n\nLOCK_FILE=$1\nif [[ \"$LOCK_FILE\" = \"--lock\" ]]; then\n    rm project.lock.json\nfi\n\n\necho \"Cleaning complete...\"\n```\n\nOn macOS, we can save this script as `dotnet-clean` and set its executable bit with `chmod +x dotnet-clean`. We can then \ncreate a symbolic link to it in `/usr/local/bin` using the command `ln -s dotnet-clean /usr/local/bin/`. This will make \nit possible to invoke the clean command using the `dotnet clean` syntax. You can test this by creating an app, running \n`dotnet build` on it and then running `dotnet clean`. \n\n## Conclusion\nThe .NET Core CLI tools allow two main extensibility points. The per-project tools are contained within the project's \ncontext, but they allow easy installation through restoration. PATH-based tools are good for general, cross-project \ntools that are usable on a single machine. \n"}