{"nodes":[{"pos":[11,22],"content":"REST client","needQuote":true,"nodes":[{"content":"REST client","pos":[0,11]}]},{"pos":[36,47],"content":"REST client","needQuote":true,"nodes":[{"content":"REST client","pos":[0,11]}]},{"pos":[58,73],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":"REST client","pos":[281,292]},{"content":"Introduction","pos":[297,309]},{"content":"This tutorial teaches you a number of features in .NET Core and the C# language.","pos":[310,390]},{"content":"You’ll learn:","pos":[391,404]},{"content":"The basics of the .NET Core Command Line Interface (CLI).","pos":[409,466]},{"content":"An overview of C# Language features.","pos":[471,507]},{"content":"Managing dependencies with NuGet","pos":[512,544]},{"content":"HTTP Communications","pos":[549,568]},{"content":"Processing JSON information","pos":[573,600]},{"content":"Managing configuration with Attributes.","pos":[605,644]},{"content":"You’ll build an application that issues HTTP Requests to a REST service on GitHub.","pos":[647,729],"source":"You’ll build an application that issues HTTP Requests to a REST\nservice on GitHub."},{"content":"You'll read information in JSON format, and convert that JSON packet into C# objects.","pos":[730,815],"source":" You'll read information in JSON format, and convert\nthat JSON packet into C# objects."},{"content":"Finally, you'll see how to work with C# objects.","pos":[816,864],"source":" Finally, you'll see how to work with\nC# objects."},{"content":"There are a lot of features in this tutorial.","pos":[866,911]},{"content":"Let’s build them one by one.","pos":[912,940]},{"content":"Prerequisites","pos":[945,958]},{"content":"You’ll need to setup your machine to run .NET core.","pos":[959,1010]},{"content":"You can find the installation instructions on the <bpt id=\"p1\">[</bpt>.NET Core<ept id=\"p1\">](https://www.microsoft.com/net/core)</ept> page.","pos":[1011,1114],"source":" You can find the\ninstallation instructions on the [.NET Core](https://www.microsoft.com/net/core)\npage."},{"content":"You can run this application on Windows, Linux, macOS or in a Docker container.","pos":[1115,1194],"source":" You can run this\napplication on Windows, Linux, macOS or in a Docker container."},{"content":"You’ll need to install your favorite code editor.","pos":[1195,1245],"source":" \nYou’ll need to install your favorite code editor."},{"content":"The descriptions below use <bpt id=\"p1\">[</bpt>Visual Studio Code<ept id=\"p1\">](https://code.visualstudio.com/)</ept> which is an open source, cross platform editor.","pos":[1246,1373],"source":" The descriptions below\nuse [Visual Studio Code](https://code.visualstudio.com/) which is an open\nsource, cross platform editor."},{"content":"However, you can use whatever tools you are comfortable with.","pos":[1374,1435],"source":" However, you can use whatever tools you are\ncomfortable with."},{"content":"Create the Application","pos":[1439,1461]},{"content":"The first step is to create a new application.","pos":[1462,1508]},{"content":"Open a command prompt and create a new directory for your application.","pos":[1509,1579],"source":" Open a command prompt and\ncreate a new directory for your application."},{"content":"Make that the current directory.","pos":[1580,1612],"source":" Make that the current\ndirectory."},{"content":"Type the command \"dotnet new\" at the command prompt.","pos":[1613,1665]},{"content":"This creates the starter files for a basic “Hello World” application.","pos":[1666,1735],"source":" This\ncreates the starter files for a basic “Hello World” application."},{"content":"Before you start making modifications, let’s go through the steps to run the simple Hello World application.","pos":[1737,1845],"source":"Before you start making modifications, let’s go through the steps to run\nthe simple Hello World application."},{"content":"After creating the application, type \"dotnet restore\" at the command prompt.","pos":[1846,1922],"source":" After creating the application, type\n\"dotnet restore\" at the command prompt."},{"content":"This command runs the NuGet package restore process.","pos":[1923,1975],"source":" This command runs the NuGet\npackage restore process."},{"content":"NuGet is a .NET package manager.","pos":[1976,2008]},{"content":"This command downloads any of the missing dependencies for your project.","pos":[2009,2081],"source":" This command\ndownloads any of the missing dependencies for your project."},{"content":"As this is a new project, none of the dependencies are in place, so the first run will download the .NET Core framework.","pos":[2082,2202],"source":" As this is a\nnew project, none of the dependencies are in place, so the first run will\ndownload the .NET Core framework."},{"content":"After this initial step, you will only need to run dotnet restore when you add new dependent packages, or update the versions of any of your dependencies.","pos":[2203,2357],"source":" After this initial step, you will only\nneed to run dotnet restore when you add new dependent packages, or update\nthe versions of any of your dependencies."},{"content":"This process also creates the project lock file (project.lock.json) in your project directory.","pos":[2358,2452],"source":" This process also creates the\nproject lock file (project.lock.json) in your project directory."},{"content":"This file helps to manage the project dependencies.","pos":[2453,2504],"source":" This file\nhelps to manage the project dependencies."},{"content":"It contains the local location of all the project dependencies.","pos":[2505,2568],"source":" It contains the local location\nof all the project dependencies."},{"content":"You do not need to put the file in source control; it will be generated when you run “dotnet restore”.","pos":[2569,2671],"source":" You do not need to put the file in source\ncontrol; it will be generated when you run “dotnet restore”."},{"content":"After restoring packages, you run “dotnet build”.","pos":[2674,2723]},{"content":"This executes the build engine and creates your application.","pos":[2724,2784],"source":" This executes the build\nengine and creates your application."},{"content":"Finally, you execute “dotnet run” to run your application.","pos":[2785,2843],"source":" Finally, you execute “dotnet run” to\nrun your application."},{"content":"Adding New Dependencies","pos":[2848,2871]},{"content":"One of the key design goals for .NET Core is to minimize the size of the .NET framework installation.","pos":[2872,2973],"source":"One of the key design goals for .NET Core is to minimize the size of\nthe .NET framework installation."},{"content":"The .NET Core Application framework contains only the most common elements of the .NET full framework.","pos":[2974,3076],"source":" The .NET Core Application framework contains\nonly the most common elements of the .NET full framework."},{"content":"This application needs more libraries for some of its features.","pos":[3077,3140],"source":" This application\nneeds more libraries for some of its features."},{"content":"You'll add those dependencies into your project.json file.","pos":[3141,3199],"source":" You'll add those\ndependencies into your project.json file."},{"content":"You'll need to add the <ph id=\"ph1\">`System.Net.Http`</ph> package so that your application can make HTTP requests.","pos":[3200,3297],"source":" You'll need to add the\n`System.Net.Http` package so that your application can make HTTP requests."},{"content":"You'll also need to add the <ph id=\"ph1\">`System.Runtime.Serialization.Json`</ph> package so your application can process JSON responses.","pos":[3298,3417],"source":"\nYou'll also need to add the `System.Runtime.Serialization.Json` package\nso your application can process JSON responses."},{"content":"Open your project.json file.","pos":[3419,3447]},{"content":"Look for the dependencies section.","pos":[3448,3482]},{"content":"You should see one line that looks similar to this:","pos":[3483,3534],"source":" You should\nsee one line that looks similar to this:"},{"content":"You'll add two lines to this section to include the two new libraries:","pos":[3658,3728]},{"content":"Most code editors will provide completion for different versions of these libraries.","pos":[3957,4041],"source":"Most code editors will provide completion for different versions of these\nlibraries."},{"content":"You'll usually want to use the latest version of any package that you add.","pos":[4042,4116],"source":" You'll usually want to use the latest version of any package\nthat you add."},{"content":"However, it is important to make sure that the versions of all packages match, and that they also match the version of the .NET Core Application framework.","pos":[4117,4272],"source":" However, it is important to make sure that the versions\nof all packages match, and that they also match the version of the .NET\nCore Application framework."},{"pos":[4274,4397],"content":"After you've made these changes, you should run \"dotnet restore\" again so that those packages are installed on your system.","source":"After you've made these changes, you should run \"dotnet restore\" again so\nthat those packages are installed on your system."},{"content":"Making Web Requests","pos":[4402,4421]},{"content":"Now you're ready to start retrieving data from the web.","pos":[4422,4477]},{"content":"In this application, you'll read information from the <bpt id=\"p1\">[</bpt>GitHub API<ept id=\"p1\">](https://developer.github.com/v3/)</ept>.","pos":[4478,4580],"source":" In this\napplication, you'll read information from the \n[GitHub API](https://developer.github.com/v3/)."},{"content":"Let's read information about the projects under the <bpt id=\"p1\">[</bpt>.NET Foundation<ept id=\"p1\">](http://www.dotnetfoundation.org/)</ept> umbrella.","pos":[4581,4694],"source":" Let's read information\nabout the projects under the\n[.NET Foundation](http://www.dotnetfoundation.org/) umbrella."},{"content":"You'll start by making the request to the GitHub API to retrieve information on the projects.","pos":[4695,4788],"source":" You'll\nstart by making the request to the GitHub API to retrieve information\non the projects."},{"content":"The endpoint you'll use is: <bpt id=\"p1\">[</bpt>https://api.github.com/orgs/dotnet/repos<ept id=\"p1\">](https://api.github.com/orgs/dotnet/repos)</ept>.","pos":[4789,4902],"source":" The endpoint you'll use is: [https://api.github.com/orgs/dotnet/repos](https://api.github.com/orgs/dotnet/repos)."},{"content":"You want to retrieve all the information about these projects, so you'll use an HTTP GET request.","pos":[4903,5000],"source":" You want to retrieve all the\ninformation about these projects, so you'll use an HTTP GET request."},{"content":"Your browser also uses HTTP GET requests, so you can paste that URL into your browser to see what information you'll be receiving and processing.","pos":[5001,5146],"source":"\nYour browser also uses HTTP GET requests, so you can paste that URL into\nyour browser to see what information you'll be receiving and processing."},{"content":"You use the <ph id=\"ph1\">`HttpClient`</ph> class to make web requests.","pos":[5148,5200],"source":"You use the `HttpClient` class to make web requests."},{"content":"Like all modern .NET APIs, <ph id=\"ph1\">`HttpClient`</ph> supports only async methods for its long-running APIs.","pos":[5201,5295],"source":" Like all modern .NET\nAPIs, `HttpClient` supports only async methods for its long-running APIs."},{"content":"Start by making an async method.","pos":[5296,5328],"source":"\nStart by making an async method."},{"content":"You'll fill in the implementation as you build the functionality of the application.","pos":[5329,5413],"source":" You'll fill in the implementation as you\nbuild the functionality of the application."},{"pos":[5484,5607],"content":"You'll need to add a using statement at the top of your <ph id=\"ph1\">`Main()`</ph> method so that the C# compiler recognizes the <ph id=\"ph2\">`Task`</ph> type:","source":"You'll need to add a using statement at the top of your `Main()` method so\nthat the C# compiler recognizes the `Task` type:"},{"content":"If you build your project at this point, you'll get a warning generated for this method, because it does not contain any <ph id=\"ph1\">`await`</ph> operators and will run synchronously.","pos":[5650,5816],"source":"If you build your project at this point, you'll get a warning generated\nfor this method, because it does not contain any `await` operators and\nwill run synchronously."},{"content":"Ignore that for now, you'll add <ph id=\"ph1\">`await`</ph> operators as you fill in the method.","pos":[5817,5893],"source":" Ignore that for now, you'll add `await` operators\nas you fill in the method."},{"content":"Next, update the <ph id=\"ph1\">`Main()`</ph> method to call this method.","pos":[5895,5948],"source":"Next, update the `Main()` method to call this method."},{"content":"The <ph id=\"ph1\">`ProcessRepositories()`</ph> method returns a Task, and you shouldn't exit the program before that task finishes.","pos":[5949,6061],"source":" The\n`ProcessRepositories()` method returns a Task, and you shouldn't exit the\nprogram before that task finishes."},{"content":"Therefore, you must use the <ph id=\"ph1\">`Wait()`</ph> method to block and wait for the task to finish:","pos":[6062,6147],"source":" Therefore, you must use the `Wait()`\nmethod to block and wait for the task to finish:"},{"content":"Now, you have a program that does nothing, but does it asynchronously.","pos":[6237,6307]},{"content":"Let's go back to the <ph id=\"ph1\">`ProcessRepositories()`</ph> method and fill in a first version of it:","pos":[6308,6394],"source":" Let's go back to the\n`ProcessRepositories()` method and fill in a first version of it:"},{"content":"You'll need to also add two new using statements at the top of the file for this to compile:","pos":[6905,6997]},{"content":"This first version makes a web request to read the list of all repositories under the dotnet foundation organization.","pos":[7064,7181],"source":"This first version makes a web request to read the list of all repositories under the dotnet\nfoundation organization."},{"content":"(The gitHub ID for the .NET Foundation is 'dotnet').","pos":[7182,7234]},{"content":"First, you create a new <ph id=\"ph1\">`HttpClient`</ph>.","pos":[7235,7272],"source":" First, you create\na new `HttpClient`."},{"content":"This object handles the request and the responses.","pos":[7273,7323]},{"content":"The next few lines setup the <ph id=\"ph1\">`HttpClient`</ph> for this request.","pos":[7324,7383],"source":" The next few lines setup\nthe `HttpClient` for this request."},{"content":"First, it is configured to accept the GitHub JSON responses.","pos":[7384,7444]},{"content":"This format is simply JSON.","pos":[7445,7472],"source":"\nThis format is simply JSON."},{"content":"The next line adds a User Agent header to all requests from this object.","pos":[7473,7545],"source":" The next line adds a User Agent header to all requests from this\nobject."},{"content":"These two headers are checked by the GitHub server code, and are necessary to retrieve information from GitHub.","pos":[7546,7657],"source":" These two headers are checked by the GitHub server code, and are necessary to retrieve\ninformation from GitHub."},{"content":"After you've configured the <ph id=\"ph1\">`HttpClient`</ph>, you make a web request, and retrieve the response.","pos":[7659,7751],"source":"After you've configured the `HttpClient`, you make a web request, and retrieve the response."},{"content":"In this first version, you use the <ph id=\"ph1\">`GetStringAsync`</ph> convenience method.","pos":[7752,7823],"source":" In\nthis first version, you use the `GetStringAsync` convenience method."},{"content":"This convenience method starts a task that makes the web request, and then when the request returns, it will read the response stream, and extract the content from the stream.","pos":[7824,7999],"source":" This convenience method\nstarts a task that makes the web request, and then when the request returns, it will read the\nresponse stream, and extract the content from the stream."},{"content":"The body of the response is returned as a <ph id=\"ph1\">`string`</ph>.","pos":[8000,8051],"source":" The body of the response is returned\nas a `string`."},{"content":"The string is available when the task completes.","pos":[8052,8100]},{"content":"The final two lines of this method await that task, and then print the response to the console.","pos":[8103,8198]},{"content":"Build the app, and run it.","pos":[8199,8225],"source":"\nBuild the app, and run it."},{"content":"The build warning is gone now, because the <ph id=\"ph1\">`ProcessRepositories`</ph> now does contain an <ph id=\"ph2\">`await`</ph> operator.","pos":[8226,8328],"source":" The build warning is gone now, because the `ProcessRepositories` now\ndoes contain an `await` operator."},{"content":"You'll see a long display of JSON formatted text.","pos":[8329,8378]},{"content":"Processing the JSON Result","pos":[8386,8412]},{"content":"At this point, you've written the code to retrieve a response from a web server, and display the text that is contained in that response.","pos":[8414,8551],"source":"At this point, you've written the code to retrieve a response from a web server, and display\nthe text that is contained in that response."},{"content":"Next, let's convert that JSON response into C# objects.","pos":[8552,8607],"source":" Next, let's convert that JSON response into C#\nobjects."},{"content":"The JSON Serializer converts JSON data into C# Objects.","pos":[8609,8664]},{"content":"Your first task is to define a C# class type to contain the information you use from this response.","pos":[8665,8764],"source":" Your first task is to define a C# class\ntype to contain the information you use from this response."},{"content":"Let's build this slowly, so start with a simple C# type that contains the name of the repository:","pos":[8765,8862],"source":" Let's build this slowly, so start with\na simple C# type that contains the name of the repository:"},{"content":"Put the above code in a new file called 'repo.cs'.","pos":[8965,9015]},{"content":"This version of the class represents the simplest path to process JSON data.","pos":[9016,9092],"source":" This version of the class represents the\nsimplest path to process JSON data."},{"content":"The class name and the member name match the names used in the JSON packet, instead of following C# conventions.","pos":[9093,9205],"source":" The class name and the member name match the names used\nin the JSON packet, instead of following C# conventions."},{"content":"You'll fix that by providing some configuration attributes later.","pos":[9206,9271],"source":" You'll fix that by providing some\nconfiguration attributes later."},{"content":"This class demonstrates another important feature of JSON serialization and deserialization: Not all the fields in the JSON packet are part of this class.","pos":[9272,9426],"source":" This class demonstrates another important feature of JSON\nserialization and deserialization: Not all the fields in the JSON packet are part of this class."},{"content":"The JSON serializer will ignore information that is not included in the class type being used.","pos":[9427,9521],"source":"\nThe JSON serializer will ignore information that is not included in the class type being used."},{"content":"This feature makes it easier to create types that work with only a subset of the fields in the JSON packet.","pos":[9522,9629],"source":"\nThis feature makes it easier to create types that work with only a subset of the fields in\nthe JSON packet."},{"content":"Now that you've created the type, let's deserialize it.","pos":[9631,9686]},{"content":"You'll need to create a <ph id=\"ph1\">`DataContractJsonSerializer`</ph> object.","pos":[9687,9747],"source":" You'll need to create a\n`DataContractJsonSerializer` object."},{"content":"This object must know the CLR type expected for the JSON packet it retrieves.","pos":[9748,9825],"source":" This object must know the CLR type expected for the\nJSON packet it retrieves."},{"content":"The packet from GitHub contains a sequence of repositories, so a <ph id=\"ph1\">`List&lt;repo&gt;`</ph> is the correct type.","pos":[9826,9924],"source":" The packet from GitHub contains a sequence of repositories, so a\n`List<repo>` is the correct type."},{"content":"Add the following line to your <ph id=\"ph1\">`ProcessRepositories`</ph> method:","pos":[9925,9985],"source":" Add the following line to your `ProcessRepositories` method:"},{"content":"You're using two new namespaces, so you'll need to add those as well:","pos":[10067,10136]},{"content":"Next, you'll use the serializer to convert JSON into C# objects.","pos":[10224,10288]},{"content":"Replace the call to <ph id=\"ph1\">`GetStringAsync()`</ph> in your <ph id=\"ph2\">`ProcessRepositories`</ph> method with the following two lines:","pos":[10289,10394],"source":" Replace the call to\n`GetStringAsync()` in your `ProcessRepositories` method with the following two lines:"},{"content":"Notice that you're now using <ph id=\"ph1\">`GetStreamAsync`</ph> instead of <ph id=\"ph2\">`GetStringAsync`</ph>.","pos":[10565,10639],"source":"Notice that you're now using `GetStreamAsync` instead of `GetStringAsync`."},{"content":"The serializer uses a stream instead of a string as its source.","pos":[10640,10703],"source":" The serializer\nuses a stream instead of a string as its source."},{"content":"Let's explain a couple features of the C# language that are being used in the second line above.","pos":[10704,10800],"source":" Let's explain a couple features of the C#\nlanguage that are being used in the second line above."},{"content":"The argument to <ph id=\"ph1\">`ReadObject`</ph> is an <ph id=\"ph2\">`await`</ph> expression.","pos":[10801,10855],"source":" The argument to `ReadObject` is an\n`await` expression."},{"content":"Await expressions can appear almost anywhere in your code, even though up to now, you've only seen them as part of an assignment statement.","pos":[10856,10995],"source":" Await expressions can appear almost anywhere in your code, even though\nup to now, you've only seen them as part of an assignment statement."},{"content":"Secondly, the <ph id=\"ph1\">`as`</ph> operator converts from the compile time type of <ph id=\"ph2\">`object`</ph> to <ph id=\"ph3\">`List&lt;repo&gt;`</ph>.","pos":[10997,11089],"source":"Secondly, the `as` operator converts from the compile time type of `object` to `List<repo>`."},{"content":"The declaration of <ph id=\"ph1\">`ReadObject`</ph> declares that it returns an object of type <ph id=\"ph2\">`System.Object`</ph>.","pos":[11090,11182],"source":" \nThe declaration of `ReadObject` declares that it returns an object of type `System.Object`."},{"content":"will return the type you specified when you constructed it (<ph id=\"ph1\">`List&lt;repo&gt;`</ph> in this tutorial).","pos":[11196,11287],"source":" will return the type you specified when you constructed it (`List<repo>` in\nthis tutorial)."},{"content":"If the conversion does not succeed, the <ph id=\"ph1\">`as`</ph> operator evaluates to <ph id=\"ph2\">`null`</ph>, instead of throwing an exception.","pos":[11288,11396],"source":" If the conversion does not succeed, the `as` operator evaluates to `null`,\ninstead of throwing an exception."},{"content":"You're almost done with this section.","pos":[11398,11435]},{"content":"Now that you've converted the JSON to C# objects, let's display the name of each repository:","pos":[11436,11528],"source":" Now that you've converted the JSON to C# objects, let's display\nthe name of each repository:"},{"content":"Compile and run the application.","pos":[11610,11642]},{"content":"It will print out the names of the repositories that are part of the .NET Foundation.","pos":[11643,11728],"source":" It will print out the names of the repositories that are part of the\n.NET Foundation."},{"content":"Controlling Serialization","pos":[11733,11758]},{"content":"Before you add more features, let's address the <ph id=\"ph1\">`repo`</ph> type and make it follow more standard C# conventions.","pos":[11760,11868],"source":"Before you add more features, let's address the `repo` type and make it follow more standard\nC# conventions."},{"content":"You'll do this by annotating the <ph id=\"ph1\">`repo`</ph> type with <bpt id=\"p1\">*</bpt>Attributes<ept id=\"p1\">*</ept> that control how the JSON Serializer works.","pos":[11869,11975],"source":" You'll do this by annotating the `repo` type with *Attributes* that control how\nthe JSON Serializer works."},{"content":"In your case, you'll use these attributes to define a mapping between the JSON key names and the C# class and member names.","pos":[11976,12099],"source":" In your case, you'll use these attributes to define a mapping between\nthe JSON key names and the C# class and member names."},{"content":"The two attributes used are the <ph id=\"ph1\">`DataContract`</ph> attribute and the <ph id=\"ph2\">`Data Member`</ph> attribute.","pos":[12100,12189],"source":" The two attributes used are the `DataContract`\nattribute and the `Data Member` attribute."},{"content":"By convention, all Attribute classes end in the suffix <ph id=\"ph1\">`Attribute`</ph>.","pos":[12190,12257],"source":" By convention, all Attribute classes end in the suffix\n`Attribute`."},{"content":"However, you do not need to use that suffix when you apply an attribute.","pos":[12258,12330]},{"content":"The <ph id=\"ph1\">`DataContract`</ph> and <ph id=\"ph2\">`DataMember`</ph> attributes are in a different library, so you'll need to add that library to project.json as a dependency.","pos":[12333,12475],"source":"The `DataContract` and `DataMember` attributes are in a different library, so you'll need to add\nthat library to project.json as a dependency."},{"content":"Add the following line to the dependencies section of the project.json file (remember to add the comma separator on the line above):","pos":[12476,12608],"source":" Add the following line to the dependencies section\nof the project.json file (remember to add the comma separator on the line above):"},{"pos":[12671,12780],"content":"After you save the file, run 'dotnet restore' to retrieve this package and update the project.json.lock file.","source":"After you save the file, run 'dotnet restore' to retrieve this package and update the project.json.lock\nfile."},{"content":"Next, open the repo.cs file.","pos":[12782,12810]},{"content":"Let's change the name to use Pascal Case, and fully spell out the name <ph id=\"ph1\">`Repository`</ph>.","pos":[12811,12895],"source":" Let's change the name to use Pascal Case, and fully spell out the name\n`Repository`."},{"content":"We still want to map JSON 'repo' nodes to this type, so you'll need to add the <ph id=\"ph1\">`DataContract`</ph> attribute to the class declaration.","pos":[12896,13026],"source":" We still want to map JSON 'repo' nodes to this type, so you'll need to add the \n`DataContract` attribute to the class declaration."},{"content":"YOu'll set the <ph id=\"ph1\">`Name`</ph> property of the attribute to the name of the JSON nodes that map to this type:","pos":[13027,13127],"source":" YOu'll set the `Name` property of the attribute\nto the name of the JSON nodes that map to this type:"},{"pos":[13192,13358],"content":"The <ph id=\"ph1\">`DataContractAttribute`</ph> is a member of the <ph id=\"ph2\">`System.Runtime.Serialization`</ph> namespace, so you'll need to add the appropriate using statement at the top of the file:","source":"The `DataContractAttribute` is a member of the `System.Runtime.Serialization` namespace, so you'll\nneed to add the appropriate using statement at the top of the file:"},{"pos":[13407,13612],"content":"You changed the name of the <ph id=\"ph1\">`repo`</ph> class to <ph id=\"ph2\">`Repository`</ph>, so you'll need to make the same name change in Program.cs (some editors may support a rename refactoring that will make this change automatically:)","source":"You changed the name of the `repo` class to `Repository`, so you'll need to make the same name change\nin Program.cs (some editors may support a rename refactoring that will make this change automatically:)"},{"content":"Next, let's make the same change with the <ph id=\"ph1\">`name`</ph> field, using the <ph id=\"ph2\">`DataMemberAttribute`</ph> class.","pos":[13789,13883],"source":"Next, let's make the same change with the `name` field, using the `DataMemberAttribute` class."},{"content":"Make the following changes to the declaration of the <ph id=\"ph1\">`name`</ph> field in repo.cs:","pos":[13884,13961],"source":" Make\nthe following changes to the declaration of the `name` field in repo.cs:"},{"content":"This change means you need to change the code that writes the name of each repository in program.cs:","pos":[14020,14120]},{"content":"Do a \"dotnet build\", followed by a \"dotnet run\" to make sure you've got the mappings correct.","pos":[14163,14256]},{"content":"You should see the same output as before.","pos":[14257,14298],"source":" You should\nsee the same output as before."},{"content":"Before we process more properties from the web server, let's make one more change to the <ph id=\"ph1\">`Repository`</ph> class.","pos":[14299,14407],"source":" Before we process more properties from the web server, let's make one\nmore change to the `Repository` class."},{"content":"The <ph id=\"ph1\">`Name`</ph> member is a publicly accessible field.","pos":[14408,14457],"source":" The `Name` member is a publicly accessible field."},{"content":"That's not a good object oriented practice, so let's change it to a property.","pos":[14458,14535],"source":" That's not\na good object oriented practice, so let's change it to a property."},{"content":"For our purposes, we don't need any specific code to run when getting or setting the property, but changing to a property makes it easier to add those changes later without breaking any code that uses the <ph id=\"ph1\">`Repository`</ph> class.","pos":[14536,14760],"source":" For our purposes, we don't need\nany specific code to run when getting or setting the property, but changing to a property makes it\neasier to add those changes later without breaking any code that uses the `Repository` class."},{"pos":[14762,14842],"content":"Remove the field definition, and replace it with an <bpt id=\"p1\">*</bpt>auto-implemented property<ept id=\"p1\">*</ept>:","source":"Remove the field definition, and replace it with an *auto-implemented property*:"},{"content":"The compiler generates the body of the <ph id=\"ph1\">`get`</ph> and <ph id=\"ph2\">`set`</ph> accessors, as well as a private field to store the name.","pos":[14888,14999],"source":"The compiler generates the body of the `get` and `set` accessors, as well as a private field to\nstore the name."},{"content":"It would be similar to the following code that you could type by hand:","pos":[15000,15070]},{"content":"Let's make one more change before adding new features.","pos":[15193,15247]},{"content":"The <ph id=\"ph1\">`ProcessRepositories`</ph> method can do the async work and return a collection of the repositories.","pos":[15248,15347],"source":" The `ProcessRepositories` method can do the async\nwork and return a collection of the repositories."},{"content":"Let's return the <ph id=\"ph1\">`List&lt;Repository&gt;`</ph> from that method, and move the code that writes the information into the <ph id=\"ph2\">`Main`</ph> method.","pos":[15348,15471],"source":" Let's return the `List<Repository>` from that method,\nand move the code that writes the information into the `Main` method."},{"pos":[15473,15583],"content":"Change the signature of <ph id=\"ph1\">`ProcessRepositories`</ph> to return a task whose result is a list of <ph id=\"ph2\">`Repository`</ph> objects:","source":"Change the signature of `ProcessRepositories` to return a task whose result is a list of `Repository`\nobjects:"},{"content":"Then, just return the repositories after processing the JSON response:","pos":[15662,15732]},{"content":"The compiler generates the <ph id=\"ph1\">`Task&lt;T&gt;`</ph> object for the return because you've marked this method as <ph id=\"ph2\">`async`</ph>.","pos":[15846,15950],"source":"The compiler generates the `Task<T>` object for the return because you've marked this method as `async`."},{"content":"Then, let's modify the <ph id=\"ph1\">`Main`</ph> method so that it captures those results and writes each repository name to the console.","pos":[15951,16069],"source":"\nThen, let's modify the `Main` method so that it captures those results and writes each repository name\nto the console."},{"content":"Your <ph id=\"ph1\">`Main`</ph> method now looks like this:","pos":[16070,16109],"source":" Your `Main` method now looks like this:"},{"content":"Accessing the <ph id=\"ph1\">`Result`</ph> property of a Task blocks until the task has completed.","pos":[16296,16374],"source":"Accessing the `Result` property of a Task blocks until the task has completed."},{"content":"Normally, you would prefer to <ph id=\"ph1\">`await`</ph> the completion of the task as in the <ph id=\"ph2\">`ProcessRepositories`</ph> method, but that isn't allowed in the <ph id=\"ph3\">`Main`</ph> method.","pos":[16375,16524],"source":" Normally, you would prefer\nto `await` the completion of the task as in the `ProcessRepositories` method, but that isn't allowed in the\n`Main` method."},{"content":"Reading More Information","pos":[16529,16553]},{"content":"Let's finish this by processing a few more of the properties in the JSON packet that gets sent from the GitHub API.","pos":[16555,16670],"source":"Let's finish this by processing a few more of the properties in the JSON packet that gets sent from the\nGitHub API."},{"content":"You won't want to grab everything, but adding a few properties will demonstrate a few more features of the C# language.","pos":[16671,16790],"source":" You won't want to grab everything, but adding a few properties will demonstrate a few more\nfeatures of the C# language."},{"content":"Let's start by adding a few more simple types to the <ph id=\"ph1\">`Repository`</ph> class definition.","pos":[16792,16875],"source":"Let's start by adding a few more simple types to the `Repository` class definition."},{"content":"Add these properties to that class:","pos":[16876,16911],"source":" Add these properties\nto that class:"},{"content":"These properties have built in conversions from the string type (which is what the JSON packets contain) to the target type.","pos":[17197,17321],"source":"These properties have built in conversions from the string type (which is what the JSON packets contain) to\nthe target type."},{"content":"The <ph id=\"ph1\">`Uri`</ph> type may be new to you.","pos":[17322,17355],"source":" The `Uri` type may be new to you."},{"content":"It represents a URI, or in this case, a URL.","pos":[17356,17400]},{"content":"In the case of the <ph id=\"ph1\">`Uri`</ph> and <ph id=\"ph2\">`int`</ph> types, if the JSON packet contains data that does not convert to the target type, the Serialization action will throw an exception.","pos":[17401,17567],"source":" In the case\nof the `Uri` and `int` types, if the JSON packet contains data that does not convert to the target type,\nthe Serialization action will throw an exception."},{"pos":[17569,17645],"content":"Once you've added these, update the <ph id=\"ph1\">`Main`</ph> method to display those elements:","source":"Once you've added these, update the `Main` method to display those elements:"},{"content":"As a final step, let's add the information for the last push operation.","pos":[17915,17986]},{"content":"This information is formatted in this fashion in the JSON response:","pos":[17987,18054],"source":" This information is formatted in\nthis fashion in the JSON response:"},{"content":"That format does not follow one of the standard .NET DateTime formats.","pos":[18086,18156]},{"content":"Because of that, you'll need to write a custom conversion method.","pos":[18157,18222],"source":" Because of that, you'll need to write\na custom conversion method."},{"content":"You also probably don't want the raw string exposed to uses of the <ph id=\"ph1\">`Repository`</ph> class.","pos":[18223,18309],"source":" You also probably don't want the raw string exposed to uses of the `Repository`\nclass."},{"content":"Attributes can help control that as well.","pos":[18310,18351]},{"content":"First, define a <ph id=\"ph1\">`private`</ph> property that will hold the string representation of the date time in your <ph id=\"ph2\">`Repository`</ph> class:","pos":[18352,18472],"source":" First, define a `private` property that will hold the\nstring representation of the date time in your `Repository` class:"},{"content":"The <ph id=\"ph1\">`DataMember`</ph> attribute informs the Serializer that this should be processed, even though it is not a public member.","pos":[18554,18673],"source":"The `DataMember` attribute informs the Serializer that this should be processed, even though it is not\na public member."},{"content":"Next, you need to write a public read only property that converts the string to a valid <ph id=\"ph1\">`DateTime`</ph> object, and returns that <ph id=\"ph2\">`DateTime`</ph>:","pos":[18674,18809],"source":" Next, you need to write a public read only property that converts the string to a\nvalid `DateTime` object, and returns that `DateTime`:"},{"content":"Let's go over the new constructs above.","pos":[18990,19029]},{"content":"The <ph id=\"ph1\">`IgnoreDatamember`</ph> attribute instructs the serializer that this type should not be read to or written from any JSON object.","pos":[19030,19157],"source":" The `IgnoreDatamember` attribute instructs the serializer\nthat this type should not be read to or written from any JSON object."},{"content":"This property contains only a <ph id=\"ph1\">`get`</ph> accessor.","pos":[19158,19203],"source":" This property contains only a\n`get` accessor."},{"content":"There is no <ph id=\"ph1\">`set`</ph> accessor.","pos":[19204,19231],"source":" There is no `set` accessor."},{"content":"That's how you define a <bpt id=\"p1\">*</bpt>read only<ept id=\"p1\">*</ept> property in C#.","pos":[19232,19283],"source":" That's how you define a *read only* property in C#."},{"content":"(Yes, you can create <bpt id=\"p1\">*</bpt>write only<ept id=\"p1\">*</ept> properties in C#, but their value is limited.) The <ph id=\"ph1\">`DateTime.ParseExact`</ph> method parses a string and creates a <ph id=\"ph2\">`DateTime`</ph> object to return.","pos":[19284,19456],"source":" (Yes,\nyou can create *write only* properties in C#, but their value is limited.) The `DateTime.ParseExact`\nmethod parses a string and creates a `DateTime` object to return."},{"content":"If the parse operation fails, the property accessor throws an exception.","pos":[19457,19529],"source":" If the parse operation fails, the\nproperty accessor throws an exception."},{"pos":[19531,19635],"content":"Finally, add one more output statement in the console, and you're ready to build and run this app again:","source":"Finally, add one more output statement in the console, and you're ready to build and run this app\nagain:"},{"pos":[19682,19842],"content":"Your version should now match the finished version located <bpt id=\"p1\">[</bpt>here<ept id=\"p1\">](https://github.com/dotnet/core-docs/tree/master/samples/csharp-language/console-webapiclient)</ept>.","source":"Your version should now match the finished version located\n[here](https://github.com/dotnet/core-docs/tree/master/samples/csharp-language/console-webapiclient)."},{"content":"Conclusion","pos":[19848,19858]},{"content":"This tutorial showed you how to make web requests, parse the result, and display properties of those results.","pos":[19860,19969],"source":"This tutorial showed you how to make web requests, parse the result, and display properties of\nthose results."},{"content":"You've also added new packages as dependencies in your project.","pos":[19970,20033]},{"content":"You've seen some of the features of the C# language that support object oriented techniques.","pos":[20034,20126],"source":" You've seen some of\nthe features of the C# language that support object oriented techniques."}],"content":"---\ntitle: REST client\ndescription: REST client\nkeywords: .NET, .NET Core\nauthor: BillWagner\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: 51033ce2-7a53-4cdd-966d-9da15c8204d2\n---\n\n# REST client\n\n## Introduction\nThis tutorial teaches you a number of features in .NET Core and the C# language. You’ll learn:\n*   The basics of the .NET Core Command Line Interface (CLI).\n*   An overview of C# Language features.\n*   Managing dependencies with NuGet\n*   HTTP Communications\n*   Processing JSON information\n*   Managing configuration with Attributes. \n\nYou’ll build an application that issues HTTP Requests to a REST\nservice on GitHub. You'll read information in JSON format, and convert\nthat JSON packet into C# objects. Finally, you'll see how to work with\nC# objects.\n\nThere are a lot of features in this tutorial. Let’s build them one by one. \n## Prerequisites\nYou’ll need to setup your machine to run .NET core. You can find the\ninstallation instructions on the [.NET Core](https://www.microsoft.com/net/core)\npage. You can run this\napplication on Windows, Linux, macOS or in a Docker container. \nYou’ll need to install your favorite code editor. The descriptions below\nuse [Visual Studio Code](https://code.visualstudio.com/) which is an open\nsource, cross platform editor. However, you can use whatever tools you are\ncomfortable with.\n## Create the Application\nThe first step is to create a new application. Open a command prompt and\ncreate a new directory for your application. Make that the current\ndirectory. Type the command \"dotnet new\" at the command prompt. This\ncreates the starter files for a basic “Hello World” application.\n\nBefore you start making modifications, let’s go through the steps to run\nthe simple Hello World application. After creating the application, type\n\"dotnet restore\" at the command prompt. This command runs the NuGet\npackage restore process. NuGet is a .NET package manager. This command\ndownloads any of the missing dependencies for your project. As this is a\nnew project, none of the dependencies are in place, so the first run will\ndownload the .NET Core framework. After this initial step, you will only\nneed to run dotnet restore when you add new dependent packages, or update\nthe versions of any of your dependencies. This process also creates the\nproject lock file (project.lock.json) in your project directory. This file\nhelps to manage the project dependencies. It contains the local location\nof all the project dependencies. You do not need to put the file in source\ncontrol; it will be generated when you run “dotnet restore”. \n\nAfter restoring packages, you run “dotnet build”. This executes the build\nengine and creates your application. Finally, you execute “dotnet run” to\nrun your application.\n\n## Adding New Dependencies\nOne of the key design goals for .NET Core is to minimize the size of\nthe .NET framework installation. The .NET Core Application framework contains\nonly the most common elements of the .NET full framework. This application\nneeds more libraries for some of its features. You'll add those\ndependencies into your project.json file. You'll need to add the\n`System.Net.Http` package so that your application can make HTTP requests.\nYou'll also need to add the `System.Runtime.Serialization.Json` package\nso your application can process JSON responses.\n\nOpen your project.json file. Look for the dependencies section. You should\nsee one line that looks similar to this:\n\n```\n\"dependencies\": {\n    \"Microsoft.NETCore.App\": {\n        \"type\": \"platform\",\n        \"version\": \"1.0.0\"\n    }\n},\n```\n\nYou'll add two lines to this section to include the two new libraries:\n\n```\n\"dependencies\": {\n   \"Microsoft.NETCore.App\": {\n        \"type\": \"platform\"\n        \"version\": \"1.0.0\",\n    },\n    \"System.Runtime.Serialization.Json\": \"4.0.2\",\n    \"System.Runtime.Serialization.Primitives\": \"4.1.1\"\n},\n```\n\nMost code editors will provide completion for different versions of these\nlibraries. You'll usually want to use the latest version of any package\nthat you add. However, it is important to make sure that the versions\nof all packages match, and that they also match the version of the .NET\nCore Application framework.\n\nAfter you've made these changes, you should run \"dotnet restore\" again so\nthat those packages are installed on your system.\n\n## Making Web Requests\nNow you're ready to start retrieving data from the web. In this\napplication, you'll read information from the \n[GitHub API](https://developer.github.com/v3/). Let's read information\nabout the projects under the\n[.NET Foundation](http://www.dotnetfoundation.org/) umbrella. You'll\nstart by making the request to the GitHub API to retrieve information\non the projects. The endpoint you'll use is: [https://api.github.com/orgs/dotnet/repos](https://api.github.com/orgs/dotnet/repos). You want to retrieve all the\ninformation about these projects, so you'll use an HTTP GET request.\nYour browser also uses HTTP GET requests, so you can paste that URL into\nyour browser to see what information you'll be receiving and processing.\n\nYou use the `HttpClient` class to make web requests. Like all modern .NET\nAPIs, `HttpClient` supports only async methods for its long-running APIs.\nStart by making an async method. You'll fill in the implementation as you\nbuild the functionality of the application. \n\n```cs\nprivate static async Task ProcessRepositories()\n{\n    \n}\n```\n\nYou'll need to add a using statement at the top of your `Main()` method so\nthat the C# compiler recognizes the `Task` type:\n\n```cs\nusing System.Threading.Tasks;\n```\n\nIf you build your project at this point, you'll get a warning generated\nfor this method, because it does not contain any `await` operators and\nwill run synchronously. Ignore that for now, you'll add `await` operators\nas you fill in the method.\n\nNext, update the `Main()` method to call this method. The\n`ProcessRepositories()` method returns a Task, and you shouldn't exit the\nprogram before that task finishes. Therefore, you must use the `Wait()`\nmethod to block and wait for the task to finish:\n\n```cs\npublic static void Main(string[] args)\n{\n    ProcessRepositories().Wait();\n}\n```\n\nNow, you have a program that does nothing, but does it asynchronously. Let's go back to the\n`ProcessRepositories()` method and fill in a first version of it:\n\n```cs\nprivate static async Task ProcessRepositories()\n{\n    var client = new HttpClient();\n    client.DefaultRequestHeaders.Accept.Clear();\n    client.DefaultRequestHeaders.Accept.Add(\n        new MediaTypeWithQualityHeaderValue(\"application/vnd.github.v3+json\"));\n    client.DefaultRequestHeaders.Add(\"User-Agent\", \".NET Foundation Repository Reporter\");\n\n    var stringTask = client.GetStringAsync(\"https://api.github.com/orgs/dotnet/repos\");\n\n    var msg = await stringTask;\n    Console.Write(msg);\n}\n```\n\nYou'll need to also add two new using statements at the top of the file for this to compile:\n\n```cs\nusing System.Net.Http;\nusing System.Net.Http.Headers;\n```\n\nThis first version makes a web request to read the list of all repositories under the dotnet\nfoundation organization. (The gitHub ID for the .NET Foundation is 'dotnet'). First, you create\na new `HttpClient`. This object handles the request and the responses. The next few lines setup\nthe `HttpClient` for this request. First, it is configured to accept the GitHub JSON responses.\nThis format is simply JSON. The next line adds a User Agent header to all requests from this\nobject. These two headers are checked by the GitHub server code, and are necessary to retrieve\ninformation from GitHub.\n\nAfter you've configured the `HttpClient`, you make a web request, and retrieve the response. In\nthis first version, you use the `GetStringAsync` convenience method. This convenience method\nstarts a task that makes the web request, and then when the request returns, it will read the\nresponse stream, and extract the content from the stream. The body of the response is returned\nas a `string`. The string is available when the task completes. \n\nThe final two lines of this method await that task, and then print the response to the console.\nBuild the app, and run it. The build warning is gone now, because the `ProcessRepositories` now\ndoes contain an `await` operator. You'll see a long display of JSON formatted text.   \n\n## Processing the JSON Result\n\nAt this point, you've written the code to retrieve a response from a web server, and display\nthe text that is contained in that response. Next, let's convert that JSON response into C#\nobjects.\n\nThe JSON Serializer converts JSON data into C# Objects. Your first task is to define a C# class\ntype to contain the information you use from this response. Let's build this slowly, so start with\na simple C# type that contains the name of the repository:\n\n```cs\nnamespace WebAPIClient\n{\n    public class repo\n    {\n        public string name;\n    }\n}\n``` \n\nPut the above code in a new file called 'repo.cs'. This version of the class represents the\nsimplest path to process JSON data. The class name and the member name match the names used\nin the JSON packet, instead of following C# conventions. You'll fix that by providing some\nconfiguration attributes later. This class demonstrates another important feature of JSON\nserialization and deserialization: Not all the fields in the JSON packet are part of this class.\nThe JSON serializer will ignore information that is not included in the class type being used.\nThis feature makes it easier to create types that work with only a subset of the fields in\nthe JSON packet.\n\nNow that you've created the type, let's deserialize it. You'll need to create a\n`DataContractJsonSerializer` object. This object must know the CLR type expected for the\nJSON packet it retrieves. The packet from GitHub contains a sequence of repositories, so a\n`List<repo>` is the correct type. Add the following line to your `ProcessRepositories` method:\n\n```cs\nvar serializer = new DataContractJsonSerializer(typeof(List<repo>));\n```\n\nYou're using two new namespaces, so you'll need to add those as well:\n\n```cs\nusing System.Collections.Generic;\nusing System.Runtime.Serialization.Json;\n```\n\nNext, you'll use the serializer to convert JSON into C# objects. Replace the call to\n`GetStringAsync()` in your `ProcessRepositories` method with the following two lines:\n\n```cs\nvar streamTask = client.GetStreamAsync(\"https://api.github.com/orgs/dotnet/repos\");\nvar repositories = serializer.ReadObject(await streamTask) as List<repo>;\n```\n\nNotice that you're now using `GetStreamAsync` instead of `GetStringAsync`. The serializer\nuses a stream instead of a string as its source. Let's explain a couple features of the C#\nlanguage that are being used in the second line above. The argument to `ReadObject` is an\n`await` expression. Await expressions can appear almost anywhere in your code, even though\nup to now, you've only seen them as part of an assignment statement.\n\nSecondly, the `as` operator converts from the compile time type of `object` to `List<repo>`. \nThe declaration of `ReadObject` declares that it returns an object of type `System.Object`.\n`ReadObject` will return the type you specified when you constructed it (`List<repo>` in\nthis tutorial). If the conversion does not succeed, the `as` operator evaluates to `null`,\ninstead of throwing an exception.\n\nYou're almost done with this section. Now that you've converted the JSON to C# objects, let's display\nthe name of each repository:\n\n```cs\nforeach (var repo in repositories)\n    Console.WriteLine(repo.name);\n```\n\nCompile and run the application. It will print out the names of the repositories that are part of the\n.NET Foundation.\n\n## Controlling Serialization\n\nBefore you add more features, let's address the `repo` type and make it follow more standard\nC# conventions. You'll do this by annotating the `repo` type with *Attributes* that control how\nthe JSON Serializer works. In your case, you'll use these attributes to define a mapping between\nthe JSON key names and the C# class and member names. The two attributes used are the `DataContract`\nattribute and the `Data Member` attribute. By convention, all Attribute classes end in the suffix\n`Attribute`. However, you do not need to use that suffix when you apply an attribute. \n\nThe `DataContract` and `DataMember` attributes are in a different library, so you'll need to add\nthat library to project.json as a dependency. Add the following line to the dependencies section\nof the project.json file (remember to add the comma separator on the line above):\n\n```\n\"System.Runtime.Serialization.Primitives\" : \"4.0.1\"\n```\n\nAfter you save the file, run 'dotnet restore' to retrieve this package and update the project.json.lock\nfile.\n\nNext, open the repo.cs file. Let's change the name to use Pascal Case, and fully spell out the name\n`Repository`. We still want to map JSON 'repo' nodes to this type, so you'll need to add the \n`DataContract` attribute to the class declaration. YOu'll set the `Name` property of the attribute\nto the name of the JSON nodes that map to this type:\n\n```cs\n[DataContract(Name=\"repo\")]\npublic class Repository\n```\n\nThe `DataContractAttribute` is a member of the `System.Runtime.Serialization` namespace, so you'll\nneed to add the appropriate using statement at the top of the file:\n\n```cs\nusing System.Runtime.Serialization;\n```\n\nYou changed the name of the `repo` class to `Repository`, so you'll need to make the same name change\nin Program.cs (some editors may support a rename refactoring that will make this change automatically:)\n\n```cs\nvar serializer = new DataContractJsonSerializer(typeof(List<Repository>));\n\n// ...\n\nvar repositories = serializer.ReadObject(await streamTask) as List<Repository>;\n```\n\nNext, let's make the same change with the `name` field, using the `DataMemberAttribute` class. Make\nthe following changes to the declaration of the `name` field in repo.cs:\n\n```cs\n[DataMember(Name=\"name\")]\npublic string Name;\n```\n\nThis change means you need to change the code that writes the name of each repository in program.cs:\n\n```cs\nConsole.WriteLine(repo.Name);\n```\n\nDo a \"dotnet build\", followed by a \"dotnet run\" to make sure you've got the mappings correct. You should\nsee the same output as before. Before we process more properties from the web server, let's make one\nmore change to the `Repository` class. The `Name` member is a publicly accessible field. That's not\na good object oriented practice, so let's change it to a property. For our purposes, we don't need\nany specific code to run when getting or setting the property, but changing to a property makes it\neasier to add those changes later without breaking any code that uses the `Repository` class.\n\nRemove the field definition, and replace it with an *auto-implemented property*:\n\n```cs\npublic string Name { get; set; }\n```\n\nThe compiler generates the body of the `get` and `set` accessors, as well as a private field to\nstore the name. It would be similar to the following code that you could type by hand:\n\n```cs\npublic string Name \n{ \n    get { return this._name; }\n    set { this._name = value; }\n}\nprivate string _name;\n```\n\nLet's make one more change before adding new features. The `ProcessRepositories` method can do the async\nwork and return a collection of the repositories. Let's return the `List<Repository>` from that method,\nand move the code that writes the information into the `Main` method.\n\nChange the signature of `ProcessRepositories` to return a task whose result is a list of `Repository`\nobjects:\n\n```cs\nprivate static async Task<List<Repository>> ProcessRepositories()\n```\n\nThen, just return the repositories after processing the JSON response:\n\n```cs\nvar repositories = serializer.ReadObject(await streamTask) as List<Repository>;\nreturn repositories;\n```\n\nThe compiler generates the `Task<T>` object for the return because you've marked this method as `async`.\nThen, let's modify the `Main` method so that it captures those results and writes each repository name\nto the console. Your `Main` method now looks like this:\n\n```cs\npublic static void Main(string[] args)\n{\n    var repositories = ProcessRepositories().Result;\n\n    foreach (var repo in repositories)\n        Console.WriteLine(repo.Name);\n}\n```\n\nAccessing the `Result` property of a Task blocks until the task has completed. Normally, you would prefer\nto `await` the completion of the task as in the `ProcessRepositories` method, but that isn't allowed in the\n`Main` method.\n\n## Reading More Information\n\nLet's finish this by processing a few more of the properties in the JSON packet that gets sent from the\nGitHub API. You won't want to grab everything, but adding a few properties will demonstrate a few more\nfeatures of the C# language.\n\nLet's start by adding a few more simple types to the `Repository` class definition. Add these properties\nto that class:\n\n```cs\n[DataMember(Name=\"description\")]\npublic string Description { get; set; }\n\n[DataMember(Name=\"html_url\")]\npublic Uri GitHubHomeUrl { get; set; }\n\n[DataMember(Name=\"homepage\")]\npublic Uri Homepage { get; set; }\n\n[DataMember(Name=\"watchers\")]\npublic int Watchers { get; set; }\n```\n\nThese properties have built in conversions from the string type (which is what the JSON packets contain) to\nthe target type. The `Uri` type may be new to you. It represents a URI, or in this case, a URL. In the case\nof the `Uri` and `int` types, if the JSON packet contains data that does not convert to the target type,\nthe Serialization action will throw an exception.\n\nOnce you've added these, update the `Main` method to display those elements:\n\n```cs\nforeach (var repo in repositories)\n{\n    Console.WriteLine(repo.Name);\n    Console.WriteLine(repo.Description);\n    Console.WriteLine(repo.GitHubHomeUrl);\n    Console.WriteLine(repo.Homepage);\n    Console.WriteLine(repo.Watchers);\n    Console.WriteLine();\n}\n```\nAs a final step, let's add the information for the last push operation. This information is formatted in\nthis fashion in the JSON response:\n\n```\n2016-02-08T21:27:00Z\n```\n\nThat format does not follow one of the standard .NET DateTime formats. Because of that, you'll need to write\na custom conversion method. You also probably don't want the raw string exposed to uses of the `Repository`\nclass. Attributes can help control that as well. First, define a `private` property that will hold the\nstring representation of the date time in your `Repository` class:\n\n```cs\n[DataMember(Name=\"pushed_at\")]\nprivate string JsonDate { get; set; }\n```\n\nThe `DataMember` attribute informs the Serializer that this should be processed, even though it is not\na public member. Next, you need to write a public read only property that converts the string to a\nvalid `DateTime` object, and returns that `DateTime`:\n\n```cs\n[IgnoreDataMember]\npublic DateTime LastPush\n{\n    get\n    {\n        return DateTime.ParseExact(JsonDate, \"yyyy-MM-ddTHH:mm:ssZ\", CultureInfo.InvariantCulture);\n    }\n}\n```\n\nLet's go over the new constructs above. The `IgnoreDatamember` attribute instructs the serializer\nthat this type should not be read to or written from any JSON object. This property contains only a\n`get` accessor. There is no `set` accessor. That's how you define a *read only* property in C#. (Yes,\nyou can create *write only* properties in C#, but their value is limited.) The `DateTime.ParseExact`\nmethod parses a string and creates a `DateTime` object to return. If the parse operation fails, the\nproperty accessor throws an exception.\n\nFinally, add one more output statement in the console, and you're ready to build and run this app\nagain:\n\n```cs\nConsole.WriteLine(repo.LastPush);\n```\n\nYour version should now match the finished version located\n[here](https://github.com/dotnet/core-docs/tree/master/samples/csharp-language/console-webapiclient).\n \n## Conclusion\n\nThis tutorial showed you how to make web requests, parse the result, and display properties of\nthose results. You've also added new packages as dependencies in your project. You've seen some of\nthe features of the C# language that support object oriented techniques.\n\n"}