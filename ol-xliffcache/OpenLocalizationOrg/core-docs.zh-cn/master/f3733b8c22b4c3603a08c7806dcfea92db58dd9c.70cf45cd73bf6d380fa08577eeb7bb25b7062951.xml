{"nodes":[{"pos":[11,57],"content":"Developing Libraries with Cross Platform Tools","needQuote":true,"nodes":[{"content":"Developing Libraries with Cross Platform Tools","pos":[0,46]}]},{"pos":[71,117],"content":"Developing Libraries with Cross Platform Tools","needQuote":true,"nodes":[{"content":"Developing Libraries with Cross Platform Tools","pos":[0,46]}]},{"pos":[128,143],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":"Developing Libraries with Cross Platform Tools","pos":[349,395]},{"content":"Some details are subject to change as the toolchain evolves.","pos":[399,459]},{"content":"This article covers how to write libraries for .NET using cross-platform CLI tools.","pos":[463,546]},{"content":"The CLI provides an efficient and low-level experience that works across any supported OS.","pos":[548,638]},{"content":"You can still build libraries with Visual Studio, and if that is your preferred experience <bpt id=\"p1\">[</bpt>refer to the Visual Studio guide<ept id=\"p1\">](libraries-with-vs.md)</ept>.","pos":[640,788],"source":"  You can still build libraries with Visual Studio, and if that is your preferred experience [refer to the Visual Studio guide](libraries-with-vs.md)."},{"content":"Prerequisites","pos":[793,806]},{"pos":[808,907],"content":"You need <bpt id=\"p1\">[</bpt>the .NET Core SDK and CLI<ept id=\"p1\">](https://www.microsoft.com/net/core)</ept> installed on your machine.","source":"You need [the .NET Core SDK and CLI](https://www.microsoft.com/net/core) installed on your machine."},{"pos":[909,1113],"content":"For the sections of this document dealing with .NET Framework versions or Portable Class Libraries (PCL), you need the <bpt id=\"p1\">[</bpt>.NET Framework<ept id=\"p1\">](http://getdotnet.azurewebsites.net/)</ept> installed on a Windows machine.","source":"For the sections of this document dealing with .NET Framework versions or Portable Class Libraries (PCL), you need the [.NET Framework](http://getdotnet.azurewebsites.net/) installed on a Windows machine."},{"content":"Additionally, if you wish to support older .NET Framework targets, you need to install targeting/developer packs for older framework versions from the <bpt id=\"p1\">[</bpt>.NET target platforms page<ept id=\"p1\">](http://getdotnet.azurewebsites.net/target-dotnet-platforms.html)</ept>.","pos":[1117,1362],"source":"Additionally, if you wish to support older .NET Framework targets, you need to install targeting/developer packs for older framework versions from the [.NET target platforms page](http://getdotnet.azurewebsites.net/target-dotnet-platforms.html)."},{"content":"Refer to this table:","pos":[1364,1384]},{"content":".NET Framework Version","pos":[1388,1410]},{"content":"What to download","pos":[1413,1429]},{"content":"4.6.1","pos":[1481,1486]},{"content":".NET Framework 4.6.1 Targeting Pack","pos":[1489,1524]},{"content":"4.6","pos":[1529,1532]},{"content":".NET Framework 4.6 Targeting Pack","pos":[1535,1568]},{"content":"4.5.2","pos":[1573,1578]},{"content":".NET Framework 4.5.2 Developer Pack","pos":[1581,1616]},{"content":"4.5.1","pos":[1621,1626]},{"content":".NET Framework 4.5.1 Developer Pack","pos":[1629,1664]},{"content":"4.5","pos":[1669,1672]},{"content":"Windows Software Development Kit for Windows 8","pos":[1675,1721]},{"content":"4.0","pos":[1726,1729]},{"content":"Windows SDK for Windows 7 and .NET Framework 4","pos":[1732,1778]},{"content":"2.0, 3.0, and 3.5","pos":[1783,1800]},{"content":".NET Framework 3.5 SP1 Runtime (or Windows 8+ version)","pos":[1803,1857]},{"content":"How to target the .NET Standard","pos":[1864,1895]},{"pos":[1897,2028],"content":"If you're not quite familiar with the .NET Standard, refer to <bpt id=\"p1\">[</bpt>the .NET Standard Library<ept id=\"p1\">](../../standard/library.md)</ept> to learn more.","source":"If you're not quite familiar with the .NET Standard, refer to [the .NET Standard Library](../../standard/library.md) to learn more."},{"content":"In that article, there is a table which maps .NET Standard versions to various implementations:","pos":[2030,2125]},{"content":"Platform Name","pos":[2129,2142]},{"content":"Alias","pos":[2145,2150]},{"content":".NET Standard","pos":[2286,2299]},{"content":"netstandard","pos":[2302,2313]},{"content":"1.0","pos":[2316,2319]},{"content":"1.1","pos":[2322,2325]},{"content":"1.2","pos":[2328,2331]},{"content":"1.3","pos":[2334,2337]},{"content":"1.4","pos":[2340,2343]},{"content":"1.5","pos":[2346,2349]},{"content":"1.6","pos":[2352,2355]},{"content":".NET Core","pos":[2359,2368]},{"content":"netcoreapp","pos":[2369,2379]},{"content":"1.0","pos":[2422,2425]},{"content":".NET Framework","pos":[2428,2442]},{"content":"net","pos":[2443,2446]},{"content":"4.5","pos":[2454,2457]},{"content":"4.5.1","pos":[2458,2463]},{"content":"4.6","pos":[2464,2467]},{"content":"4.6.1","pos":[2468,2473]},{"content":"4.6.2","pos":[2474,2479]},{"content":"4.6.3","pos":[2480,2485]},{"content":"Mono/Xamarin Platforms","pos":[2488,2510]},{"content":"Universal Windows Platform","pos":[2558,2584]},{"content":"uap","pos":[2585,2588]},{"content":"10.0","pos":[2617,2621]},{"content":"Windows","pos":[2626,2633]},{"content":"win","pos":[2634,2637]},{"content":"8.0","pos":[2645,2648]},{"content":"8.1","pos":[2649,2652]},{"content":"Windows Phone","pos":[2659,2672]},{"content":"wpa","pos":[2673,2676]},{"content":"8.1","pos":[2691,2694]},{"content":"Windows Phone Silverlight","pos":[2701,2726]},{"content":"wp","pos":[2727,2729]},{"content":"8.0","pos":[2730,2733]},{"content":"Here's what this table means for the purposes of creating a library:","pos":[2742,2810]},{"content":"The version of the .NET Platform Standard you pick will be a tradeoff between access to the newest APIs and ability to target more .NET platforms and Framework versions.","pos":[2812,2981]},{"content":"You control the range of targetable platforms and versions by picking a version of <ph id=\"ph1\">`netstandardX.X`</ph> (Where <ph id=\"ph2\">`X.X`</ph> is a version number) and adding it to your <ph id=\"ph3\">`project.json`</ph> file.","pos":[2983,3159],"source":"  You control the range of targetable platforms and versions by picking a version of `netstandardX.X` (Where `X.X` is a version number) and adding it to your `project.json` file."},{"content":"Additionally, the corresponding <bpt id=\"p1\">[</bpt>NuGet package to depend on<ept id=\"p1\">](https://www.nuget.org/packages/NETStandard.Library/)</ept> is <ph id=\"ph1\">`NETStandard.Library`</ph> version <ph id=\"ph2\">`1.6.0`</ph>.","pos":[3161,3316],"source":"Additionally, the corresponding [NuGet package to depend on](https://www.nuget.org/packages/NETStandard.Library/) is `NETStandard.Library` version `1.6.0`."},{"content":"Although there's nothing preventing you from depending on <ph id=\"ph1\">`Microsoft.NETCore.App`</ph> like with console apps, it's generally not recommended.","pos":[3318,3455],"source":"  Although there's nothing preventing you from depending on `Microsoft.NETCore.App` like with console apps, it's generally not recommended."},{"content":"If you need APIs from a package not specified in <ph id=\"ph1\">`NETStandard.Library`</ph>, you can always specify that package in addition to <ph id=\"ph2\">`NETStandard.Library`</ph> in the <ph id=\"ph3\">`dependencies`</ph> section of your <ph id=\"ph4\">`project.json`</ph> file.","pos":[3457,3660],"source":"  If you need APIs from a package not specified in `NETStandard.Library`, you can always specify that package in addition to `NETStandard.Library` in the `dependencies` section of your `project.json` file."},{"content":"You have three primary options when targeting the .NET Standard, depending on your needs.","pos":[3662,3751]},{"pos":[3756,3941],"content":"You can use the latest version of the .NET Standard - <ph id=\"ph1\">`netstandard1.6`</ph> - which is for when you want access to the most APIs and don't mind if you have less reach across implementations.","source":"You can use the latest version of the .NET Standard - `netstandard1.6` - which is for when you want access to the most APIs and don't mind if you have less reach across implementations."},{"content":"You can use a lower version of the .NET Standard to target earlier .NET implementations.","pos":[3945,4033]},{"content":"The cost here is not having access to some of the latest APIs.","pos":[4034,4096]},{"pos":[4106,4234],"content":"For example, if you wanted to have guaranteed compatibility with .NET Framework 4.6 and higher, you would pick <ph id=\"ph1\">`netstandard1.3`</ph>:","source":"For example, if you wanted to have guaranteed compatibility with .NET Framework 4.6 and higher, you would pick `netstandard1.3`:"},{"content":".NET Standard versions are backward compatible.","pos":[4420,4467]},{"content":"That means that <ph id=\"ph1\">`netstandard1.0`</ph> libraries run on <ph id=\"ph2\">`netstandard1.1`</ph> platforms and higher.","pos":[4468,4556],"source":" That means that `netstandard1.0` libraries run on `netstandard1.1` platforms and higher."},{"content":"However, there is no forward compatibility - lower .NET Standard platforms cannot reference higher ones.","pos":[4558,4662]},{"content":"This means that <ph id=\"ph1\">`netstandard1.0`</ph> libraries cannot reference libraries targeting <ph id=\"ph2\">`netstandard1.1`</ph> or higher.","pos":[4664,4771],"source":"  This means that `netstandard1.0` libraries cannot reference libraries targeting `netstandard1.1` or higher."},{"content":"Select the Standard version that has the right mix of APIs and platform support for your needs.","pos":[4773,4868]},{"pos":[4877,5118],"content":"If you want to target the .NET Framework versions 4.0 or below, or you wish to use an API available in the .NET Framework but not in the .NET Standard (for example, <ph id=\"ph1\">`System.Drawing`</ph>), read the following sections and learn how to multitarget.","source":"If you want to target the .NET Framework versions 4.0 or below, or you wish to use an API available in the .NET Framework but not in the .NET Standard (for example, `System.Drawing`), read the following sections and learn how to multitarget."},{"content":"How to target the .NET Framework","pos":[5123,5155]},{"content":"<bpt id=\"p1\">**</bpt>NOTE:<ept id=\"p1\">**</ept> These instructions assume you have the .NET Framework installed on your machine.","pos":[5157,5247],"source":"**NOTE:** These instructions assume you have the .NET Framework installed on your machine."},{"content":"Refer to the <bpt id=\"p1\">[</bpt>Prerequisites<ept id=\"p1\">](#prerequisites)</ept> to get dependencies installed.","pos":[5249,5324],"source":"  Refer to the [Prerequisites](#prerequisites) to get dependencies installed."},{"content":"Keep in mind that some of the .NET Framework versions used here are no longer in support.","pos":[5326,5415]},{"content":"Refer to the <bpt id=\"p1\">[</bpt>.NET Framework Support Lifecycle Policy FAQ<ept id=\"p1\">](https://support.microsoft.com/gp/framework_faq/en-us)</ept> about unsupported versions.","pos":[5417,5557],"source":"  Refer to the [.NET Framework Support Lifecycle Policy FAQ](https://support.microsoft.com/gp/framework_faq/en-us) about unsupported versions."},{"content":"If you want to reach the maximum number of developers and projects, use the .NET Framework 4 as your baseline target.","pos":[5559,5676]},{"content":"To target the .NET Framework, you will need to begin by using the correct Target Framework Moniker (TFM) that corresponds to the .NET Framework version you wish to support.","pos":[5677,5849]},{"content":"For example, here's how you would write a library which targets the .NET Framework 4:","pos":[6206,6291]},{"content":"And that's it!","pos":[6354,6368]},{"content":"Although this compiled only for the .NET Framework 4, you can use the library on newer versions of the .NET Framework.","pos":[6370,6488]},{"content":"How to target a Portable Class Library (PCL)","pos":[6493,6537]},{"content":"<bpt id=\"p1\">**</bpt>NOTE:<ept id=\"p1\">**</ept> These instructions assume you have the .NET Framework installed on your machine.","pos":[6539,6629],"source":"**NOTE:** These instructions assume you have the .NET Framework installed on your machine."},{"content":"Refer to the <bpt id=\"p1\">[</bpt>Prerequisites<ept id=\"p1\">](#prerequisites)</ept> to get dependencies installed.","pos":[6631,6706],"source":"  Refer to the [Prerequisites](#prerequisites) to get dependencies installed."},{"content":"Targeting a PCL profile is a bit trickier than targeting .NET Standard or the .NET Framework.","pos":[6708,6801]},{"content":"For starters, <bpt id=\"p1\">[</bpt>reference this list of PCL profiles<ept id=\"p1\">](http://embed.plnkr.co/03ck2dCtnJogBKHJ9EjY/preview)</ept> to find the NuGet target which corresponds to the PCL profile you are targeting.","pos":[6803,6987],"source":"  For starters, [reference this list of PCL profiles](http://embed.plnkr.co/03ck2dCtnJogBKHJ9EjY/preview) to find the NuGet target which corresponds to the PCL profile you are targeting."},{"content":"Then, you need to do the following:","pos":[6989,7024]},{"pos":[7029,7259],"content":"Create a new entry under <ph id=\"ph1\">`frameworks`</ph> in your <ph id=\"ph2\">`project.json`</ph>, named <ph id=\"ph3\">`.NETPortable,Version=v{version},Profile=Profile{profile}`</ph>, where <ph id=\"ph4\">`{version}`</ph> and <ph id=\"ph5\">`{profile}`</ph> correspond to a PCL version number and Profile number, respectively.","source":"Create a new entry under `frameworks` in your `project.json`, named `.NETPortable,Version=v{version},Profile=Profile{profile}`, where `{version}` and `{profile}` correspond to a PCL version number and Profile number, respectively."},{"content":"In this new entry, list every single assembly used for that target under a <ph id=\"ph1\">`frameworkAssemblies`</ph> entry.","pos":[7263,7366],"source":"In this new entry, list every single assembly used for that target under a `frameworkAssemblies` entry."},{"content":"This includes <ph id=\"ph1\">`mscorlib`</ph>, <ph id=\"ph2\">`System`</ph>, and <ph id=\"ph3\">`System.Core`</ph>.","pos":[7368,7422],"source":"  This includes `mscorlib`, `System`, and `System.Core`."},{"content":"If you are multitargeting (see the next section), you must explicitly list dependencies for each target under their target entries.","pos":[7426,7557]},{"content":"You won't be able to use a global <ph id=\"ph1\">`dependencies`</ph> entry anymore.","pos":[7559,7622],"source":"  You won't be able to use a global `dependencies` entry anymore."},{"content":"The following is an example targeting PCL Profile 328.","pos":[7624,7678]},{"content":"Profile 328 supports: .NET Standard 1.4, .NET Framework 4, Windows 8, Windows Phone 8.1, Windows Phone Silverlight 8.1, and Silverlight 5.","pos":[7679,7817]},{"pos":[8071,8224],"content":"When you build a project that includes PCL Profile 328 as a framework in the <bpt id=\"p1\">*</bpt>project.json<ept id=\"p1\">*</ept> file, it will have this subfolder in the <bpt id=\"p2\">*</bpt>/bin/debug<ept id=\"p2\">*</ept> folder:","source":"When you build a project that includes PCL Profile 328 as a framework in the *project.json* file, it will have this subfolder in the */bin/debug* folder:"},{"pos":[8276,8344],"content":"This folder contains the <ph id=\"ph1\">`.dll`</ph> files necessary to run your library.","source":"This folder contains the `.dll` files necessary to run your library."},{"content":"How to Multitarget","pos":[8349,8367]},{"content":"<bpt id=\"p1\">**</bpt>NOTE:<ept id=\"p1\">**</ept> These following instructions assume you have the .NET Framework installed on your machine.","pos":[8369,8469],"source":"**NOTE:** These following instructions assume you have the .NET Framework installed on your machine."},{"content":"Refer to the <bpt id=\"p1\">[</bpt>Prerequisites<ept id=\"p1\">](#prerequisites)</ept> section to learn which dependencies you need to install and where to download them from.","pos":[8471,8604],"source":"  Refer to the [Prerequisites](#prerequisites) section to learn which dependencies you need to install and where to download them from."},{"content":"You may need to target older versions of the .NET Framework when your project supports both the .NET Framework and .NET Core.","pos":[8606,8731]},{"content":"In this scenario, if you want to use newer APIs and language constructs for the newer targets, use <ph id=\"ph1\">`#if`</ph> directives in your code.","pos":[8732,8861],"source":" In this scenario, if you want to use newer APIs and language constructs for the newer targets, use `#if` directives in your code."},{"content":"You also might need to add different packages and dependencies in your <ph id=\"ph1\">`project.json file`</ph> for each platform you're targeting to include the different APIs needed for each case.","pos":[8862,9039],"source":" You also might need to add different packages and dependencies in your `project.json file` for each platform you're targeting to include the different APIs needed for each case."},{"content":"For example, let's say you have a library that performs networking operations over HTTP.","pos":[9041,9129]},{"content":"For .NET Standard and the .NET Framework versions 4.5 or higher, you can use the <ph id=\"ph1\">`HttpClient`</ph> class from the <ph id=\"ph2\">`System.Net.Http`</ph> namespace.","pos":[9130,9267],"source":" For .NET Standard and the .NET Framework versions 4.5 or higher, you can use the `HttpClient` class from the `System.Net.Http` namespace."},{"content":"However, earlier versions of the .NET Framework don't have the <ph id=\"ph1\">`HttpClient`</ph> class, so you could use the <ph id=\"ph2\">`WebClient`</ph> class from the <ph id=\"ph3\">`System.Net`</ph> namespace for those instead.","pos":[9268,9440],"source":" However, earlier versions of the .NET Framework don't have the `HttpClient` class, so you could use the `WebClient` class from the `System.Net` namespace for those instead."},{"pos":[9442,9491],"content":"So, the <ph id=\"ph1\">`project.json`</ph> file could look like this:","source":"So, the `project.json` file could look like this:"},{"content":"Note that the .NET Framework assemblies need to be referenced explicitly in the <ph id=\"ph1\">`net40`</ph> and <ph id=\"ph2\">`net452`</ph> target, and NuGet references are also explicitly listed in the <ph id=\"ph3\">`netstandard1.6`</ph> target.","pos":[10076,10264],"source":"Note that the .NET Framework assemblies need to be referenced explicitly in the `net40` and `net452` target, and NuGet references are also explicitly listed in the `netstandard1.6` target."},{"content":"This is required in multitargeting scenarios.","pos":[10266,10311]},{"pos":[10313,10388],"content":"Next, the <ph id=\"ph1\">`using`</ph> statements in your source file can be adjusted like this:","source":"Next, the `using` statements in your source file can be adjusted like this:"},{"pos":[10593,10682],"content":"The build system is aware of the following preprocessor symbols used in <ph id=\"ph1\">`#if`</ph> directives:","source":"The build system is aware of the following preprocessor symbols used in `#if` directives:"},{"content":"And in the middle of the source, you can use <ph id=\"ph1\">`#if`</ph> directives to use those libraries conditionally.","pos":[11256,11355],"source":"And in the middle of the source, you can use `#if` directives to use those libraries conditionally."},{"content":"For example:","pos":[11356,11368]},{"pos":[12772,12949],"content":"When you build a project that includes <ph id=\"ph1\">`net40`</ph>, <ph id=\"ph2\">`net45`</ph>, and <ph id=\"ph3\">`netstandard1.6`</ph> as frameworks in the <bpt id=\"p1\">*</bpt>project.json<ept id=\"p1\">*</ept> file, it will have these subfolders in the <bpt id=\"p2\">*</bpt>/bin/debug<ept id=\"p2\">*</ept> folder:","source":"When you build a project that includes `net40`, `net45`, and `netstandard1.6` as frameworks in the *project.json* file, it will have these subfolders in the */bin/debug* folder:"},{"content":"But What about Multitargeting with Portable Class Libraries?","pos":[12994,13054]},{"content":"If you want to cross-compile with a PCL target, you must add a build definition in your <ph id=\"ph1\">`project.json`</ph> file under <ph id=\"ph2\">`buildOptions`</ph> in your PCL target.","pos":[13056,13204],"source":"If you want to cross-compile with a PCL target, you must add a build definition in your `project.json` file under `buildOptions` in your PCL target."},{"content":"You can then use <ph id=\"ph1\">`#if`</ph> directives in the source which use the build definition as a preprocessor symbol.","pos":[13206,13310],"source":"  You can then use `#if` directives in the source which use the build definition as a preprocessor symbol."},{"content":"For example, if you want to target <bpt id=\"p1\">[</bpt>PCL profile 328<ept id=\"p1\">](http://embed.plnkr.co/03ck2dCtnJogBKHJ9EjY/preview)</ept> (The .NET Framework 4, Windows 8, Windows Phone Silverlight 8, Windows Phone 8.1, Silverlight 5), you could to refer to it to as \"PORTABLE328\" when cross-compiling.","pos":[13312,13581],"source":"For example, if you want to target [PCL profile 328](http://embed.plnkr.co/03ck2dCtnJogBKHJ9EjY/preview) (The .NET Framework 4, Windows 8, Windows Phone Silverlight 8, Windows Phone 8.1, Silverlight 5), you could to refer to it to as \"PORTABLE328\" when cross-compiling."},{"content":"Simply add it to the <ph id=\"ph1\">`project.json`</ph> file as a <ph id=\"ph2\">`buildOptions`</ph> attribute:","pos":[13583,13654],"source":"  Simply add it to the `project.json` file as a `buildOptions` attribute:"},{"content":"Now you can conditionally compile against that target:","pos":[14155,14209]},{"pos":[14376,14548],"content":"Because <ph id=\"ph1\">`PORTABLE328`</ph> is now recognized by the compiler, the PCL Profile 328 library generated by a compiler will not include <ph id=\"ph2\">`System.Net.Http`</ph> or <ph id=\"ph3\">`System.Threading.Tasks`</ph>.","source":"Because `PORTABLE328` is now recognized by the compiler, the PCL Profile 328 library generated by a compiler will not include `System.Net.Http` or `System.Threading.Tasks`."},{"pos":[14550,14725],"content":"When you build a project that includes PCL Profile 328 and <ph id=\"ph1\">`netstandard1.6`</ph> as frameworks in the <bpt id=\"p1\">*</bpt>project.json<ept id=\"p1\">*</ept> file, it will have these subfolders in the <bpt id=\"p2\">*</bpt>/bin/debug<ept id=\"p2\">*</ept> folder:","source":"When you build a project that includes PCL Profile 328 and `netstandard1.6` as frameworks in the *project.json* file, it will have these subfolders in the */bin/debug* folder:"},{"content":"How to use native dependencies","pos":[14796,14826]},{"content":"You may wish to write a library which depends on a native <ph id=\"ph1\">`.dll`</ph> file.","pos":[14828,14898],"source":"You may wish to write a library which depends on a native `.dll` file."},{"content":"If you're writing such a library, you have have two options:","pos":[14900,14960]},{"pos":[14965,15025],"content":"Reference the native <ph id=\"ph1\">`.dll`</ph> directly in your <ph id=\"ph2\">`project.json`</ph>.","source":"Reference the native `.dll` directly in your `project.json`."},{"pos":[15029,15103],"content":"Package that <ph id=\"ph1\">`.dll`</ph> into its own NuGet package and depend on that package.","source":"Package that `.dll` into its own NuGet package and depend on that package."},{"pos":[15105,15192],"content":"For the first option, you'll need to include the following in your <ph id=\"ph1\">`project.json`</ph> file:","source":"For the first option, you'll need to include the following in your `project.json` file:"},{"pos":[15197,15257],"content":"Setting <ph id=\"ph1\">`allowUnsafe`</ph> to <ph id=\"ph2\">`true`</ph> in a <ph id=\"ph3\">`buildOptions`</ph> section.","source":"Setting `allowUnsafe` to `true` in a `buildOptions` section."},{"pos":[15261,15401],"content":"Specifying the path to the native <ph id=\"ph1\">`.dll`</ph>(s) with a <bpt id=\"p1\">[</bpt>Runtime Identifier (RID)<ept id=\"p1\">](../rid-catalog.md)</ept> under <ph id=\"ph2\">`files`</ph> in the <ph id=\"ph3\">`packOptions`</ph> section.","source":"Specifying the path to the native `.dll`(s) with a [Runtime Identifier (RID)](../rid-catalog.md) under `files` in the `packOptions` section."},{"content":"If you're distributing your library as a package, it's recommended that you place the <ph id=\"ph1\">`.dll`</ph> file at the root level of your project.","pos":[15403,15535],"source":"If you're distributing your library as a package, it's recommended that you place the `.dll` file at the root level of your project."},{"content":"Here's an example <ph id=\"ph1\">`project.json`</ph> for a native <ph id=\"ph2\">`.dll`</ph> file that runs on Windows x64:","pos":[15537,15620],"source":"  Here's an example `project.json` for a native `.dll` file that runs on Windows x64:"},{"content":"For the second option, you'll need to build a NuGet package out of your <ph id=\"ph1\">`.dll`</ph> file(s), host on a NuGet or MyGet feed, and depend on it directly.","pos":[15805,15950],"source":"For the second option, you'll need to build a NuGet package out of your `.dll` file(s), host on a NuGet or MyGet feed, and depend on it directly."},{"content":"You'll still need to set <ph id=\"ph1\">`allowUnsafe`</ph> to <ph id=\"ph2\">`true`</ph> in the <ph id=\"ph3\">`buildOptions`</ph> section of your <ph id=\"ph4\">`project.json`</ph>.","pos":[15952,16054],"source":"  You'll still need to set `allowUnsafe` to `true` in the `buildOptions` section of your `project.json`."},{"content":"Here's an example (assuming <ph id=\"ph1\">`MyNativeLib`</ph> is a Nuget package at version <ph id=\"ph2\">`1.2.0`</ph>):","pos":[16056,16137],"source":"  Here's an example (assuming `MyNativeLib` is a Nuget package at version `1.2.0`):"},{"pos":[16268,16579],"content":"To see an example of packaging up cross-platform native binaries, check out the <bpt id=\"p1\">[</bpt>ASP.NET Libuv Package<ept id=\"p1\">](https://github.com/aspnet/libuv-package)</ept> and the <bpt id=\"p2\">[</bpt>corresponding reference in KestrelHttpServer<ept id=\"p2\">](https://github.com/aspnet/KestrelHttpServer/blob/dev/src/Microsoft.AspNetCore.Server.Kestrel/project.json#L18)</ept>.","source":"To see an example of packaging up cross-platform native binaries, check out the [ASP.NET Libuv Package](https://github.com/aspnet/libuv-package) and the [corresponding reference in KestrelHttpServer](https://github.com/aspnet/KestrelHttpServer/blob/dev/src/Microsoft.AspNetCore.Server.Kestrel/project.json#L18)."},{"content":"How to test libraries on .NET Core","pos":[16584,16618]},{"content":"It's important to be able to test across platforms.","pos":[16620,16671]},{"content":"It's easiest to use <bpt id=\"p1\">[</bpt>xUnit<ept id=\"p1\">](http://xunit.github.io/)</ept>, which is also the testing tool used by .NET Core projects.","pos":[16673,16785],"source":"  It's easiest to use [xUnit](http://xunit.github.io/), which is also the testing tool used by .NET Core projects."},{"content":"How you set up your solution with test projects will depend on the <bpt id=\"p1\">[</bpt>structure of your solution<ept id=\"p1\">](#structuring-a-solution)</ept>.","pos":[16787,16908],"source":"  How you set up your solution with test projects will depend on the [structure of your solution](#structuring-a-solution)."},{"content":"The following example assumes that all source projects are under a top-level <ph id=\"ph1\">`/src`</ph> folder and all test projects are under a top-level <ph id=\"ph2\">`/test`</ph> folder.","pos":[16910,17060],"source":"  The following example assumes that all source projects are under a top-level `/src` folder and all test projects are under a top-level `/test` folder."},{"pos":[17065,17170],"content":"Ensure you have a <ph id=\"ph1\">`global.json`</ph> file at the solution level which understands where the test projects are:","source":"Ensure you have a `global.json` file at the solution level which understands where the test projects are:"},{"content":"Your solution folder structure should then look like this:","pos":[17253,17311]},{"content":"Create a new test project by creating a project folder under your <ph id=\"ph1\">`/test`</ph> folder, and a <ph id=\"ph2\">`project.json`</ph> file in the new project folder.","pos":[17413,17547],"source":"Create a new test project by creating a project folder under your `/test` folder, and a `project.json` file in the new project folder."},{"content":"To create the <ph id=\"ph1\">`project.json`</ph> file you can run the <ph id=\"ph2\">`dotnet new`</ph> command and modify the <ph id=\"ph3\">`project.json`</ph> file afterwards.","pos":[17549,17666],"source":"  To create the `project.json` file you can run the `dotnet new` command and modify the `project.json` file afterwards."},{"content":"The file should have the following:","pos":[17668,17703]},{"pos":[17726,17770],"content":"listed as the only entry under <ph id=\"ph1\">`frameworks`</ph>.","source":" listed as the only entry under `frameworks`."},{"pos":[17776,17831],"content":"A reference to <ph id=\"ph1\">`Microsoft.NETCore.App`</ph> version <ph id=\"ph2\">`1.0.0`</ph>.","source":"A reference to `Microsoft.NETCore.App` version `1.0.0`."},{"pos":[17837,17890],"content":"A reference to xUnit version <ph id=\"ph1\">`2.2.0-beta2-build3300`</ph>.","source":"A reference to xUnit version `2.2.0-beta2-build3300`."},{"pos":[17896,17938],"content":"A reference to <ph id=\"ph1\">`dotnet-test-xunit`</ph> version","source":"A reference to `dotnet-test-xunit` version "},{"content":"A project reference to the library being tested.","pos":[17971,18019]},{"pos":[18025,18058],"content":"The entry <ph id=\"ph1\">`\"testRunner\":\"xunit\"`</ph>.","source":"The entry `\"testRunner\":\"xunit\"`."},{"pos":[18066,18149],"content":"Here's an example (<ph id=\"ph1\">`LibraryUnderTest`</ph> version <ph id=\"ph2\">`1.0.0`</ph> is the library being tested):","source":"Here's an example (`LibraryUnderTest` version `1.0.0` is the library being tested):"},{"content":"Restore packages by running <ph id=\"ph1\">`dotnet restore`</ph>.","pos":[18659,18704],"source":"Restore packages by running `dotnet restore`."},{"content":"You should do this at the solution level if you haven't restored packages yet.","pos":[18706,18784]},{"pos":[18789,18852],"content":"Navigate to your test project and run tests with <ph id=\"ph1\">`dotnet test`</ph>:","source":"Navigate to your test project and run tests with `dotnet test`:"},{"content":"And that's it!","pos":[18924,18938]},{"content":"You can now test your library across all platforms using command line tools.","pos":[18940,19016]},{"content":"To continue testing now that you have everything set up, testing your library is very simple:","pos":[19018,19111]},{"content":"Make changes to your library.","pos":[19116,19145]},{"pos":[19149,19233],"content":"Run tests from the command line, in your test directory, with <ph id=\"ph1\">`dotnet test`</ph> command.","source":"Run tests from the command line, in your test directory, with `dotnet test` command."},{"pos":[19235,19313],"content":"Your code will be automatically rebuilt when you invoke <ph id=\"ph1\">`dotnet test`</ph> command.","source":"Your code will be automatically rebuilt when you invoke `dotnet test` command."},{"pos":[19315,19434],"content":"Just remember to run <ph id=\"ph1\">`dotnet restore`</ph> from the command line any time you add a new dependency and you'll be good to go!","source":"Just remember to run `dotnet restore` from the command line any time you add a new dependency and you'll be good to go!"},{"content":"How to use multiple projects","pos":[19439,19467]},{"content":"A common need for larger libraries is to place functionality in different projects.","pos":[19469,19552]},{"content":"Imagine you wished to build a library which could be consumed in idiomatic C# and F#.","pos":[19554,19639]},{"content":"That would mean that consumers of your library consume them in ways which are natural to C# or F#.","pos":[19641,19739]},{"content":"For example, in C# you might consume the library like this:","pos":[19741,19800]},{"content":"In F#, it might look like this:","pos":[19932,19963]},{"content":"Consumption scenarios like this mean that the APIs being accessed have to have a different structure for C# and F#.","pos":[20099,20214]},{"content":"A common approach to accomplishing this is to factor all of the logic of a library into a core project, with C# and F# projects defining the API layers that call into that core project.","pos":[20216,20401]},{"content":"The rest of the section will use the following names:","pos":[20403,20456]},{"pos":[20460,20541],"content":"<bpt id=\"p1\">**</bpt>AwesomeLibrary.Core<ept id=\"p1\">**</ept> - A core project which contains all logic for the library","source":"**AwesomeLibrary.Core** - A core project which contains all logic for the library"},{"pos":[20544,20628],"content":"<bpt id=\"p1\">**</bpt>AwesomeLibrary.CSharp<ept id=\"p1\">**</ept> - A project with public APIs intended for consumption in C","source":"**AwesomeLibrary.CSharp** - A project with public APIs intended for consumption in C#"},{"pos":[20632,20716],"content":"<bpt id=\"p1\">**</bpt>AwesomeLibrary.FSharp<ept id=\"p1\">**</ept> - A project with public APIs intended for consumption in F","source":"**AwesomeLibrary.FSharp** - A project with public APIs intended for consumption in F#"},{"content":"Project-to-project referencing","pos":[20723,20753]},{"content":"To reference a project, you need to do two things:","pos":[20755,20805]},{"content":"Understand the name and version number of the project you wish to reference.","pos":[20810,20886]},{"content":"List that project as a dependency using the name and version number from (1).","pos":[20890,20967]},{"pos":[20969,21069],"content":"In the above case, you may wish to set up the <ph id=\"ph1\">`project.json`</ph> for <bpt id=\"p1\">**</bpt>AwesomeLibrary.Core<ept id=\"p1\">**</ept> as follows:","source":"In the above case, you may wish to set up the `project.json` for **AwesomeLibrary.Core** as follows:"},{"content":"You can use these entries in the <ph id=\"ph1\">`project.json`</ph> to control the name and version of the project.","pos":[21144,21239],"source":"You can use these entries in the `project.json` to control the name and version of the project."},{"content":"If you don't specify these, the default configuration is to use the name of the containing folder as the name and 1.0.0 as the version number.","pos":[21241,21383]},{"content":"The <ph id=\"ph1\">`project.json`</ph> files for both <bpt id=\"p1\">**</bpt>AwesomeLibrary.CSharp<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>AwesomeLibrary.FSharp<ept id=\"p2\">**</ept> now need to reference <bpt id=\"p3\">**</bpt>AwesomeLibrary.Core<ept id=\"p3\">**</ept> as a <ph id=\"ph2\">`project`</ph> target.","pos":[21385,21543],"source":"The `project.json` files for both **AwesomeLibrary.CSharp** and **AwesomeLibrary.FSharp** now need to reference **AwesomeLibrary.Core** as a `project` target."},{"content":"If you aren't multitargeting, you can use the global <ph id=\"ph1\">`dependencies`</ph> entry:","pos":[21545,21619],"source":"  If you aren't multitargeting, you can use the global `dependencies` entry:"},{"content":"<bpt id=\"p1\">**</bpt>Note:<ept id=\"p1\">**</ept> Failure to list the reference as a <ph id=\"ph1\">`project`</ph> target may result in NuGet resolving the dependency with an existing NuGet package which happens to have the same name.","pos":[21771,21945],"source":"**Note:** Failure to list the reference as a `project` target may result in NuGet resolving the dependency with an existing NuGet package which happens to have the same name."},{"content":"Always specify <ph id=\"ph1\">`\"target\":\"project\"`</ph> when referencing a project in the same solution.","pos":[21947,22031],"source":"  Always specify `\"target\":\"project\"` when referencing a project in the same solution."},{"content":"If you are multitargeting, you may not be able to use a global <ph id=\"ph1\">`dependencies`</ph> entry and may have to reference <bpt id=\"p1\">**</bpt>AwesomeLibrary.Core<ept id=\"p1\">**</ept> in a target-level <ph id=\"ph2\">`dependencies`</ph> entry.","pos":[22033,22206],"source":"If you are multitargeting, you may not be able to use a global `dependencies` entry and may have to reference **AwesomeLibrary.Core** in a target-level `dependencies` entry."},{"content":"For example, if you were targeting <ph id=\"ph1\">`netstandard1.6`</ph>, you could do so like this:","pos":[22208,22287],"source":"  For example, if you were targeting `netstandard1.6`, you could do so like this:"},{"content":"Structuring a Solution","pos":[22551,22573]},{"content":"Another important aspect of multi-project solutions is establishing a good overall project structure.","pos":[22575,22676]},{"content":"To structure a multi-project library, you must use top-level <ph id=\"ph1\">`/src`</ph> and <ph id=\"ph2\">`/test`</ph> folders:","pos":[22677,22765],"source":" To structure a multi-project library, you must use top-level `/src` and `/test` folders:"},{"pos":[23267,23329],"content":"The <ph id=\"ph1\">`global.json`</ph> file for this solution would look like this:","source":"The `global.json` file for this solution would look like this:"},{"pos":[23379,23596],"content":"This approach follows the same pattern established by project templates in the <ph id=\"ph1\">`dotnet new`</ph> command establish, where all projects are placed under a <ph id=\"ph2\">`/src`</ph> directory and all tests are placed under a <ph id=\"ph3\">`/test`</ph> directory.","source":"This approach follows the same pattern established by project templates in the `dotnet new` command establish, where all projects are placed under a `/src` directory and all tests are placed under a `/test` directory."},{"content":"Here's how you could restore packages, build, and test your entire project:","pos":[23598,23673]},{"content":"And that's it!","pos":[23948,23962]}],"content":"---\ntitle: Developing Libraries with Cross Platform Tools\ndescription: Developing Libraries with Cross Platform Tools\nkeywords: .NET, .NET Core\nauthor: cartermp\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: 9f6e8679-bd7e-4317-b3f9-7255a260d9cf\n---\n\n# Developing Libraries with Cross Platform Tools\n\n**Some details are subject to change as the toolchain evolves.**\n\nThis article covers how to write libraries for .NET using cross-platform CLI tools.  The CLI provides an efficient and low-level experience that works across any supported OS.  You can still build libraries with Visual Studio, and if that is your preferred experience [refer to the Visual Studio guide](libraries-with-vs.md).\n\n## Prerequisites\n\nYou need [the .NET Core SDK and CLI](https://www.microsoft.com/net/core) installed on your machine.\n\nFor the sections of this document dealing with .NET Framework versions or Portable Class Libraries (PCL), you need the [.NET Framework](http://getdotnet.azurewebsites.net/) installed on a Windows machine.  \n\nAdditionally, if you wish to support older .NET Framework targets, you need to install targeting/developer packs for older framework versions from the [.NET target platforms page](http://getdotnet.azurewebsites.net/target-dotnet-platforms.html).  Refer to this table:\n\n| .NET Framework Version | What to download |\n| ---------------------- | ----------------- |\n| 4.6.1 | .NET Framework 4.6.1 Targeting Pack |\n| 4.6 | .NET Framework 4.6 Targeting Pack |\n| 4.5.2 | .NET Framework 4.5.2 Developer Pack |\n| 4.5.1 | .NET Framework 4.5.1 Developer Pack |\n| 4.5 | Windows Software Development Kit for Windows 8 |\n| 4.0 | Windows SDK for Windows 7 and .NET Framework 4 |\n| 2.0, 3.0, and 3.5 | .NET Framework 3.5 SP1 Runtime (or Windows 8+ version) |\n\n## How to target the .NET Standard\n\nIf you're not quite familiar with the .NET Standard, refer to [the .NET Standard Library](../../standard/library.md) to learn more.\n\nIn that article, there is a table which maps .NET Standard versions to various implementations:\n\n| Platform Name | Alias |  |  |  |  |  | | |\n| :---------- | :--------- |:--------- |:--------- |:--------- |:--------- |:--------- |:--------- |:--------- |\n|.NET Standard | netstandard | 1.0 | 1.1 | 1.2 | 1.3 | 1.4 | 1.5 | 1.6 |\n|.NET Core|netcoreapp|&rarr;|&rarr;|&rarr;|&rarr;|&rarr;|&rarr;|1.0|\n|.NET Framework|net|&rarr;|4.5|4.5.1|4.6|4.6.1|4.6.2|4.6.3|\n|Mono/Xamarin Platforms||&rarr;|&rarr;|&rarr;|&rarr;|&rarr;|&rarr;|*|\n|Universal Windows Platform|uap|&rarr;|&rarr;|&rarr;|&rarr;|10.0|||\n|Windows|win|&rarr;|8.0|8.1|||||\n|Windows Phone|wpa|&rarr;|&rarr;|8.1|||||\n|Windows Phone Silverlight|wp|8.0|||||||\n\nHere's what this table means for the purposes of creating a library:\n\nThe version of the .NET Platform Standard you pick will be a tradeoff between access to the newest APIs and ability to target more .NET platforms and Framework versions.  You control the range of targetable platforms and versions by picking a version of `netstandardX.X` (Where `X.X` is a version number) and adding it to your `project.json` file.\n\nAdditionally, the corresponding [NuGet package to depend on](https://www.nuget.org/packages/NETStandard.Library/) is `NETStandard.Library` version `1.6.0`.  Although there's nothing preventing you from depending on `Microsoft.NETCore.App` like with console apps, it's generally not recommended.  If you need APIs from a package not specified in `NETStandard.Library`, you can always specify that package in addition to `NETStandard.Library` in the `dependencies` section of your `project.json` file.\n\nYou have three primary options when targeting the .NET Standard, depending on your needs.\n\n1. You can use the latest version of the .NET Standard - `netstandard1.6` - which is for when you want access to the most APIs and don't mind if you have less reach across implementations.\n2. You can use a lower version of the .NET Standard to target earlier .NET implementations. The cost here is not having access to some of the latest APIs.\n    \n    For example, if you wanted to have guaranteed compatibility with .NET Framework 4.6 and higher, you would pick `netstandard1.3`:\n\n    ```json\n    {\n        \"dependencies\":{\n            \"NETStandard.Library\":\"1.6.0\"\n        },\n        \"frameworks\":{\n            \"netstandard1.3\":{}\n        }\n    }\n    ```\n    \n    .NET Standard versions are backward compatible. That means that `netstandard1.0` libraries run on `netstandard1.1` platforms and higher.  However, there is no forward compatibility - lower .NET Standard platforms cannot reference higher ones.  This means that `netstandard1.0` libraries cannot reference libraries targeting `netstandard1.1` or higher.  Select the Standard version that has the right mix of APIs and platform support for your needs.\n    \n3. If you want to target the .NET Framework versions 4.0 or below, or you wish to use an API available in the .NET Framework but not in the .NET Standard (for example, `System.Drawing`), read the following sections and learn how to multitarget.\n\n## How to target the .NET Framework\n\n**NOTE:** These instructions assume you have the .NET Framework installed on your machine.  Refer to the [Prerequisites](#prerequisites) to get dependencies installed.\n\nKeep in mind that some of the .NET Framework versions used here are no longer in support.  Refer to the [.NET Framework Support Lifecycle Policy FAQ](https://support.microsoft.com/gp/framework_faq/en-us) about unsupported versions.\n\nIf you want to reach the maximum number of developers and projects, use the .NET Framework 4 as your baseline target. To target the .NET Framework, you will need to begin by using the correct Target Framework Moniker (TFM) that corresponds to the .NET Framework version you wish to support.\n\n```\n.NET Framework 2.0   --> net20\n.NET Framework 3.0   --> net30\n.NET Framework 3.5   --> net35\n.NET Framework 4.0   --> net40\n.NET Framework 4.5   --> net45\n.NET Framework 4.5.1 --> net451\n.NET Framework 4.5.2 --> net452\n.NET Framework 4.6   --> net46\n.NET Framework 4.6.1 --> net461\n.NET Framework 4.6.2 --> net462\n.NET Framework 4.6.3 --> net463\n```\n\nFor example, here's how you would write a library which targets the .NET Framework 4:\n\n```json\n{\n    \"frameworks\":{\n        \"net40\":{}\n    }\n}\n```\n\nAnd that's it!  Although this compiled only for the .NET Framework 4, you can use the library on newer versions of the .NET Framework.\n\n## How to target a Portable Class Library (PCL)\n\n**NOTE:** These instructions assume you have the .NET Framework installed on your machine.  Refer to the [Prerequisites](#prerequisites) to get dependencies installed.\n\nTargeting a PCL profile is a bit trickier than targeting .NET Standard or the .NET Framework.  For starters, [reference this list of PCL profiles](http://embed.plnkr.co/03ck2dCtnJogBKHJ9EjY/preview) to find the NuGet target which corresponds to the PCL profile you are targeting.\n\nThen, you need to do the following:\n\n1. Create a new entry under `frameworks` in your `project.json`, named `.NETPortable,Version=v{version},Profile=Profile{profile}`, where `{version}` and `{profile}` correspond to a PCL version number and Profile number, respectively.\n2. In this new entry, list every single assembly used for that target under a `frameworkAssemblies` entry.  This includes `mscorlib`, `System`, and `System.Core`.\n3. If you are multitargeting (see the next section), you must explicitly list dependencies for each target under their target entries.  You won't be able to use a global `dependencies` entry anymore.\n\nThe following is an example targeting PCL Profile 328. Profile 328 supports: .NET Standard 1.4, .NET Framework 4, Windows 8, Windows Phone 8.1, Windows Phone Silverlight 8.1, and Silverlight 5.\n\n```json\n{\n    \"frameworks\":{\n        \".NETPortable,Version=v4.0,Profile=Profile328\":{\n            \"frameworkAssemblies\":{\n                \"mscorlib\":\"\",\n                \"System\":\"\",\n                \"System.Core\":\"\"\n            }\n        }\n    }\n}\n```\n\nWhen you build a project that includes PCL Profile 328 as a framework in the *project.json* file, it will have this subfolder in the */bin/debug* folder:\n\n```\nportable-net40+sl50+netcore45+wpa81+wp8/\n```\n\nThis folder contains the `.dll` files necessary to run your library.\n\n## How to Multitarget\n\n**NOTE:** These following instructions assume you have the .NET Framework installed on your machine.  Refer to the [Prerequisites](#prerequisites) section to learn which dependencies you need to install and where to download them from.\n\nYou may need to target older versions of the .NET Framework when your project supports both the .NET Framework and .NET Core. In this scenario, if you want to use newer APIs and language constructs for the newer targets, use `#if` directives in your code. You also might need to add different packages and dependencies in your `project.json file` for each platform you're targeting to include the different APIs needed for each case.\n\nFor example, let's say you have a library that performs networking operations over HTTP. For .NET Standard and the .NET Framework versions 4.5 or higher, you can use the `HttpClient` class from the `System.Net.Http` namespace. However, earlier versions of the .NET Framework don't have the `HttpClient` class, so you could use the `WebClient` class from the `System.Net` namespace for those instead.\n\nSo, the `project.json` file could look like this:\n\n```json\n{\n    \"frameworks\":{\n        \"net40\":{\n            \"frameworkAssemblies\": {\n                \"System.Net\":\"\",\n                \"System.Text.RegularExpressions\":\"\"\n            }\n        },\n        \"net452\":{\n            \"frameworkAssemblies\":{\n                \"System.Net\":\"\",\n                \"System.Net.Http\":\"\",\n                \"System.Text.RegularExpressions\":\"\",\n                \"System.Threading.Tasks\":\"\"\n            }\n        },\n        \"netstandard1.6\":{\n            \"dependencies\": {\n                \"NETStandard.Library\":\"1.6.0\",\n            }\n        }\n    }\n}\n```\n\nNote that the .NET Framework assemblies need to be referenced explicitly in the `net40` and `net452` target, and NuGet references are also explicitly listed in the `netstandard1.6` target.  This is required in multitargeting scenarios.\n\nNext, the `using` statements in your source file can be adjusted like this:\n\n```csharp\n#if NET40\n// This only compiles for the .NET Framework 4 targets\nusing System.Net;\n#else\n// This compiles for all other targets\nusing System.Net.Http;\nusing System.Threading.Tasks;\n#endif\n```\n\nThe build system is aware of the following preprocessor symbols used in `#if` directives:\n\n```\n.NET Framework 2.0   --> NET20\n.NET Framework 3.5   --> NET35\n.NET Framework 4.0   --> NET40\n.NET Framework 4.5   --> NET45\n.NET Framework 4.5.1 --> NET451\n.NET Framework 4.5.2 --> NET452\n.NET Framework 4.6   --> NET46\n.NET Framework 4.6.1 --> NET461\n.NET Framework 4.6.2 --> NET462\n.NET Standard 1.0    --> NETSTANDARD1_0\n.NET Standard 1.1    --> NETSTANDARD1_1\n.NET Standard 1.2    --> NETSTANDARD1_2\n.NET Standard 1.3    --> NETSTANDARD1_3\n.NET Standard 1.4    --> NETSTANDARD1_4\n.NET Standard 1.5    --> NETSTANDARD1_5\n.NET Standard 1.6    --> NETSTANDARD1_6\n```\n\nAnd in the middle of the source, you can use `#if` directives to use those libraries conditionally. For example:\n\n```csharp\n    public class Library\n    {\n#if NET40\n        private readonly WebClient _client = new WebClient();\n        private readonly object _locker = new object();\n#else\n        private readonly HttpClient _client = new HttpClient();\n#endif\n\n#if NET40\n        // .NET Framework 4.0 does not have async/await\n        public string GetDotNetCount()\n        {\n            string url = \"http://www.dotnetfoundation.org/\";\n          \n            var uri = new Uri(url);\n            \n            string result = \"\";\n            \n            // Lock here to provide thread-safety.\n            lock(_locker)\n            {\n                result = _client.DownloadString(uri);\n            }\n            \n            int dotNetCount = Regex.Matches(result, \".NET\").Count;\n            \n            return $\"Dotnet Foundation mentions .NET {dotNetCount} times!\";\n        }\n#else\n        // .NET 4.5+ can use async/await!\n        public async Task<string> GetDotNetCountAsync()\n        {\n            string url = \"http://www.dotnetfoundation.org/\";\n            \n            // HttpClient is thread-safe, so no need to explicitly lock here\n            var result = await _client.GetStringAsync(url);\n            \n            int dotNetCount = Regex.Matches(result, \".NET\").Count;\n            \n            return $\"dotnetfoundation.orgmentions .NET {dotNetCount} times in its HTML!\";\n        }\n#endif\n    }\n```\n\nWhen you build a project that includes `net40`, `net45`, and `netstandard1.6` as frameworks in the *project.json* file, it will have these subfolders in the */bin/debug* folder:\n\n```\nnet40/\nnet45/\nnetstandard1.6/\n```\n\n### But What about Multitargeting with Portable Class Libraries?\n\nIf you want to cross-compile with a PCL target, you must add a build definition in your `project.json` file under `buildOptions` in your PCL target.  You can then use `#if` directives in the source which use the build definition as a preprocessor symbol.\n\nFor example, if you want to target [PCL profile 328](http://embed.plnkr.co/03ck2dCtnJogBKHJ9EjY/preview) (The .NET Framework 4, Windows 8, Windows Phone Silverlight 8, Windows Phone 8.1, Silverlight 5), you could to refer to it to as \"PORTABLE328\" when cross-compiling.  Simply add it to the `project.json` file as a `buildOptions` attribute:\n\n```json\n{\n    \"frameworks\":{\n        \"netstandard1.6\":{\n           \"dependencies\":{\n                \"NETStandard.Library\":\"1.6.0\",\n            }\n        },\n        \".NETPortable,Version=v4.0,Profile=Profile328\":{\n            \"buildOptions\": {\n                \"define\": [ \"PORTABLE328\" ]\n            },\n            \"frameworkAssemblies\":{\n                \"mscorlib\":\"\",\n                \"System\":\"\",\n                \"System.Core\":\"\",\n                \"System.Net\"\n            }\n        }\n    }\n}\n\n```\n\nNow you can conditionally compile against that target:\n\n```csharp\n#if !PORTABLE328\nusing System.Net.Http;\nusing System.Threading.Tasks;\n// Potentially other namespaces which aren't compatible with Profile 328\n#endif\n```\n\nBecause `PORTABLE328` is now recognized by the compiler, the PCL Profile 328 library generated by a compiler will not include `System.Net.Http` or `System.Threading.Tasks`.\n\nWhen you build a project that includes PCL Profile 328 and `netstandard1.6` as frameworks in the *project.json* file, it will have these subfolders in the */bin/debug* folder:\n\n```\nportable-net40+sl50+netcore45+wpa81+wp8/\nnetstandard1.6/\n```\n\n## How to use native dependencies\n\nYou may wish to write a library which depends on a native `.dll` file.  If you're writing such a library, you have have two options:\n\n1. Reference the native `.dll` directly in your `project.json`.\n2. Package that `.dll` into its own NuGet package and depend on that package.\n\nFor the first option, you'll need to include the following in your `project.json` file:\n\n1. Setting `allowUnsafe` to `true` in a `buildOptions` section.\n2. Specifying the path to the native `.dll`(s) with a [Runtime Identifier (RID)](../rid-catalog.md) under `files` in the `packOptions` section.\n\nIf you're distributing your library as a package, it's recommended that you place the `.dll` file at the root level of your project.  Here's an example `project.json` for a native `.dll` file that runs on Windows x64:\n\n```json\n{\n    \"buildOptions\":{\n        \"allowUnsafe\":true\n    },\n    \"packOptions\":{\n        \"files\":{\n            \"runtimes/win7-x64/native/\":\"native-lib.dll\"\n        }\n    }\n}\n```\n\nFor the second option, you'll need to build a NuGet package out of your `.dll` file(s), host on a NuGet or MyGet feed, and depend on it directly.  You'll still need to set `allowUnsafe` to `true` in the `buildOptions` section of your `project.json`.  Here's an example (assuming `MyNativeLib` is a Nuget package at version `1.2.0`):\n\n```json\n{\n    \"buildOptions\":{\n        \"allowUnsafe\":true\n    },\n    \"dependencies\":{\n        \"MyNativeLib\":\"1.2.0\"\n    }\n}\n```\n\nTo see an example of packaging up cross-platform native binaries, check out the [ASP.NET Libuv Package](https://github.com/aspnet/libuv-package) and the [corresponding reference in KestrelHttpServer](https://github.com/aspnet/KestrelHttpServer/blob/dev/src/Microsoft.AspNetCore.Server.Kestrel/project.json#L18).\n\n## How to test libraries on .NET Core\n\nIt's important to be able to test across platforms.  It's easiest to use [xUnit](http://xunit.github.io/), which is also the testing tool used by .NET Core projects.  How you set up your solution with test projects will depend on the [structure of your solution](#structuring-a-solution).  The following example assumes that all source projects are under a top-level `/src` folder and all test projects are under a top-level `/test` folder.\n\n1. Ensure you have a `global.json` file at the solution level which understands where the test projects are:\n    \n    ```json\n    {\n        \"projects\":[ \"src\", \"test\"]\n    }\n    ```\n    \n    Your solution folder structure should then look like this:\n    \n    ```\n    /SolutionWithSrcAndTest\n    |__global.json\n    |__/src\n    |__/test\n    ```\n    \n2. Create a new test project by creating a project folder under your `/test` folder, and a `project.json` file in the new project folder.  To create the `project.json` file you can run the `dotnet new` command and modify the `project.json` file afterwards.  The file should have the following:\n\n   * `netcoreapp1.0` listed as the only entry under `frameworks`.\n   * A reference to `Microsoft.NETCore.App` version `1.0.0`.\n   * A reference to xUnit version `2.2.0-beta2-build3300`.\n   * A reference to `dotnet-test-xunit` version `1.0.0-preview2-build1029`\n   * A project reference to the library being tested.\n   * The entry `\"testRunner\":\"xunit\"`.\n   \n   Here's an example (`LibraryUnderTest` version `1.0.0` is the library being tested):\n   \n   ```json\n   {\n        \"testRunner\":\"xunit\",\n        \"dependencies\":{\n            \"LibraryUnderTest\":{\n                \"version\":\"1.0.0\",\n                \"target\":\"project\"\n            },\n            \"Microsoft.NETCore.App\":{\n                \"version\":\"1.0.0\",\n                \"type\":\"platform\"\n            },\n            \"xunit\":\"2.2.0-beta2-build3300\",\n            \"dotnet-test-xunit\":\".0.0-preview2-build1029\",\n        },\n        \"frameworks\":{\n            \"netcoreapp1.0\":{}\n        }\n   }\n   ```\n3. Restore packages by running `dotnet restore`.  You should do this at the solution level if you haven't restored packages yet.\n\n4. Navigate to your test project and run tests with `dotnet test`:\n\n    ```\n    $ cd path-to-your-test-project\n    $ dotnet test\n    ```\n\nAnd that's it!  You can now test your library across all platforms using command line tools.  To continue testing now that you have everything set up, testing your library is very simple:\n\n1. Make changes to your library.\n2. Run tests from the command line, in your test directory, with `dotnet test` command.\n\nYour code will be automatically rebuilt when you invoke `dotnet test` command.\n\nJust remember to run `dotnet restore` from the command line any time you add a new dependency and you'll be good to go!\n\n## How to use multiple projects\n\nA common need for larger libraries is to place functionality in different projects.\n\nImagine you wished to build a library which could be consumed in idiomatic C# and F#.  That would mean that consumers of your library consume them in ways which are natural to C# or F#.  For example, in C# you might consume the library like this:\n\n```csharp\nvar convertResult = await AwesomeLibrary.ConvertAsync(data);\nvar result = AwesomeLibrary.Process(convertResult);\n```  \n\nIn F#, it might look like this:\n\n```fsharp\nlet result =\n    data\n    |> AwesomeLibrary.convertAsync \n    |> Async.RunSynchronously \n    |> AwesomeLibrary.process\n```\n\nConsumption scenarios like this mean that the APIs being accessed have to have a different structure for C# and F#.  A common approach to accomplishing this is to factor all of the logic of a library into a core project, with C# and F# projects defining the API layers that call into that core project.  The rest of the section will use the following names:\n\n* **AwesomeLibrary.Core** - A core project which contains all logic for the library\n* **AwesomeLibrary.CSharp** - A project with public APIs intended for consumption in C#\n* **AwesomeLibrary.FSharp** - A project with public APIs intended for consumption in F#\n\n### Project-to-project referencing\n\nTo reference a project, you need to do two things:\n\n1. Understand the name and version number of the project you wish to reference.\n2. List that project as a dependency using the name and version number from (1).\n\nIn the above case, you may wish to set up the `project.json` for **AwesomeLibrary.Core** as follows:\n\n```json\n{\n    \"name\":\"AwesomeLibrary.Core\",\n    \"version\":\"1.0.0\"\n}\n```\n\nYou can use these entries in the `project.json` to control the name and version of the project.  If you don't specify these, the default configuration is to use the name of the containing folder as the name and 1.0.0 as the version number.\n\nThe `project.json` files for both **AwesomeLibrary.CSharp** and **AwesomeLibrary.FSharp** now need to reference **AwesomeLibrary.Core** as a `project` target.  If you aren't multitargeting, you can use the global `dependencies` entry:\n\n```json\n{\n    \"dependencies\":{\n        \"AwesomeLibrary.Core\":{\n            \"version\":\"1.0.0\",\n            \"target\":\"project\"\n        }\n    }\n}\n```\n\n> **Note:** Failure to list the reference as a `project` target may result in NuGet resolving the dependency with an existing NuGet package which happens to have the same name.  Always specify `\"target\":\"project\"` when referencing a project in the same solution.\n\nIf you are multitargeting, you may not be able to use a global `dependencies` entry and may have to reference **AwesomeLibrary.Core** in a target-level `dependencies` entry.  For example, if you were targeting `netstandard1.6`, you could do so like this:\n\n```json\n{\n    \"frameworks\":{\n        \"netstandard1.6\":{\n            \"dependencies\":{\n                \"AwesomeLibrary.Core\":{\n                    \"version\":\"1.0.0\",\n                    \"target\":\"project\"\n                }\n            }\n        }\n    }\n}\n```\n\n### Structuring a Solution\n\nAnother important aspect of multi-project solutions is establishing a good overall project structure. To structure a multi-project library, you must use top-level `/src` and `/test` folders:\n\n```\n/AwesomeLibrary\n|__global.json\n|__/src\n   |__/AwesomeLibrary.Core\n      |__Source Files\n      |__project.json\n   |__/AwesomeLibrary.CSharp\n      |__Source Files\n      |__project.json\n   |__/AwesomeLibrary.FSharp\n      |__Source Files\n      |__project.json\n/test\n   |__/AwesomeLibrary.Core.Tests\n      |__Test Files\n      |__project.json\n   |__/AwesomeLibrary.CSharp.Tests\n      |__Test Files\n      |__project.json\n   |__/AwesomeLibrary.FSharp.Tests\n      |__Test Files\n      |__project.json\n```\n\nThe `global.json` file for this solution would look like this:\n\n```json\n{\n    \"projects\":[\"src\", \"test\"]\n}\n```\n\nThis approach follows the same pattern established by project templates in the `dotnet new` command establish, where all projects are placed under a `/src` directory and all tests are placed under a `/test` directory.\n\nHere's how you could restore packages, build, and test your entire project:\n\n```\n$ dotnet restore\n$ cd src/AwesomeLibrary.FSharp\n$ dotnet build\n$ cd ../AwesomeLibrary.CSharp\n$ dotnet build\n$ cd ../../test/AwesomeLibrary.Core.Tests\n$ dotnet test\n$ cd ../AwesomeLibrary.CSharp.Tests\n$ dotnet test\n$ cd ../AwesomeLibrary.FSharp.Tests\n$ dotnet test\n```\n\nAnd that's it!\n"}