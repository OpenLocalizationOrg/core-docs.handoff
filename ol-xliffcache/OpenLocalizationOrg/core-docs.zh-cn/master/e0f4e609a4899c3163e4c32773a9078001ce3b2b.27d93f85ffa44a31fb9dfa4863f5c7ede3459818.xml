{"nodes":[{"pos":[11,34],"content":"Async Programming in F#","needQuote":true,"nodes":[{"content":"Async Programming in F","pos":[0,22]}]},{"pos":[48,71],"content":"Async Programming in F#","needQuote":true,"nodes":[{"content":"Async Programming in F","pos":[0,22]}]},{"pos":[82,97],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":"Async Programming in F","pos":[303,325]},{"content":"<bpt id=\"p1\">**</bpt>Note:<ept id=\"p1\">**</ept> Some inaccuracies have been discovered in this article.","pos":[332,397],"source":"**Note:** Some inaccuracies have been discovered in this article."},{"content":"It is being rewritten.","pos":[399,421]},{"content":"See <bpt id=\"p1\">[</bpt>Issue #666<ept id=\"p1\">](https://github.com/dotnet/core-docs/issues/666)</ept> to learn about the changes.","pos":[423,515],"source":"  See [Issue #666](https://github.com/dotnet/core-docs/issues/666) to learn about the changes."},{"content":"Async programming in F# can be accomplished through a language-level programming model designed to be easy to use and natural to the language.","pos":[517,659]},{"pos":[661,914],"content":"The core of async programming in F# is <ph id=\"ph1\">`Async&lt;'T&gt;`</ph>, a representation of work that can be triggered to run in the background, where <ph id=\"ph2\">`'T`</ph> is either the type returned via the special <ph id=\"ph3\">`return`</ph> keyword or <ph id=\"ph4\">`unit`</ph> if the async workflow has no result to return.","source":"The core of async programming in F# is `Async<'T>`, a representation of work that can be triggered to run in the background, where `'T` is either the type returned via the special `return` keyword or `unit` if the async workflow has no result to return."},{"content":"The key concept to understand is that an async expression’s type is <ph id=\"ph1\">`Async&lt;'T&gt;`</ph>, which is merely a <bpt id=\"p1\">_</bpt>specification<ept id=\"p1\">_</ept> of work to be done in an asynchronous context.","pos":[916,1077],"source":"The key concept to understand is that an async expression’s type is `Async<'T>`, which is merely a _specification_ of work to be done in an asynchronous context."},{"content":"It is not executed until you explicitly start it with one of the starting functions (such as <ph id=\"ph1\">`Async.RunSynchronously`</ph>).","pos":[1078,1197],"source":" It is not executed until you explicitly start it with one of the starting functions (such as `Async.RunSynchronously`)."},{"content":"Although this is a different way of thinking about doing work, it ends up being quite simple in practice.","pos":[1198,1303]},{"content":"For example, say you wanted to download the HTML from dotnetfoundation.org without blocking the main thread.","pos":[1305,1413]},{"content":"You can accomplish it like this:","pos":[1414,1446]},{"content":"And that’s it!","pos":[1855,1869]},{"content":"Aside from the use of <ph id=\"ph1\">`async`</ph>, <ph id=\"ph2\">`let!`</ph>, and <ph id=\"ph3\">`return`</ph>, this is just normal F# code.","pos":[1870,1951],"source":" Aside from the use of `async`, `let!`, and `return`, this is just normal F# code."},{"content":"There are a few syntactical constructs which are worth noting:","pos":[1953,2015]},{"pos":[2028,2100],"content":"binds the result of an async expression (which runs on another context)."},{"pos":[2112,2195],"content":"works just like <ph id=\"ph1\">`let!`</ph>, but disposes its bound resources when it goes out of scope.","source":" works just like `let!`, but disposes its bound resources when it goes out of scope."},{"pos":[2206,2265],"content":"will await an async workflow which doesn’t return anything."},{"pos":[2279,2328],"content":"simply returns a result from an async expression."},{"pos":[2343,2416],"content":"executes another async workflow and returns its return value as a result."},{"pos":[2418,2552],"content":"Additionally, normal <ph id=\"ph1\">`let`</ph>, <ph id=\"ph2\">`use`</ph>, and <ph id=\"ph3\">`do`</ph> keywords can be used alongside the async versions just as they would in a normal function.","source":"Additionally, normal `let`, `use`, and `do` keywords can be used alongside the async versions just as they would in a normal function."},{"content":"How to start Async Code in F","pos":[2557,2585]},{"content":"As mentioned earlier, async code is a specification of work to be done in another context which needs to be explicitly started.","pos":[2590,2717]},{"content":"Here are two primary ways to accomplish this:","pos":[2718,2763]},{"pos":[2794,2862],"content":"will start an async workflow on another thread and await its result."},{"pos":[3305,3387],"content":"will start an async workflow on another thread, and will <bpt id=\"p1\">**</bpt>not<ept id=\"p1\">**</ept> await its result.","source":" will start an async workflow on another thread, and will **not** await its result."},{"content":"There are other ways to start an async workflow available for more specific scenarios.","pos":[3787,3873]},{"content":"They are detailed <bpt id=\"p1\">[</bpt>in the Async reference<ept id=\"p1\">](https://msdn.microsoft.com/library/ee370232.aspx)</ept>.","pos":[3874,3967],"source":" They are detailed [in the Async reference](https://msdn.microsoft.com/library/ee370232.aspx)."},{"content":"A Note on Threads","pos":[3973,3990]},{"content":"The phrase “on another thread” is mentioned above, but it is important to know that <bpt id=\"p1\">**</bpt>this does not mean that async workflows are a facade for multithreading<ept id=\"p1\">**</ept>.","pos":[3992,4152],"source":"The phrase “on another thread” is mentioned above, but it is important to know that **this does not mean that async workflows are a facade for multithreading**."},{"content":"The workflow actually “jumps” between threads, borrowing them for a small amount of time to do useful work.","pos":[4153,4260]},{"content":"When an async workflow is effectively “waiting” (e.g. waiting for a network call to return something), any thread it was borrowing at the time is freed up to go do useful work on something else.","pos":[4261,4455]},{"content":"This allows async workflows to utilize the system they run on as effectively as possible, and makes them especially strong for high-volume I/O scenarios.","pos":[4456,4609]},{"content":"How to Add Parallelism to Async Code","pos":[4614,4650]},{"content":"Sometimes you may need to perform multiple asynchronous jobs in parallel, collect their results, and interpret them in some way.","pos":[4652,4780]},{"content":"allows you to do this without needing to use the Task Parallel Library, which would involve needing to coerce <ph id=\"ph1\">`Task&lt;'T&gt;`</ph> and <ph id=\"ph2\">`Async&lt;'T&gt;`</ph> types.","pos":[4798,4941],"source":" allows you to do this without needing to use the Task Parallel Library, which would involve needing to coerce `Task<'T>` and `Async<'T>` types."},{"pos":[4943,5128],"content":"The following example will use <ph id=\"ph1\">`Async.Parallel`</ph> to download the HTML from four popular sites in parallel, wait for those tasks to complete, and then print the HTML which was downloaded.","source":"The following example will use `Async.Parallel` to download the HTML from four popular sites in parallel, wait for those tasks to complete, and then print the HTML which was downloaded."},{"content":"Important Info and Advice","pos":[5816,5841]},{"content":"Append “Async” to the end of any functions you’ll consume","pos":[5847,5904]},{"content":"Although this is just a naming convention, it does make things like API discoverability easier.","pos":[5907,6002]},{"content":"Particularly if there are synchronous and asynchronous versions of the same routine, it’s a good idea to explicitly state which is asynchronous via the name.","pos":[6003,6160]},{"content":"Listen to the compiler!","pos":[6166,6189]},{"content":"F#’s compiler is very strict, making it nearly impossible to do something troubling like run “async” code synchronously.","pos":[6192,6312]},{"content":"If you come across a warning, that’s a sign that the code won’t execute how you think it will.","pos":[6313,6407]},{"content":"If you can make the compiler happy, your code will most likely execute as expected.","pos":[6408,6491]},{"content":"For the C#/VB Programmer Looking Into F","pos":[6496,6535]},{"content":"This section assumes you’re familiar with the async model in C#/VB.","pos":[6540,6607]},{"content":"If you are not, <bpt id=\"p1\">[</bpt>Async Programming in C#<ept id=\"p1\">](../csharp/async.md)</ept> is a starting point.","pos":[6608,6690],"source":" If you are not, [Async Programming in C#](../csharp/async.md) is a starting point."},{"content":"There is a fundamental difference between the C#/VB async model and the F# async model.","pos":[6692,6779]},{"content":"When you call a function which returns a <ph id=\"ph1\">`Task`</ph> or <ph id=\"ph2\">`Task&lt;'T&gt;`</ph>, that job has already begun execution.","pos":[6781,6881],"source":"When you call a function which returns a `Task` or `Task<'T>`, that job has already begun execution."},{"content":"The handle returned represents an already-running asynchronous job.","pos":[6882,6949]},{"content":"In contrast, when you call an async function in F#, the <ph id=\"ph1\">`Async&lt;'a&gt;`</ph> returned represents a job which will be <bpt id=\"p1\">**</bpt>generated<ept id=\"p1\">**</ept> at some point.","pos":[6950,7086],"source":" In contrast, when you call an async function in F#, the `Async<'a>` returned represents a job which will be **generated** at some point."},{"content":"Understanding this model is powerful, because it allows for asynchronous jobs in F# to be chained together easier, performed conditionally, and be started with a finer grain of control.","pos":[7087,7272]},{"content":"There are a few other similarities and differences worth noting.","pos":[7274,7338]},{"content":"Similarities","pos":[7344,7356]},{"pos":[7368,7471],"content":", <ph id=\"ph1\">`use!`</ph>, and <ph id=\"ph2\">`do!`</ph> are analogous to <ph id=\"ph3\">`await`</ph> when calling an async job from within an <ph id=\"ph4\">`async{ }`</ph> block.","source":", `use!`, and `do!` are analogous to `await` when calling an async job from within an `async{ }` block."},{"content":"The three keywords can only be used within an <ph id=\"ph1\">`async { }`</ph> block, similar to how <ph id=\"ph2\">`await`</ph> can only be invoked inside an <ph id=\"ph3\">`async`</ph> method.","pos":[7474,7607],"source":"The three keywords can only be used within an `async { }` block, similar to how `await` can only be invoked inside an `async` method."},{"content":"In short, <ph id=\"ph1\">`let!`</ph> is for when you want to capture and use a result, <ph id=\"ph2\">`use!`</ph> is the same but for something whose resources should get cleaned after it’s used, and <ph id=\"ph3\">`do!`</ph> is for when you want to wait for an async workflow with no return value to finish before moving on.","pos":[7608,7873],"source":" In short, `let!` is for when you want to capture and use a result, `use!` is the same but for something whose resources should get cleaned after it’s used, and `do!` is for when you want to wait for an async workflow with no return value to finish before moving on."},{"content":"F# supports data-parallelism in a similar way.","pos":[7879,7925]},{"pos":[7928,8100],"content":"Although it operates very differently, <ph id=\"ph1\">`Async.Parallel`</ph> corresponds to <ph id=\"ph2\">`Task.WhenAll`</ph> for the scenario of wanting the results of a set of async jobs when they all complete.","source":"Although it operates very differently, `Async.Parallel` corresponds to `Task.WhenAll` for the scenario of wanting the results of a set of async jobs when they all complete."},{"content":"Differences","pos":[8106,8117]},{"pos":[8123,8166],"content":"Nested <ph id=\"ph1\">`let!`</ph> is not allowed, unlike nested","source":"Nested `let!` is not allowed, unlike nested "},{"pos":[8177,8331],"content":"Unlike <ph id=\"ph1\">`await`</ph>, which can be nested indefinitely, <ph id=\"ph2\">`let!`</ph> cannot and must have its result bound before using it inside of another <ph id=\"ph3\">`let!`</ph>, <ph id=\"ph4\">`do!`</ph>, or <ph id=\"ph5\">`use!`</ph>.","source":"Unlike `await`, which can be nested indefinitely, `let!` cannot and must have its result bound before using it inside of another `let!`, `do!`, or `use!`."},{"content":"Cancellation support is simpler in F# than in C#/VB.","pos":[8337,8389]},{"pos":[8392,8633],"content":"Supporting cancellation of a task midway through its execution in C#/VB requires checking the <ph id=\"ph1\">`IsCancellationRequested`</ph> property or calling <ph id=\"ph2\">`ThrowIfCancellationRequested()`</ph> on a <ph id=\"ph3\">`CancellationToken`</ph> object that’s passed into the async method.","source":"Supporting cancellation of a task midway through its execution in C#/VB requires checking the `IsCancellationRequested` property or calling `ThrowIfCancellationRequested()` on a `CancellationToken` object that’s passed into the async method."},{"content":"In contrast, F# async workflows are more naturally cancellable.","pos":[8635,8698]},{"content":"Cancellation is a simple three-step process.","pos":[8699,8743]},{"pos":[8749,8788],"content":"Create a new <ph id=\"ph1\">`CancellationTokenSource`</ph>.","source":"Create a new `CancellationTokenSource`."},{"content":"Pass it into a starting function.","pos":[8793,8826]},{"pos":[8831,8858],"content":"Call <ph id=\"ph1\">`Cancel`</ph> on the token.","source":"Call `Cancel` on the token."},{"content":"Example:","pos":[8860,8868]},{"content":"And that’s it!","pos":[9276,9290]},{"content":"Further resources:","pos":[9295,9313]},{"content":"Async Workflows on MSDN","pos":[9320,9343]},{"content":"Asynchronous Sequences for F","pos":[9400,9428]},{"content":"F# Data HTTP Utilities","pos":[9511,9533]}],"content":"---\ntitle: Async Programming in F#\ndescription: Async Programming in F#\nkeywords: .NET, .NET Core\nauthor: cartermp\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: f9196bfc-b8a8-4d33-8b53-0dcbd58a69d8\n---\n\n# Async Programming in F# #\n\n> **Note:** Some inaccuracies have been discovered in this article.  It is being rewritten.  See [Issue #666](https://github.com/dotnet/core-docs/issues/666) to learn about the changes.\n\nAsync programming in F# can be accomplished through a language-level programming model designed to be easy to use and natural to the language.\n\nThe core of async programming in F# is `Async<'T>`, a representation of work that can be triggered to run in the background, where `'T` is either the type returned via the special `return` keyword or `unit` if the async workflow has no result to return.\n\nThe key concept to understand is that an async expression’s type is `Async<'T>`, which is merely a _specification_ of work to be done in an asynchronous context. It is not executed until you explicitly start it with one of the starting functions (such as `Async.RunSynchronously`). Although this is a different way of thinking about doing work, it ends up being quite simple in practice.\n\nFor example, say you wanted to download the HTML from dotnetfoundation.org without blocking the main thread. You can accomplish it like this:\n\n```fs\nlet fetchHtmlAsync url = async {\n    let uri = new System.Uri(url)\n    let webClient = new System.Net.WebClient()\n\n    // Execution of fetchHtmlAsync won't continue until the result\n    // of AsyncDownloadString is bound.\n    let! html = webClient.AsyncDownloadString(uri)\n    return html\n}\n\nlet html = \"http://dotnetfoundation.org\" |> fetchHtmlAsync |> Async.RunSynchronously\nprintfn \"%s\" html\n\n```\n\nAnd that’s it! Aside from the use of `async`, `let!`, and `return`, this is just normal F# code.\n\nThere are a few syntactical constructs which are worth noting:\n\n*   `let!` binds the result of an async expression (which runs on another context).\n*   `use!` works just like `let!`, but disposes its bound resources when it goes out of scope.\n*   `do!` will await an async workflow which doesn’t return anything.\n*   `return` simply returns a result from an async expression.\n*   `return!` executes another async workflow and returns its return value as a result.\n\nAdditionally, normal `let`, `use`, and `do` keywords can be used alongside the async versions just as they would in a normal function.\n\n## How to start Async Code in F# #\n\nAs mentioned earlier, async code is a specification of work to be done in another context which needs to be explicitly started. Here are two primary ways to accomplish this:\n\n1.  `Async.RunSynchronously` will start an async workflow on another thread and await its result.\n\n ```fs\n let fetchHtmlAsync url = async {\n     let uri = new System.Uri(url)\n     let webClient = new System.Net.WebClient()\n     let! html = webClient.AsyncDownloadString(uri)\n     return html\n }\n\n // Execution will pause until fetchHtmlAsync finishes\n let html = \"http://dotnetfoundation.org\" |> fetchHtmlAsync |> Async.RunSynchronously\n\n // you actually have the result from fetchHtmlAsync now!\n printfn \"%s\" html\n\n ```\n\n2.  `Async.Start` will start an async workflow on another thread, and will **not** await its result.\n\n ```fs\n let uploadDataAsync url data = async {\n     let uri = new System.Uri(url)\n     let webClient = new System.Net.WebClient()\n     webClient.UploadStringAsync(uri, data)\n }\n\n let workflow = uploadDataAsync \"http://url-to-upload-to.com\" \"hello, world!\"\n\n // Execution will continue after calling this!\n Async.Run(workflow)\n\n printfn \"%s\" \"uploadDataAsync is running in the background...\"\n\n ```\n\nThere are other ways to start an async workflow available for more specific scenarios. They are detailed [in the Async reference](https://msdn.microsoft.com/library/ee370232.aspx).\n\n### A Note on Threads\n\nThe phrase “on another thread” is mentioned above, but it is important to know that **this does not mean that async workflows are a facade for multithreading**. The workflow actually “jumps” between threads, borrowing them for a small amount of time to do useful work. When an async workflow is effectively “waiting” (e.g. waiting for a network call to return something), any thread it was borrowing at the time is freed up to go do useful work on something else. This allows async workflows to utilize the system they run on as effectively as possible, and makes them especially strong for high-volume I/O scenarios.\n\n## How to Add Parallelism to Async Code\n\nSometimes you may need to perform multiple asynchronous jobs in parallel, collect their results, and interpret them in some way. `Async.Parallel` allows you to do this without needing to use the Task Parallel Library, which would involve needing to coerce `Task<'T>` and `Async<'T>` types.\n\nThe following example will use `Async.Parallel` to download the HTML from four popular sites in parallel, wait for those tasks to complete, and then print the HTML which was downloaded.\n\n```fs\nlet urlList = [\n    \"http://www.microsoft.com\"\n    \"http://www.google.com\"\n    \"http://www.amazon.com\"\n    \"http://www.facebook.com\" ]\n\nlet fetchHtmlAsync url = async {\n    let uri = new System.Uri(url)\n    let webClient = new System.Net.WebClient()\n    let! html = webClient.AsyncDownloadString(uri)\n    return html\n}\n\nlet getHtmlList =\n    Seq.map fetchHtmlAsync    // Build an Async<'T> for each site\n    >> Async.Parallel         // Returns an Async<'T []>\n    >> Async.RunSynchronously // Wait for the result of the parallel work\n\nlet htmlList = urlList |> getHtmlList\n\n// We now have the downloaded HTML for each site!\nfor html in htmlList do\n    printfn \"%s\" html\n\n```\n\n## Important Info and Advice\n\n*   Append “Async” to the end of any functions you’ll consume\n\n Although this is just a naming convention, it does make things like API discoverability easier. Particularly if there are synchronous and asynchronous versions of the same routine, it’s a good idea to explicitly state which is asynchronous via the name.\n\n*   Listen to the compiler!\n\n F#’s compiler is very strict, making it nearly impossible to do something troubling like run “async” code synchronously. If you come across a warning, that’s a sign that the code won’t execute how you think it will. If you can make the compiler happy, your code will most likely execute as expected.\n\n## For the C#/VB Programmer Looking Into F# #\n\nThis section assumes you’re familiar with the async model in C#/VB. If you are not, [Async Programming in C#](../csharp/async.md) is a starting point.\n\nThere is a fundamental difference between the C#/VB async model and the F# async model.\n\nWhen you call a function which returns a `Task` or `Task<'T>`, that job has already begun execution. The handle returned represents an already-running asynchronous job. In contrast, when you call an async function in F#, the `Async<'a>` returned represents a job which will be **generated** at some point. Understanding this model is powerful, because it allows for asynchronous jobs in F# to be chained together easier, performed conditionally, and be started with a finer grain of control.\n\nThere are a few other similarities and differences worth noting.\n\n### Similarities\n\n*   `let!`, `use!`, and `do!` are analogous to `await` when calling an async job from within an `async{ }` block.\n\n The three keywords can only be used within an `async { }` block, similar to how `await` can only be invoked inside an `async` method. In short, `let!` is for when you want to capture and use a result, `use!` is the same but for something whose resources should get cleaned after it’s used, and `do!` is for when you want to wait for an async workflow with no return value to finish before moving on.\n\n*   F# supports data-parallelism in a similar way.\n\n Although it operates very differently, `Async.Parallel` corresponds to `Task.WhenAll` for the scenario of wanting the results of a set of async jobs when they all complete.\n\n### Differences\n\n*   Nested `let!` is not allowed, unlike nested `await`\n\n Unlike `await`, which can be nested indefinitely, `let!` cannot and must have its result bound before using it inside of another `let!`, `do!`, or `use!`.\n\n*   Cancellation support is simpler in F# than in C#/VB.\n\n Supporting cancellation of a task midway through its execution in C#/VB requires checking the `IsCancellationRequested` property or calling `ThrowIfCancellationRequested()` on a `CancellationToken` object that’s passed into the async method.\n\nIn contrast, F# async workflows are more naturally cancellable. Cancellation is a simple three-step process.\n\n1.  Create a new `CancellationTokenSource`.\n2.  Pass it into a starting function.\n3.  Call `Cancel` on the token.\n\nExample:\n\n```fs\nlet uploadDataAsync url data = async {\n    let uri = new System.Uri(url)\n    let webClient = new System.Net.WebClient()\n    webClient.UploadStringAsync(uri, data)\n}\n\nlet workflow = uploadDataAsync \"http://url-to-upload-to.com\" \"hello, world!\"\n\nlet token = new CancellationTokenSource()\nAsync.Start (workflow, token)\n\n// Immediately cancel uploadDataAsync after it's been started.\ntoken.Cancel()\n```\n\nAnd that’s it!\n\n## Further resources:\n\n*   [Async Workflows on MSDN](https://msdn.microsoft.com/library/dd233250.aspx)\n*   [Asynchronous Sequences for F#](http://fsprojects.github.io/FSharp.Control.AsyncSeq/library/AsyncSeq.html)\n*   [F# Data HTTP Utilities](https://fsharp.github.io/FSharp.Data/library/Http.html)\n"}