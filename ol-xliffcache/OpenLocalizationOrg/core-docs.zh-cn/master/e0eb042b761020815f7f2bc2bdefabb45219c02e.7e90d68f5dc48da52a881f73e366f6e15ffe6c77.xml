{"nodes":[{"content":"How to: Create an Object Pool by Using a ConcurrentBag","pos":[12,66]},{"content":"How to: Create an Object Pool by Using a ConcurrentBag","pos":[82,136]},{"pos":[148,163],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":"How to: Create an Object Pool by Using a ConcurrentBag","pos":[367,421]},{"content":"This example shows how to use a concurrent bag to implement an object pool.","pos":[423,498]},{"content":"Object pools can improve application performance in situations where you require multiple instances of a class and the class is expensive to create or destroy.","pos":[499,658]},{"content":"When a client program requests a new object, the object pool first attempts to provide one that has already been created and returned to the pool.","pos":[659,805]},{"content":"If none is available, only then is a new object created.","pos":[806,862]},{"content":"<bpt id=\"p1\">[</bpt>ConcurrentBag<ph id=\"ph1\">&amp;lt;</ph>T<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1)</ept> is used to store the objects because it supports fast insertion and removal, especially when the same thread is both adding and removing items.","pos":[865,1123],"source":"[ConcurrentBag&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1) is used to store the objects because it supports fast insertion and removal, especially when the same thread is both adding and removing items."},{"content":"This example could be further augmented to be built around a <bpt id=\"p1\">[</bpt>IProducerConsumerCollection<ph id=\"ph1\">&amp;lt;</ph>T<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept>, which the bag data structure implements, as do <bpt id=\"p2\">[</bpt>ConcurrentQueue<ph id=\"ph3\">&amp;lt;</ph>T<ph id=\"ph4\">&amp;gt;</ph><ept id=\"p2\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1)</ept> and <bpt id=\"p3\">[</bpt>ConcurrentStack<ph id=\"ph5\">&amp;lt;</ph>T<ph id=\"ph6\">&amp;gt;</ph><ept id=\"p3\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1)</ept>.","pos":[1124,1618],"source":" This example could be further augmented to be built around a [IProducerConsumerCollection&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1), which the bag data structure implements, as do [ConcurrentQueue&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1) and [ConcurrentStack&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1)."},{"content":"Example","pos":[1623,1630]},{"content":"See Also","pos":[4362,4370]},{"content":"System.Collections.Concurrent","pos":[4373,4402]},{"content":"Thread-Safe Collections","pos":[4480,4503]}],"content":"---\ntitle: \"How to: Create an Object Pool by Using a ConcurrentBag\"\ndescription: \"How to: Create an Object Pool by Using a ConcurrentBag\"\nkeywords: .NET, .NET Core\nauthor: mairaw\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: 87a6ada1-ee27-423d-b587-82e7cb45361b\n---\n\n# How to: Create an Object Pool by Using a ConcurrentBag\n\nThis example shows how to use a concurrent bag to implement an object pool. Object pools can improve application performance in situations where you require multiple instances of a class and the class is expensive to create or destroy. When a client program requests a new object, the object pool first attempts to provide one that has already been created and returned to the pool. If none is available, only then is a new object created. \n\n[ConcurrentBag&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1) is used to store the objects because it supports fast insertion and removal, especially when the same thread is both adding and removing items. This example could be further augmented to be built around a [IProducerConsumerCollection&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1), which the bag data structure implements, as do [ConcurrentQueue&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1) and [ConcurrentStack&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1).\n\n## Example\n\n```csharp\nusing System;\nusing System.Collections.Concurrent;\nusing System.Threading;\nusing System.Threading.Tasks;\n\n\nnamespace ObjectPoolExample\n{\n    public class ObjectPool<T>\n    {\n        private ConcurrentBag<T> _objects;\n        private Func<T> _objectGenerator;\n\n        public ObjectPool(Func<T> objectGenerator)\n        {\n            if (objectGenerator == null) throw new ArgumentNullException(\"objectGenerator\");\n            {\n                _objects = new ConcurrentBag<T>();\n                _objectGenerator = objectGenerator;\n            }\n        }\n\n        public T GetObject()\n        {\n            T item;\n            if (_objects.TryTake(out item)) return item;\n            {\n                return _objectGenerator();\n            }\n        }\n\n        public void PutObject(T item)\n        {\n            _objects.Add(item);\n        }\n    }\n\n    class Program\n    {\n       static void Main(string[] args)\n        {\n            CancellationTokenSource cts = new CancellationTokenSource();\n\n            // Create an opportunity for the user to cancel.\n            Task.Run(() =>\n                {\n                    if (Console.ReadKey().KeyChar == 'c' || Console.ReadKey().KeyChar == 'C')\n                        cts.Cancel();\n                });\n\n            ObjectPool<MyClass> pool = new ObjectPool<MyClass> (() => new MyClass());            \n\n            // Create a high demand for MyClass objects.\n            Parallel.For(0, 1000000, (i, loopState) =>\n                {\n                    MyClass mc = pool.GetObject();\n                    Console.CursorLeft = 0;\n                    // This is the bottleneck in our application. All threads in this loop\n                    // must serialize their access to the static Console class.\n                    Console.WriteLine(\"{0:####.####}\", mc.GetValue(i));                 \n\n                    pool.PutObject(mc);\n                    if (cts.Token.IsCancellationRequested)\n                        loopState.Stop();                 \n                });\n            Console.WriteLine(\"Press the Enter key to exit.\");\n            Console.ReadLine();\n            cts.Dispose();\n        }\n    }\n\n    // A toy class that requires some resources to create.\n    // You can experiment here to measure the performance of the\n    // object pool vs. ordinary instantiation.\n    class MyClass\n    {\n        public int[] Nums {get; set;}\n        public double GetValue(long i)\n        {\n            return Math.Sqrt(Nums[i]);\n        }\n        public MyClass()\n        {\n            Nums = new int[1000000];\n            Random rand = new Random();\n            for (int i = 0; i < Nums.Length; i++)\n                Nums[i] = rand.Next();\n        }\n    }   \n}\n```\n\n## See Also\n\n[System.Collections.Concurrent](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)\n\n[Thread-Safe Collections](index.md)\n\n\n"}