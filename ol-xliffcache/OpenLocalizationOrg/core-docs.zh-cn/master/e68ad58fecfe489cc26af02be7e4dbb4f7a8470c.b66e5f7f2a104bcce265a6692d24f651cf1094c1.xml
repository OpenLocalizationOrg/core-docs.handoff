{"nodes":[{"content":"How to: Use Arrays of Blocking Collections in a Pipeline","pos":[12,68]},{"content":"How to: Use Arrays of Blocking Collections in a Pipeline","pos":[84,140]},{"pos":[152,167],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":"How to: Use Arrays of Blocking Collections in a Pipeline","pos":[371,427]},{"pos":[429,768],"content":"The following example shows how to use arrays of <bpt id=\"p1\">[</bpt>System.Collections.Concurrent.BlockingCollection<ph id=\"ph1\">&amp;lt;</ph>T<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> objects with static methods such as <ph id=\"ph3\">`TryAddToAny`</ph> and <ph id=\"ph4\">`TryTakeFromAny`</ph> to implement fast and flexible data transfer between components.","source":"The following example shows how to use arrays of [System.Collections.Concurrent.BlockingCollection&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1) objects with static methods such as `TryAddToAny` and `TryTakeFromAny` to implement fast and flexible data transfer between components."},{"content":"Example","pos":[774,781]},{"content":"The following example demonstrates a basic pipeline implementation in which each object is concurrently taking data from the input collection, transforming it, and passing it to the output collection.","pos":[783,983]},{"content":"See Also","pos":[6299,6307]},{"content":"System.Collections.Concurrent","pos":[6310,6339]},{"content":"Thread-Safe Collections","pos":[6417,6440]}],"content":"---\ntitle: \"How to: Use Arrays of Blocking Collections in a Pipeline\"\ndescription: \"How to: Use Arrays of Blocking Collections in a Pipeline\"\nkeywords: .NET, .NET Core\nauthor: mairaw\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: 278a6566-09ba-4022-8802-e160e75b86af\n---\n\n# How to: Use Arrays of Blocking Collections in a Pipeline\n\nThe following example shows how to use arrays of [System.Collections.Concurrent.BlockingCollection&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1) objects with static methods such as `TryAddToAny` and `TryTakeFromAny` to implement fast and flexible data transfer between components. \n\n## Example\n\nThe following example demonstrates a basic pipeline implementation in which each object is concurrently taking data from the input collection, transforming it, and passing it to the output collection.\n\n```csharp\nusing System;\nusing System.Collections.Concurrent;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\n\n\nclass PipeLineDemo\n{\n   public static void Main()\n   {\n      CancellationTokenSource cts = new CancellationTokenSource();\n\n      // Start up a UI thread for cancellation.\n      Task.Run(() =>\n          {\n              if(Console.ReadKey(true).KeyChar == 'c')\n              {\n                  cts.Cancel();\n              }  \n          });\n\n      //Generate some source data.\n      BlockingCollection<int>[] sourceArrays = new BlockingCollection<int>[5];\n      for(int i = 0; i < sourceArrays.Length; i++)\n          sourceArrays[i] = new BlockingCollection<int>(500);\n      Parallel.For(0, sourceArrays.Length * 500, (j) =>\n                          {\n                              int k = BlockingCollection<int>.TryAddToAny(sourceArrays, j);\n                              if(k >=0)\n                                  Console.WriteLine(\"added {0} to source data\", j);\n                          });\n\n      foreach (var arr in sourceArrays)\n          arr.CompleteAdding();\n\n      // First filter accepts the ints, keeps back a small percentage\n      // as a processing fee, and converts the results to decimals.\n      var filter1 = new PipelineFilter<int, decimal>\n      (\n          sourceArrays,\n          (n) => Convert.ToDecimal(n * 0.97),\n          cts.Token,\n          \"filter1\"\n       );\n\n      // Second filter accepts the decimals and converts them to\n      // System.Strings.\n      var filter2 = new PipelineFilter<decimal, string>\n      (\n          filter1.m_output,\n          (s) => String.Format(\"{0}\", s),\n          cts.Token,\n          \"filter2\"\n       );\n\n      // Third filter uses the constructor with an Action<T>\n      // that renders its output to the screen,\n      // not a blocking collection.\n      var filter3 = new PipelineFilter<string, string>\n      (\n          filter2.m_output,\n          (s) => Console.WriteLine(\"The final result is {0}\", s),\n          cts.Token,\n          \"filter3\"\n       );\n\n       // Start up the pipeline!\n      try\n      {\n          Parallel.Invoke(\n                       () => filter1.Run(),\n                       () => filter2.Run(),\n                       () => filter3.Run()\n                   );\n      }\n      catch (AggregateException ae) \n      {\n          foreach(var ex in ae.InnerExceptions)\n              Console.WriteLine(ex.Message + ex.StackTrace);\n      }\n      finally \n      {\n         cts.Dispose();\n      }\n      // You will need to press twice if you ran to the end:\n      // once for the cancellation thread, and once for this thread.\n      Console.WriteLine(\"Press any key.\");\n      Console.ReadKey(true);\n  }\n\n   class PipelineFilter<TInput, TOutput>\n   {\n      Func<TInput, TOutput> m_processor = null;\n      public BlockingCollection<TInput>[] m_input;\n      public BlockingCollection<TOutput>[] m_output = null;\n      Action<TInput> m_outputProcessor = null;\n      CancellationToken m_token;\n      public string Name { get; private set; }\n\n      public PipelineFilter(\n          BlockingCollection<TInput>[] input,\n          Func<TInput, TOutput> processor,\n          CancellationToken token,\n          string name)\n          {\n              m_input = input;\n              m_output = new BlockingCollection<TOutput>[5];\n              for (int i = 0; i < m_output.Length; i++)\n              {\n                    m_output[i] = new BlockingCollection<TOutput>(500);\n              }      \n              m_processor = processor;\n              m_token = token;\n              Name = name;\n            }\n\n      // Use this constructor for the final endpoint, which does\n      // something like write to file or screen, instead of\n      // pushing to another pipeline filter.\n      public PipelineFilter(\n          BlockingCollection<TInput>[] input,\n          Action<TInput> renderer,\n          CancellationToken token,\n          string name)\n          {\n              m_input = input;\n              m_outputProcessor = renderer;\n              m_token = token;\n              Name = name;\n          }\n\n      public void Run()\n      {\n          Console.WriteLine(\"{0} is running\", this.Name);\n          while (!m_input.All(bc => bc.IsCompleted) && !m_token.IsCancellationRequested)\n          {\n              TInput receivedItem;\n              int i = BlockingCollection<TInput>.TryTakeFromAny(\n                  m_input, out receivedItem, 50, m_token);\n              if ( i >= 0)\n              {\n                  if (m_output != null) // we pass data to another blocking collection\n                  {\n                      TOutput outputItem = m_processor(receivedItem);\n                      BlockingCollection<TOutput>.AddToAny(m_output, outputItem);\n                      Console.WriteLine(\"{0} sent {1} to next\", this.Name, outputItem);\n                  }\n                  else // we're an endpoint\n                  {\n                      m_outputProcessor(receivedItem);\n                  }\n              }\n              else\n              {\n                  Console.WriteLine(\"Unable to retrieve data from previous filter\");\n              }\n          }\n          if (m_output != null)\n          {\n              foreach (var bc in m_output) bc.CompleteAdding();\n          }\n      }\n   }\n}\n```\n\n## See Also\n\n[System.Collections.Concurrent](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)\n\n[Thread-Safe Collections](index.md)\n"}