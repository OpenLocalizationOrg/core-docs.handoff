{"nodes":[{"pos":[11,44],"content":"Generic Types (Generics) Overview","needQuote":true,"nodes":[{"content":"Generic Types (Generics) Overview","pos":[0,33]}]},{"pos":[58,91],"content":"Generic Types (Generics) Overview","needQuote":true,"nodes":[{"content":"Generic Types (Generics) Overview","pos":[0,33]}]},{"pos":[102,117],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":"Generic Types (Generics) Overview","pos":[322,355]},{"content":"We use generics all the time in C#, whether implicitly of explicitly.","pos":[357,426]},{"content":"When you use LINQ in C#, did you ever notice that you are working with IEnumerable<ph id=\"ph1\">&lt;T&gt;</ph>?","pos":[427,513],"source":" When you use LINQ in C#, did you ever notice that you are working with IEnumerable<T>?"},{"content":"Or if you ever saw an online sample of a “generic repository” for talking to databases using Entity Framework, did you see that most methods return IQueryable<ph id=\"ph1\">&lt;T&gt;</ph>?","pos":[514,676],"source":" Or if you ever saw an online sample of a “generic repository” for talking to databases using Entity Framework, did you see that most methods return IQueryable<T>?"},{"content":"You may have wondered what the <bpt id=\"p1\">**</bpt>T<ept id=\"p1\">**</ept> is in these examples and why is it in there?","pos":[677,758],"source":" You may have wondered what the **T** is in these examples and why is it in there?"},{"content":"First introduced to the .NET Framework 2.0, generics involved changes to both the C# language and the Common Language Runtime (CLR).","pos":[760,892]},{"content":"<bpt id=\"p1\">**</bpt>Generics<ept id=\"p1\">**</ept> are essentially a “code template” that allows developers to define <bpt id=\"p2\">[</bpt>type-safe<ept id=\"p2\">](https://msdn.microsoft.com/library/hbzz1a9a.aspx)</ept> data structures without committing to an actual data type.","pos":[893,1093],"source":"**Generics** are essentially a “code template” that allows developers to define [type-safe](https://msdn.microsoft.com/library/hbzz1a9a.aspx) data structures without committing to an actual data type."},{"content":"For example, <ph id=\"ph1\">`List&lt;T&gt;`</ph> is a <bpt id=\"p1\">[</bpt>Generic Collection<ept id=\"p1\">](https://msdn.microsoft.com/library/System.Collections.Generic.aspx)</ept> that can be declared and used with any type: <ph id=\"ph2\">`List&lt;int&gt;`</ph>, <ph id=\"ph3\">`List&lt;string&gt;`</ph>, <ph id=\"ph4\">`List&lt;Person&gt;`</ph>, etc.","pos":[1094,1305],"source":" For example, `List<T>` is a [Generic Collection](https://msdn.microsoft.com/library/System.Collections.Generic.aspx) that can be declared and used with any type: `List<int>`, `List<string>`, `List<Person>`, etc."},{"content":"So, what’s the point?","pos":[1307,1328]},{"content":"Why are generics useful?","pos":[1329,1353]},{"content":"In order to understand this, we need to take a look at a specific class before and after adding generics.","pos":[1354,1459]},{"content":"Let’s look at the <ph id=\"ph1\">`ArrayList`</ph>.","pos":[1460,1490],"source":" Let’s look at the `ArrayList`."},{"content":"In C# 1.0, the <ph id=\"ph1\">`ArrayList`</ph> elements were of type <ph id=\"ph2\">`object`</ph>.","pos":[1491,1549],"source":" In C# 1.0, the `ArrayList` elements were of type `object`."},{"content":"This meant that any element that was added was silently converted into an <ph id=\"ph1\">`object`</ph>; same thing happens on reading the elements from the list (this process is known as <bpt id=\"p1\">[</bpt>boxing<ept id=\"p1\">](https://msdn.microsoft.com/library/yz2be5wk.aspx)</ept> and unboxing respectively).","pos":[1550,1803],"source":" This meant that any element that was added was silently converted into an `object`; same thing happens on reading the elements from the list (this process is known as [boxing](https://msdn.microsoft.com/library/yz2be5wk.aspx) and unboxing respectively)."},{"content":"Boxing and unboxing have an impact of performance.","pos":[1804,1854]},{"content":"More than that, however, there is no way to tell at compile time what is the actual type of the data in the list.","pos":[1855,1968]},{"content":"This makes for some fragile code.","pos":[1969,2002]},{"content":"Generics solve this problem by providing additional information the type of data each instance of list will contain.","pos":[2003,2119]},{"content":"Put simply, you can only add integers to <ph id=\"ph1\">`List&lt;int&gt;`</ph> and only add Persons to <ph id=\"ph2\">`List&lt;Person&gt;`</ph>, etc.","pos":[2120,2217],"source":" Put simply, you can only add integers to `List<int>` and only add Persons to `List<Person>`, etc."},{"content":"Generics are also available at runtime, or <bpt id=\"p1\">**</bpt>reified<ept id=\"p1\">**</ept>.","pos":[2219,2274],"source":"Generics are also available at runtime, or **reified**."},{"content":"This means the runtime knows what type of data structure you are using and can store it in memory more efficiently.","pos":[2275,2390]},{"content":"Here is a small program that illustrates the efficiency of knowing the data structure type at runtime:","pos":[2392,2494]},{"content":"This program yields the following output:","pos":[3419,3460]},{"content":"The first thing you notice here is that sorting the generic list is significantly faster than for the non-generic list.","pos":[3631,3750]},{"content":"You might also notice that the type for the generic list is distinct ([System.Int32]) whereas the type for the non-generic list is generalized.","pos":[3751,3894]},{"content":"Because the runtime knows the generic <ph id=\"ph1\">`List&lt;int&gt;`</ph> is of type int, it can store the list elements in an underlying integer array in memory while the non-generic <ph id=\"ph2\">`ArrayList`</ph> has to cast each list element as an object as stored in an object array in memory.","pos":[3895,4149],"source":" Because the runtime knows the generic `List<int>` is of type int, it can store the list elements in an underlying integer array in memory while the non-generic `ArrayList` has to cast each list element as an object as stored in an object array in memory."},{"content":"As shown through this example, the extra castings take up time and slow down the list sort.","pos":[4150,4241]},{"content":"The last useful thing about the runtime knowing the type of your generic is a better debugging experience.","pos":[4243,4349]},{"content":"When you are debugging a generic in C#, you know what type each element is in your data structure.","pos":[4350,4448]},{"content":"Without generics, you would have no idea what type each element was.","pos":[4449,4517]},{"content":"Further reading and resources","pos":[4522,4551]},{"content":"An Introduction to C# Generics","pos":[4558,4588]},{"content":"C# Programming Guide - Generics","pos":[4645,4676]}],"content":"---\ntitle: Generic Types (Generics) Overview\ndescription: Generic Types (Generics) Overview\nkeywords: .NET, .NET Core\nauthor: kuhlenh\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: a315b111-8e48-446c-ab19-acb6405894a7\n---\n\n# Generic Types (Generics) Overview\n\nWe use generics all the time in C#, whether implicitly of explicitly. When you use LINQ in C#, did you ever notice that you are working with IEnumerable<T>? Or if you ever saw an online sample of a “generic repository” for talking to databases using Entity Framework, did you see that most methods return IQueryable<T>? You may have wondered what the **T** is in these examples and why is it in there?\n\nFirst introduced to the .NET Framework 2.0, generics involved changes to both the C# language and the Common Language Runtime (CLR). **Generics** are essentially a “code template” that allows developers to define [type-safe](https://msdn.microsoft.com/library/hbzz1a9a.aspx) data structures without committing to an actual data type. For example, `List<T>` is a [Generic Collection](https://msdn.microsoft.com/library/System.Collections.Generic.aspx) that can be declared and used with any type: `List<int>`, `List<string>`, `List<Person>`, etc.\n\nSo, what’s the point? Why are generics useful? In order to understand this, we need to take a look at a specific class before and after adding generics. Let’s look at the `ArrayList`. In C# 1.0, the `ArrayList` elements were of type `object`. This meant that any element that was added was silently converted into an `object`; same thing happens on reading the elements from the list (this process is known as [boxing](https://msdn.microsoft.com/library/yz2be5wk.aspx) and unboxing respectively). Boxing and unboxing have an impact of performance. More than that, however, there is no way to tell at compile time what is the actual type of the data in the list. This makes for some fragile code. Generics solve this problem by providing additional information the type of data each instance of list will contain. Put simply, you can only add integers to `List<int>` and only add Persons to `List<Person>`, etc.\n\nGenerics are also available at runtime, or **reified**. This means the runtime knows what type of data structure you are using and can store it in memory more efficiently.\n\nHere is a small program that illustrates the efficiency of knowing the data structure type at runtime:\n\n```cs\n  using System;\n  using System.Collections;\n  using System.Collections.Generic;\n  using System.Diagnostics;\n\n  namespace GenericsExample {\n    class Program {\n      static void Main(string[] args) {\n        //generic list\n        List<int> ListGeneric = new List<int> { 5, 9, 1, 4 };\n        //non-generic list\n        ArrayList ListNonGeneric = new ArrayList { 5, 9, 1, 4 };\n        // timer for generic list sort\n        Stopwatch s = Stopwatch.StartNew();\n        ListGeneric.Sort();\n        s.Stop();\n        Console.WriteLine($\"Generic Sort: {ListGeneric}  \\n Time taken: {s.Elapsed.TotalMilliseconds}ms\");\n\n        //timer for non-generic list sort\n        Stopwatch s2 = Stopwatch.StartNew();\n        ListNonGeneric.Sort();\n        s2.Stop();\n        Console.WriteLine($\"Non-Generic Sort: {ListNonGeneric}  \\n Time taken: {s2.Elapsed.TotalMilliseconds}ms\");\n        Console.ReadLine();\n      }\n    }\n  }\n\n```\n\nThis program yields the following output:\n\n```console\nGeneric Sort: System.Collections.Generic.List\\`1[System.Int32] Time taken: 0.0789ms\nNon-Generic Sort: System.Collections.ArrayList Time taken: 2.4324ms\n\n```\n\nThe first thing you notice here is that sorting the generic list is significantly faster than for the non-generic list. You might also notice that the type for the generic list is distinct ([System.Int32]) whereas the type for the non-generic list is generalized. Because the runtime knows the generic `List<int>` is of type int, it can store the list elements in an underlying integer array in memory while the non-generic `ArrayList` has to cast each list element as an object as stored in an object array in memory. As shown through this example, the extra castings take up time and slow down the list sort.\n\nThe last useful thing about the runtime knowing the type of your generic is a better debugging experience. When you are debugging a generic in C#, you know what type each element is in your data structure. Without generics, you would have no idea what type each element was.\n\n## Further reading and resources\n\n*   [An Introduction to C# Generics](https://msdn.microsoft.com/library/ms379564.aspx)\n*   [C# Programming Guide - Generics](https://msdn.microsoft.com/library/512aeb7t.aspx)\n"}