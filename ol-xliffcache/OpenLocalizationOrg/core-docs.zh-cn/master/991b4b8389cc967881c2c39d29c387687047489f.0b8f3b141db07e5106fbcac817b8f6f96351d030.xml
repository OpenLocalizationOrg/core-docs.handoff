{"nodes":[{"pos":[11,38],"content":"BlockingCollection Overview","needQuote":true,"nodes":[{"content":"BlockingCollection Overview","pos":[0,27]}]},{"pos":[52,79],"content":"BlockingCollection Overview","needQuote":true,"nodes":[{"content":"BlockingCollection Overview","pos":[0,27]}]},{"pos":[90,105],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":"BlockingCollection Overview","pos":[309,336]},{"pos":[338,534],"content":"<bpt id=\"p1\">[</bpt>BlockingCollection<ph id=\"ph1\">&amp;lt;</ph>T<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> is a thread-safe collection class that provides the following features:","source":"[BlockingCollection&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1) is a thread-safe collection class that provides the following features:"},{"content":"An implementation of the Producer-Consumer pattern.","pos":[540,591]},{"content":"Thread-safe addition and removal of items from a collection.","pos":[597,657]},{"content":"Optional maximum capacity.","pos":[663,689]},{"content":"Insertion and removal operations that block when collection is empty or full.","pos":[695,772]},{"content":"Insertion and removal \"try\" operations that do not block or that block up to a specified period of time.","pos":[778,882]},{"pos":[888,1080],"content":"Encapsulates any collection type that implements <bpt id=\"p1\">[</bpt>IProducerConsumerCollection<ph id=\"ph1\">&amp;lt;</ph>T<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept>.","source":"Encapsulates any collection type that implements [IProducerConsumerCollection&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)."},{"content":"Cancellation with cancellation tokens.","pos":[1086,1124]},{"pos":[1130,1170],"content":"Two kinds of enumeration with <ph id=\"ph1\">`foreach`</ph>:","source":"Two kinds of enumeration with `foreach`:"},{"content":"Read-only enumeration.","pos":[1180,1202]},{"content":"Enumeration that removes items as they are enumerated.","pos":[1215,1269]},{"content":"Bounding and Blocking Support","pos":[1278,1307]},{"content":"<bpt id=\"p1\">[</bpt>BlockingCollection<ph id=\"ph1\">&amp;lt;</ph>T<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> supports bounding and blocking.","pos":[1310,1466],"source":"[BlockingCollection&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1) supports bounding and blocking."},{"content":"Bounding means you can set the maximum capacity of the collection.","pos":[1467,1533]},{"content":"Bounding is important in certain scenarios because it enables you to control the maximum size of the collection in memory, and it prevents the producing threads from moving too far ahead of the consuming threads.","pos":[1534,1746]},{"content":"Multiple threads or tasks can add items to the collection concurrently, and if the collection reaches its specified maximum capacity, the producing threads will block until an item is removed.","pos":[1748,1940]},{"content":"Multiple consumers can remove items concurrently, and if the collection becomes empty, the consuming threads will block until a producer adds an item.","pos":[1941,2091]},{"content":"A producing thread can call <ph id=\"ph1\">`CompleteAdding`</ph> to indicate that no more items will be added.","pos":[2092,2182],"source":" A producing thread can call `CompleteAdding` to indicate that no more items will be added."},{"content":"Consumers monitor the <ph id=\"ph1\">`IsCompleted`</ph> property to know when the collection is empty and no more items will be added.","pos":[2183,2297],"source":" Consumers monitor the `IsCompleted` property to know when the collection is empty and no more items will be added."},{"content":"The following example shows a simple <ph id=\"ph1\">`BlockingCollection`</ph> with a bounded capacity of 100.","pos":[2298,2387],"source":" The following example shows a simple `BlockingCollection` with a bounded capacity of 100."},{"content":"A producer task adds items to the collection as long as some external condition is true, and then calls <ph id=\"ph1\">`CompleteAdding`</ph>.","pos":[2388,2509],"source":" A producer task adds items to the collection as long as some external condition is true, and then calls `CompleteAdding`."},{"content":"The consumer task takes items until the <ph id=\"ph1\">`IsCompleted`</ph> property is true.","pos":[2510,2581],"source":" The consumer task takes items until the `IsCompleted` property is true."},{"pos":[3801,3927],"content":"For a complete example, see <bpt id=\"p1\">[</bpt>How to: Add and Take Items Individually from a BlockingCollection<ept id=\"p1\">](how-to-add-and-take-items.md)</ept>.","source":"For a complete example, see [How to: Add and Take Items Individually from a BlockingCollection](how-to-add-and-take-items.md)."},{"content":"Timed Blocking Operations","pos":[3932,3957]},{"content":"In timed blocking <ph id=\"ph1\">`TryAdd`</ph> and <ph id=\"ph2\">`TryTake`</ph> operations on bounded collections, the method tries to add or take an item.","pos":[3959,4075],"source":"In timed blocking `TryAdd` and `TryTake` operations on bounded collections, the method tries to add or take an item."},{"content":"If an item is available it is placed into the variable that was passed in by reference, and the method returns <ph id=\"ph1\">`true`</ph>.","pos":[4076,4194],"source":" If an item is available it is placed into the variable that was passed in by reference, and the method returns `true`."},{"content":"If no item is retrieved after a specified time-out period the method returns <ph id=\"ph1\">`false`</ph>.","pos":[4195,4280],"source":" If no item is retrieved after a specified time-out period the method returns `false`."},{"content":"The thread is then free to do some other useful work before trying again to access the collection.","pos":[4281,4379]},{"content":"For an example of timed blocking access, see the second example in <bpt id=\"p1\">[</bpt>How to: Add and Take Items Individually from a BlockingCollection<ept id=\"p1\">](how-to-add-and-take-items.md)</ept>.","pos":[4380,4545],"source":" For an example of timed blocking access, see the second example in [How to: Add and Take Items Individually from a BlockingCollection](how-to-add-and-take-items.md)."},{"content":"Cancelling Add and Take Operations","pos":[4550,4584]},{"content":"Add and Take operations are typically performed in a loop.","pos":[4586,4644]},{"content":"You can cancel a loop by passing in a <ph id=\"ph1\">`CancellationToken`</ph> to the <ph id=\"ph2\">`TryAdd`</ph> or <ph id=\"ph3\">`TryTake`</ph> method, and then checking the value of the token's <ph id=\"ph4\">`IsCancellationRequested`</ph> property on each iteration.","pos":[4645,4836],"source":" You can cancel a loop by passing in a `CancellationToken` to the `TryAdd` or `TryTake` method, and then checking the value of the token's `IsCancellationRequested` property on each iteration."},{"content":"If the value is <ph id=\"ph1\">`true`</ph>, then it is up to you to respond the cancellation request by cleaning up any resources and exiting the loop.","pos":[4837,4968],"source":" If the value is `true`, then it is up to you to respond the cancellation request by cleaning up any resources and exiting the loop."},{"content":"The following example shows an overload of <ph id=\"ph1\">`TryAdd`</ph> that takes a cancellation token, and the code that uses it:","pos":[4969,5080],"source":" The following example shows an overload of `TryAdd` that takes a cancellation token, and the code that uses it:"},{"content":"Specifying the Collection Type","pos":[5200,5230]},{"content":"When you create a <ph id=\"ph1\">`BlockingCollection&lt;T&gt;;`</ph>, you can specify not only the bounded capacity but also the type of collection to use.","pos":[5232,5361],"source":"When you create a `BlockingCollection<T>;`, you can specify not only the bounded capacity but also the type of collection to use."},{"content":"For example, you could specify a <bpt id=\"p1\">[</bpt>ConcurrentQueue<ph id=\"ph1\">&amp;lt;</ph>T<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1)</ept> for first in-first out (FIFO) behavior, or a <bpt id=\"p2\">[</bpt>ConcurrentStack<ph id=\"ph3\">&amp;lt;</ph>T<ph id=\"ph4\">&amp;gt;</ph><ept id=\"p2\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1)</ept> for last in-first out (LIFO) behavior.","pos":[5362,5716],"source":" For example, you could specify a [ConcurrentQueue&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1) for first in-first out (FIFO) behavior, or a [ConcurrentStack&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1) for last in-first out (LIFO) behavior."},{"content":"You can use any collection class that implements the <bpt id=\"p1\">[</bpt>IProducerConsumerCollection<ph id=\"ph1\">&amp;lt;</ph>T<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept> interface.","pos":[5717,5923],"source":" You can use any collection class that implements the [IProducerConsumerCollection&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1) interface."},{"content":"The default collection type for <ph id=\"ph1\">`BlockingCollection&lt;T&gt;`</ph> is <ph id=\"ph2\">`ConcurrentQueue&lt;T&gt;`</ph>.","pos":[5924,6004],"source":" The default collection type for `BlockingCollection<T>` is `ConcurrentQueue<T>`."},{"content":"The following code example shows how to create a <ph id=\"ph1\">`BlockingCollection&lt;T&gt;`</ph> of strings that has a capacity of 1000 and uses a <bpt id=\"p1\">[</bpt>ConcurrentBag<ph id=\"ph2\">&amp;lt;</ph>T<ph id=\"ph3\">&amp;gt;</ph><ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1)</ept>:","pos":[6005,6243],"source":" The following code example shows how to create a `BlockingCollection<T>` of strings that has a capacity of 1000 and uses a [ConcurrentBag&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1):"},{"content":"IEnumerable Support","pos":[6363,6382]},{"content":"provides a <ph id=\"ph1\">`GetConsumingEnumerable`</ph> method that enables consumers to use a <ph id=\"ph2\">`foreach`</ph> statement to remove items until the collection is completed, which means it is empty and no more items will be added.","pos":[6408,6610],"source":" provides a `GetConsumingEnumerable` method that enables consumers to use a `foreach` statement to remove items until the collection is completed, which means it is empty and no more items will be added."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Use ForEach to Remove Items in a BlockingCollection<ept id=\"p1\">](how-to-use-foreach-to-remove.md)</ept>.","pos":[6611,6732],"source":" For more information, see [How to: Use ForEach to Remove Items in a BlockingCollection](how-to-use-foreach-to-remove.md)."},{"content":"Using Many BlockingCollections As One","pos":[6737,6774]},{"content":"For scenarios in which a consumer needs to take items from multiple collections simultaneously, you can create arrays of <ph id=\"ph1\">`BlockingCollection&lt;T&gt;`</ph> and use the static methods such as <ph id=\"ph2\">`TakeFromAny`</ph> and <ph id=\"ph3\">`AddToAny`</ph> that will add to or take from any of the collections in the array.","pos":[6776,7051],"source":"For scenarios in which a consumer needs to take items from multiple collections simultaneously, you can create arrays of `BlockingCollection<T>` and use the static methods such as `TakeFromAny` and `AddToAny` that will add to or take from any of the collections in the array."},{"content":"If one collection is blocking, the method immediately tries another until it finds one that can perform the operation.","pos":[7052,7170]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Use Arrays of Blocking Collections in a Pipeline<ept id=\"p1\">](how-to-use-arrays-of-blockingcollections.md)</ept>.","pos":[7171,7301],"source":" For more information, see [How to: Use Arrays of Blocking Collections in a Pipeline](how-to-use-arrays-of-blockingcollections.md)."},{"content":"See Also","pos":[7306,7314]},{"content":"System.Collections.Concurrent","pos":[7317,7346]},{"content":"Collections and Data Structures","pos":[7424,7455]},{"content":"Thread-Safe Collections","pos":[7472,7495]}],"content":"---\ntitle: BlockingCollection Overview\ndescription: BlockingCollection Overview\nkeywords: .NET, .NET Core\nauthor: mairaw\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: a1a867de-53c2-49ca-9a1a-e5770a942724\n---\n\n# BlockingCollection Overview\n\n[BlockingCollection&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1) is a thread-safe collection class that provides the following features:\n\n*   An implementation of the Producer-Consumer pattern.\n\n*   Thread-safe addition and removal of items from a collection.\n\n*   Optional maximum capacity.\n\n*   Insertion and removal operations that block when collection is empty or full.\n\n*   Insertion and removal \"try\" operations that do not block or that block up to a specified period of time.\n\n*   Encapsulates any collection type that implements [IProducerConsumerCollection&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1).\n\n*   Cancellation with cancellation tokens.\n\n*   Two kinds of enumeration with `foreach`: \n\n    1. Read-only enumeration.\n    \n    2. Enumeration that removes items as they are enumerated.\n    \n## Bounding and Blocking Support \n\n[BlockingCollection&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1) supports bounding and blocking. Bounding means you can set the maximum capacity of the collection. Bounding is important in certain scenarios because it enables you to control the maximum size of the collection in memory, and it prevents the producing threads from moving too far ahead of the consuming threads.\n\nMultiple threads or tasks can add items to the collection concurrently, and if the collection reaches its specified maximum capacity, the producing threads will block until an item is removed. Multiple consumers can remove items concurrently, and if the collection becomes empty, the consuming threads will block until a producer adds an item. A producing thread can call `CompleteAdding` to indicate that no more items will be added. Consumers monitor the `IsCompleted` property to know when the collection is empty and no more items will be added. The following example shows a simple `BlockingCollection` with a bounded capacity of 100. A producer task adds items to the collection as long as some external condition is true, and then calls `CompleteAdding`. The consumer task takes items until the `IsCompleted` property is true.\n\n```csharp\n// A bounded collection. It can hold no more \n// than 100 items at once.\nBlockingCollection<Data> dataItems = new BlockingCollection<Data>(100);\n\n\n// A simple blocking consumer with no cancellation.\nTask.Run(() => \n{\n    while (!dataItems.IsCompleted)\n    {\n\n        Data data = null;\n        // Blocks if number.Count == 0\n        // IOE means that Take() was called on a completed collection.\n        // Some other thread can call CompleteAdding after we pass the\n        // IsCompleted check but before we call Take. \n        // In this example, we can simply catch the exception since the \n        // loop will break on the next iteration.\n        try\n        {\n            data = dataItems.Take();\n        }\n        catch (InvalidOperationException) { }\n\n        if (data != null)\n        {\n            Process(data);\n        }\n    }\n    Console.WriteLine(\"\\r\\nNo more items to take.\");\n});\n\n// A simple blocking producer with no cancellation.\nTask.Run(() =>\n{\n    while (moreItemsToAdd)\n    {\n        Data data = GetData();\n        // Blocks if numbers.Count == dataItems.BoundedCapacity\n        dataItems.Add(data);\n    }\n    // Let consumer know we are done.\n    dataItems.CompleteAdding();\n});\n```\n\nFor a complete example, see [How to: Add and Take Items Individually from a BlockingCollection](how-to-add-and-take-items.md).\n\n## Timed Blocking Operations\n\nIn timed blocking `TryAdd` and `TryTake` operations on bounded collections, the method tries to add or take an item. If an item is available it is placed into the variable that was passed in by reference, and the method returns `true`. If no item is retrieved after a specified time-out period the method returns `false`. The thread is then free to do some other useful work before trying again to access the collection. For an example of timed blocking access, see the second example in [How to: Add and Take Items Individually from a BlockingCollection](how-to-add-and-take-items.md).\n\n## Cancelling Add and Take Operations\n\nAdd and Take operations are typically performed in a loop. You can cancel a loop by passing in a `CancellationToken` to the `TryAdd` or `TryTake` method, and then checking the value of the token's `IsCancellationRequested` property on each iteration. If the value is `true`, then it is up to you to respond the cancellation request by cleaning up any resources and exiting the loop. The following example shows an overload of `TryAdd` that takes a cancellation token, and the code that uses it:\n\n```csharp\nBlockingCollection<string> bc = new BlockingCollection<string>(new ConcurrentBag<string>(), 1000 );\n```\n\n## Specifying the Collection Type\n\nWhen you create a `BlockingCollection<T>;`, you can specify not only the bounded capacity but also the type of collection to use. For example, you could specify a [ConcurrentQueue&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1) for first in-first out (FIFO) behavior, or a [ConcurrentStack&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1) for last in-first out (LIFO) behavior. You can use any collection class that implements the [IProducerConsumerCollection&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1) interface. The default collection type for `BlockingCollection<T>` is `ConcurrentQueue<T>`. The following code example shows how to create a `BlockingCollection<T>` of strings that has a capacity of 1000 and uses a [ConcurrentBag&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1):\n\n```csharp\nBlockingCollection<string> bc = new BlockingCollection<string>(new ConcurrentBag<string>(), 1000 );\n```\n\n## IEnumerable Support\n\n`BlockingCollection<T>` provides a `GetConsumingEnumerable` method that enables consumers to use a `foreach` statement to remove items until the collection is completed, which means it is empty and no more items will be added. For more information, see [How to: Use ForEach to Remove Items in a BlockingCollection](how-to-use-foreach-to-remove.md).\n\n## Using Many BlockingCollections As One\n\nFor scenarios in which a consumer needs to take items from multiple collections simultaneously, you can create arrays of `BlockingCollection<T>` and use the static methods such as `TakeFromAny` and `AddToAny` that will add to or take from any of the collections in the array. If one collection is blocking, the method immediately tries another until it finds one that can perform the operation. For more information, see [How to: Use Arrays of Blocking Collections in a Pipeline](how-to-use-arrays-of-blockingcollections.md).\n\n## See Also\n\n[System.Collections.Concurrent](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)\n\n[Collections and Data Structures](../index.md)\n\n[Thread-Safe Collections](index.md)\n\n"}