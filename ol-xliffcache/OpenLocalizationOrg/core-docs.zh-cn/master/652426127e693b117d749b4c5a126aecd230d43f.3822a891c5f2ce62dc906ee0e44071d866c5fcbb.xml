{"nodes":[{"pos":[11,36],"content":"Building Expression Trees","needQuote":true,"nodes":[{"content":"Building Expression Trees","pos":[0,25]}]},{"pos":[50,75],"content":"Building Expression Trees","needQuote":true,"nodes":[{"content":"Building Expression Trees","pos":[0,25]}]},{"pos":[86,101],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":"Building Expression Trees","pos":[309,334]},{"content":"Previous -- Interpreting Expressions","pos":[337,373]},{"content":"All the expression trees you've seen so far have been created by the C# compiler.","pos":[410,491],"source":"All the expression trees you've seen so far have been created\nby the C# compiler."},{"content":"All you had to do was create a lambda expression that was assigned to a variable typed as an <ph id=\"ph1\">`Expression&lt;Func&lt;T&gt;&gt;`</ph> or some similar type.","pos":[492,628],"source":" All you had to do was create a lambda expression\nthat was assigned to a variable typed as an `Expression<Func<T>>` or\nsome similar type."},{"content":"That's not the only way to create an expression tree.","pos":[629,682],"source":" That's not the only way to create an expression\ntree."},{"content":"For many scenarios you may find that you need to build an expression in memory at runtime.","pos":[683,773],"source":" For many scenarios you may find that you need to build an\nexpression in memory at runtime."},{"content":"Building Expression Trees is complicated by the fact that those expression trees are immutable.","pos":[776,871],"source":"Building Expression Trees is complicated by the fact that those\nexpression trees are immutable."},{"content":"Being immutable means that you must build the tree from the leaves up to the root.","pos":[872,954],"source":" Being immutable means that you must\nbuild the tree from the leaves up to the root."},{"content":"The APIs you'll use to build expression trees reflect this fact: The methods you'll use to build a node take all its children as arguments.","pos":[955,1094],"source":" The APIs you'll use to\nbuild expression trees reflect this fact: The methods you'll use to\nbuild a node take all its children as arguments."},{"content":"Let's walk through a few examples to show you the techniques.","pos":[1095,1156],"source":" Let's walk through\na few examples to show you the techniques."},{"content":"Creating Nodes","pos":[1161,1175]},{"content":"Let's start relatively simply again.","pos":[1177,1213]},{"content":"We'll use the addition expression I've been working with throughout these sections:","pos":[1214,1297],"source":" We'll use the addition\nexpression I've been working with throughout these sections:"},{"content":"To construct that expression tree, you must construct the leaf nodes.","pos":[1351,1420]},{"content":"The leaf nodes are constants, so you can use the <ph id=\"ph1\">`Expression.Constant`</ph> method to create the nodes:","pos":[1421,1519],"source":"\nThe leaf nodes are constants, so you can use the `Expression.Constant`\nmethod to create the nodes:"},{"content":"Next, you'll build the addition expression:","pos":[1626,1669]},{"pos":[1723,1801],"content":"Once you've got the addition expression, you can create the lambda expression:","source":"Once you've got the addition expression, you can create the lambda\nexpression:"},{"content":"This is a very simple LambdaExpression, because it contains no arguments.","pos":[1856,1929]},{"content":"Later in this section, you'll see how to map arguments to parameters and build more complicated expressions.","pos":[1930,2038],"source":"\nLater in this section, you'll see how to map arguments to parameters\nand build more complicated expressions."},{"pos":[2040,2142],"content":"For expressions that are as simple as this one, you may combine all the calls into a single statement:","source":"For expressions that are as simple as this one, you may combine all the\ncalls into a single statement:"},{"content":"Building a Tree","pos":[2308,2323]},{"content":"That's the basics of building an expression tree in memory.","pos":[2325,2384]},{"content":"More complex trees generally mean more node types, and more nodes in the tree.","pos":[2385,2463],"source":" More\ncomplex trees generally mean more node types, and more nodes in the\ntree."},{"content":"Let's run through one more example and show two more node types that you will typically build when you create expression trees: the argument nodes, and method call nodes.","pos":[2464,2634],"source":" Let's run through one more example and show two more node types\nthat you will typically build when you create expression trees:\nthe argument nodes, and method call nodes."},{"content":"Let's build an expression tree to create this expression:","pos":[2636,2693]},{"pos":[2803,2866],"content":"You'll start by creating parameter expressions for <ph id=\"ph1\">`x`</ph> and <ph id=\"ph2\">`y`</ph>:","source":"You'll start by creating parameter expressions for `x` and `y`:"},{"pos":[2999,3092],"content":"Creating the multiplication and addition expressions follows the pattern you've already seen:","source":"Creating the multiplication and addition expressions follows the pattern\nyou've already seen:"},{"pos":[3271,3349],"content":"Next, you need to create a method call expression for the call to <ph id=\"ph1\">`Math.Sqrt`</ph>.","source":"Next, you need to create a method call expression for the call to\n`Math.Sqrt`."},{"pos":[3486,3618],"content":"And  then finally, you put the method call into a lambda expression, and make sure to define the arguments to the lambda expression:","source":"And  then finally, you put the method call into a lambda expression,\nand make sure to define the arguments to the lambda expression:"},{"pos":[3718,3837],"content":"In this more complicated example, you see a couple more techniques that you will often need to create expression trees.","source":"In this more complicated example, you see a couple more techniques that\nyou will often need to create expression trees."},{"content":"First, you need to create the objects that represent parameters or local variables before you use them.","pos":[3839,3942],"source":"First, you need to create the objects that represent parameters or\nlocal variables before you use them."},{"content":"Once you've created those objects, you can use them in your expression tree wherever you need.","pos":[3943,4037],"source":" Once you've created those objects,\nyou can use them in your expression tree wherever you need."},{"content":"Second, you need to use a subset of the Reflection APIs to create a <ph id=\"ph1\">`MethodInfo`</ph> object so that you can create an expression tree to access that method.","pos":[4039,4191],"source":"Second, you need to use a subset of the Reflection APIs to create a `MethodInfo` object\nso that you can create an expression tree to access that method."},{"content":"You must limit yourself to the subset of the Reflection APIs that are available on the .NET Core platform.","pos":[4192,4298],"source":" You must limit\nyourself to the subset of the Reflection APIs that are available on the .NET Core platform."},{"content":"Again, these techniques will extend to other expression trees.","pos":[4299,4361],"source":" Again,\nthese techniques will extend to other expression trees."},{"content":"Building Code In Depth","pos":[4366,4388]},{"content":"You aren't limited in what you can build using these APIs.","pos":[4390,4448]},{"content":"However, the more complicated expression tree that you want to build, the more difficult the code is to manage and to read.","pos":[4449,4572],"source":" However, the more\ncomplicated expression tree that you want to build, the more difficult\nthe code is to manage and to read."},{"content":"Let's build an expression tree that is the equivalent of this code:","pos":[4575,4642]},{"content":"Notice above that I did not build the expression tree, but simply the delegate.","pos":[4797,4876]},{"content":"Using the <ph id=\"ph1\">`Expression`</ph> class, you can't build statement lambdas.","pos":[4877,4941],"source":" Using\nthe `Expression` class, you can't build statement lambdas."},{"content":"Here's the code that is required to build the same functionality.","pos":[4942,5007],"source":" Here's the code that is required\nto build the same functionality."},{"content":"It's complicated by the fact that there isn't an API to build a <ph id=\"ph1\">`while`</ph> loop, instead you need to build a loop that contains a conditional test, and a label target to break out of the loop.","pos":[5008,5197],"source":" It's complicated by the fact that there isn't an API to build\na `while` loop, instead you need to build a loop that contains a conditional test, and a label\ntarget to break out of the loop."},{"pos":[6092,6315],"content":"The code to build the expression tree for the factorial function is quite a bit longer, more complicated, and it's riddled with labels and break statements and other elements we'd like to avoid in our everyday coding tasks.","source":"The code to build the expression tree for the factorial function is quite a bit longer,\nmore complicated, and it's riddled with labels and break statements and other elements\nwe'd like to avoid in our everyday coding tasks."},{"content":"For this section, I've also updated the visitor code to visit every node in this expression tree and write out information about the nodes that are created in this sample.","pos":[6318,6489],"source":"For this section, I've also updated the visitor code to visit every node in this expression\ntree and write out information about the nodes that are created in this sample."},{"content":"You can see the code in <bpt id=\"p1\">[</bpt>the samples section<ept id=\"p1\">](https://github.com/dotnet/core-docs/tree/master/samples/csharp-language/expression-trees)</ept>.","pos":[6490,6626],"source":" You can see\nthe code in [the samples section](https://github.com/dotnet/core-docs/tree/master/samples/csharp-language/expression-trees)."},{"content":"You can experiment for yourself: build it and run the samples.","pos":[6627,6689],"source":"\nYou can experiment for yourself: build it and run the samples."},{"content":"Examining the APIs","pos":[6694,6712]},{"content":"The expression tree APIs are some of the more difficult to navigate in .NET Core, but that's fine.","pos":[6714,6812],"source":"The expression tree APIs are some of the more difficult to navigate in\n.NET Core, but that's fine."},{"content":"Their purpose is a rather complex undertaking: writing code that generates code at runtime.","pos":[6813,6904],"source":" Their purpose is a rather complex undertaking: writing code that generates\ncode at runtime."},{"content":"They are necessarily complicated to provide a balance between supporting all the control structures available in the C# language and keeping the surface area of the APIs as small as reasonable.","pos":[6905,7098],"source":" They are necessarily complicated to provide a balance between supporting\nall the control structures available in the C# language and keeping the surface area\nof the APIs as small as reasonable."},{"content":"This balance means that many control structures are represented not by their C# constructs, but by constructs that represent the underlying logic that the compiler generates from these higher level constructs.","pos":[7099,7308],"source":" This balance means that many control structures are\nrepresented not by their C# constructs, but by constructs that represent the underlying\nlogic that the compiler generates from these higher level constructs."},{"content":"Also, at this time, there are C# expressions that cannot be built directly using <ph id=\"ph1\">`Expression`</ph> class methods.","pos":[7311,7419],"source":"Also, at this time, there are C# expressions that cannot be built directly\nusing `Expression` class methods."},{"content":"In general, these will be the newest operators and expressions added in C# 5 and C# 6.","pos":[7420,7506],"source":" In general, these will be the newest operators\nand expressions added in C# 5 and C# 6."},{"content":"(For example, <ph id=\"ph1\">`async`</ph> expressions cannot be built, and the new <ph id=\"ph2\">`?.`</ph> operator cannot be directly created.)","pos":[7507,7612],"source":" (For example, `async` expressions cannot be built, and\nthe new `?.` operator cannot be directly created.)"},{"content":"Next -- Translating Expressions","pos":[7615,7646]}],"content":"---\ntitle: Building Expression Trees\ndescription: Building Expression Trees\nkeywords: .NET, .NET Core\nauthor: BillWagner\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: 542754a9-7f40-4293-b299-b9f80241902c\n---\n\n# Building Expression Trees\n\n[Previous -- Interpreting Expressions](expression-trees-interpreting.md)\n\nAll the expression trees you've seen so far have been created\nby the C# compiler. All you had to do was create a lambda expression\nthat was assigned to a variable typed as an `Expression<Func<T>>` or\nsome similar type. That's not the only way to create an expression\ntree. For many scenarios you may find that you need to build an\nexpression in memory at runtime. \n\nBuilding Expression Trees is complicated by the fact that those\nexpression trees are immutable. Being immutable means that you must\nbuild the tree from the leaves up to the root. The APIs you'll use to\nbuild expression trees reflect this fact: The methods you'll use to\nbuild a node take all its children as arguments. Let's walk through\na few examples to show you the techniques.\n\n## Creating Nodes\n\nLet's start relatively simply again. We'll use the addition\nexpression I've been working with throughout these sections:\n\n```cs\nExpression<Func<int>> sum = () => 1 + 2;\n```\n\nTo construct that expression tree, you must construct the leaf nodes.\nThe leaf nodes are constants, so you can use the `Expression.Constant`\nmethod to create the nodes:\n\n```cs\nvar one = Expression.Constant(1, typeof(int));\nvar two = Expression.Constant(2, typeof(int));\n```\n\nNext, you'll build the addition expression:\n\n```cs\nvar addition = Expression.Add(one, two);\n```\n\nOnce you've got the addition expression, you can create the lambda\nexpression:\n\n```cs\nvar lamdba = Expression.Lambda(addition);\n```\n\nThis is a very simple LambdaExpression, because it contains no arguments.\nLater in this section, you'll see how to map arguments to parameters\nand build more complicated expressions.\n\nFor expressions that are as simple as this one, you may combine all the\ncalls into a single statement:\n\n```cs\nvar lambda = Expression.Lambda(\n    Expression.Add(\n        Expression.Constant(1, typeof(int)),\n        Expression.Constant(2, typeof(int))\n    )\n);\n```\n\n## Building a Tree\n\nThat's the basics of building an expression tree in memory. More\ncomplex trees generally mean more node types, and more nodes in the\ntree. Let's run through one more example and show two more node types\nthat you will typically build when you create expression trees:\nthe argument nodes, and method call nodes.\n\nLet's build an expression tree to create this expression:\n\n```cs\nExpression<Func<double, double, double>> distanceCalc =\n    (x, y) => Math.Sqrt(x * x + y * y);\n```\n \nYou'll start by creating parameter expressions for `x` and `y`:\n\n```cs\nvar xParameter = Expression.Parameter(typeof(double), \"x\");\nvar yParameter = Expression.Parameter(typeof(double), \"y\");\n```\n\nCreating the multiplication and addition expressions follows the pattern\nyou've already seen:\n\n```cs\nvar xSquared = Expression.Multiply(xParameter, xParameter);\nvar ySquared = Expression.Multiply(yParameter, yParameter);\nvar sum = Expression.Add(xSquared, ySquared);\n```\n\nNext, you need to create a method call expression for the call to\n`Math.Sqrt`.\n\n```cs\nvar sqrtMethod = typeof(Math).GetMethod(\"Sqrt\", new[] { typeof(double) });\nvar distance = Expression.Call(sqrtMethod, sum);\n```\n\nAnd  then finally, you put the method call into a lambda expression,\nand make sure to define the arguments to the lambda expression:\n\n```cs\nvar distanceLambda = Expression.Lambda(\n    distance,\n    xParameter,\n    yParameter);\n```\n\nIn this more complicated example, you see a couple more techniques that\nyou will often need to create expression trees.\n\nFirst, you need to create the objects that represent parameters or\nlocal variables before you use them. Once you've created those objects,\nyou can use them in your expression tree wherever you need.\n\nSecond, you need to use a subset of the Reflection APIs to create a `MethodInfo` object\nso that you can create an expression tree to access that method. You must limit\nyourself to the subset of the Reflection APIs that are available on the .NET Core platform. Again,\nthese techniques will extend to other expression trees.\n\n## Building Code In Depth\n\nYou aren't limited in what you can build using these APIs. However, the more\ncomplicated expression tree that you want to build, the more difficult\nthe code is to manage and to read. \n\nLet's build an expression tree that is the equivalent of this code:\n\n```cs\nFunc<int, int> factorialFunc = (n) =>\n{\n    var res = 1;\n    while (n > 1)\n    {\n        res = res * n;\n        n--;\n    }\n    return res;\n};\n```\n\nNotice above that I did not build the expression tree, but simply the delegate. Using\nthe `Expression` class, you can't build statement lambdas. Here's the code that is required\nto build the same functionality. It's complicated by the fact that there isn't an API to build\na `while` loop, instead you need to build a loop that contains a conditional test, and a label\ntarget to break out of the loop. \n\n```cs\nvar nArgument = Expression.Parameter(typeof(int), \"n\");\nvar result = Expression.Variable(typeof(int), \"result\");\n\n// Creating a label that represents the return value\nLabelTarget label = Expression.Label(typeof(int));\n\nvar initializeResult = Expression.Assign(result, Expression.Constant(1));\n\n// This is the inner block that performs the multiplication,\n// and decrements the value of 'n'\nvar block = Expression.Block(\n    Expression.Assign(result,\n        Expression.Multiply(result, nArgument)),\n    Expression.PostDecrementAssign(nArgument)\n);\n\n// Creating a method body.\nBlockExpression body = Expression.Block(\n    new[] { result },\n    initializeResult,\n    Expression.Loop(\n        Expression.IfThenElse(\n            Expression.GreaterThan(nArgument, Expression.Constant(1)),\n            block,\n            Expression.Break(label, result)\n        ),\n        label\n    )\n);\n```\n\nThe code to build the expression tree for the factorial function is quite a bit longer,\nmore complicated, and it's riddled with labels and break statements and other elements\nwe'd like to avoid in our everyday coding tasks. \n\nFor this section, I've also updated the visitor code to visit every node in this expression\ntree and write out information about the nodes that are created in this sample. You can see\nthe code in [the samples section](https://github.com/dotnet/core-docs/tree/master/samples/csharp-language/expression-trees).\nYou can experiment for yourself: build it and run the samples.\n\n## Examining the APIs\n\nThe expression tree APIs are some of the more difficult to navigate in\n.NET Core, but that's fine. Their purpose is a rather complex undertaking: writing code that generates\ncode at runtime. They are necessarily complicated to provide a balance between supporting\nall the control structures available in the C# language and keeping the surface area\nof the APIs as small as reasonable. This balance means that many control structures are\nrepresented not by their C# constructs, but by constructs that represent the underlying\nlogic that the compiler generates from these higher level constructs. \n\nAlso, at this time, there are C# expressions that cannot be built directly\nusing `Expression` class methods. In general, these will be the newest operators\nand expressions added in C# 5 and C# 6. (For example, `async` expressions cannot be built, and\nthe new `?.` operator cannot be directly created.)\n\n[Next -- Translating Expressions](expression-trees-translating.md)\n"}