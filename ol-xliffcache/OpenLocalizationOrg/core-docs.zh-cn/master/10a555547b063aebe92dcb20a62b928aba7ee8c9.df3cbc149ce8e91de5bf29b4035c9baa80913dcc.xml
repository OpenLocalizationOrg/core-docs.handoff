{"nodes":[{"pos":[11,45],"content":"Distinguising Delegates and Events","needQuote":true,"nodes":[{"content":"Distinguising Delegates and Events","pos":[0,34]}]},{"pos":[59,93],"content":"Distinguising Delegates and Events","needQuote":true,"nodes":[{"content":"Distinguising Delegates and Events","pos":[0,34]}]},{"pos":[104,119],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":"Distinguising Delegates and Events","pos":[327,361]},{"content":"Previous","pos":[364,372]},{"content":"Developers that are new to the .NET Core platform often struggle when deciding between a design based on <ph id=\"ph1\">`delegates`</ph> and a design based on <ph id=\"ph2\">`events`</ph>.","pos":[393,541],"source":"Developers that are new to the .NET Core platform often struggle\nwhen deciding between a design based on `delegates` and a design\nbased on `events`."},{"content":"This is a difficult concept, because the two language features are very similar.","pos":[542,622],"source":" This is a difficult concept, because the two\nlanguage features are very similar."},{"content":"Events are even built using the language support for delegates.","pos":[623,686],"source":" Events are even built using\nthe language support for delegates."},{"content":"They both offer a late binding scenario: they enable scenarios where a component communicates by calling a method that is only known at runtime.","pos":[689,833],"source":"They both offer a late binding scenario: they enable scenarios\nwhere a component communicates by calling a method that is only\nknown at runtime."},{"content":"They both support single and multiple subscriber methods.","pos":[834,891],"source":" They both support single and multiple subscriber\nmethods."},{"content":"You may find this referred to as singlecast and multicast support.","pos":[892,958],"source":" You may find this referred to as singlecast and multicast\nsupport."},{"content":"They both support similar syntax for adding and removing handlers.","pos":[959,1025],"source":" They both support similar syntax for adding and removing\nhandlers."},{"content":"Finally, raising an event and calling a delegate use exactly the same method call syntax.","pos":[1026,1115]},{"content":"They even both support the same <ph id=\"ph1\">`Invoke()`</ph> method syntax for use with the <ph id=\"ph2\">`?.`</ph> operator.","pos":[1116,1204],"source":" They even both support the same `Invoke()`\nmethod syntax for use with the `?.` operator."},{"pos":[1206,1292],"content":"With all those similarities, it is easy to have trouble determining when to use which.","source":"With all those similarities, it is easy to have trouble determining when\nto use which."},{"content":"Listening to Events is Optional","pos":[1297,1328]},{"content":"The most important consideration in determining which language feature to use is whether or not there must be an attached subscriber.","pos":[1330,1463],"source":"The most important consideration in determining which language feature\nto use is whether or not there must be an attached subscriber."},{"content":"If your code must call the code supplied by the subscriber, you should use a design based on delegates.","pos":[1464,1567],"source":" If your\ncode must call the code supplied by the subscriber, you should\nuse a design based on delegates."},{"content":"If your code can complete all its work without calling any subscribers, you should use a design based on events.","pos":[1568,1680],"source":" If your code can complete all its\nwork without calling any subscribers, you should use a\ndesign based on events."},{"content":"Consider the examples built during this section.","pos":[1683,1731]},{"content":"The code you built using <ph id=\"ph1\">`List.Sort()`</ph> must be given a comparer function in order to properly sort the elements.","pos":[1732,1844],"source":" The code you built\nusing `List.Sort()` must be given a comparer function in order to\nproperly sort the elements."},{"content":"LINQ queries must be supplied with delegates in order to determine what elements to return.","pos":[1845,1936],"source":" LINQ queries must be supplied with delegates\nin order to determine what elements to return."},{"content":"Both used a design built with delegates.","pos":[1937,1977],"source":" Both used a design built\nwith delegates."},{"content":"Consider the <ph id=\"ph1\">`OnProgress`</ph> event handler.","pos":[1979,2019],"source":"Consider the `OnProgress` event handler."},{"content":"It reports progress on a task.","pos":[2020,2050]},{"content":"The task continues to proceed whether or not there are any listeners.","pos":[2051,2120],"source":"\nThe task continues to proceed whether or not there are any listeners."},{"content":"The <ph id=\"ph1\">`FileSearcher`</ph> is another example.","pos":[2121,2159],"source":"\nThe `FileSearcher` is another example."},{"content":"It would still search and find all the files that were sought, even with no event subscribers attached.","pos":[2160,2263],"source":" It would still search and find\nall the files that were sought, even with no event subscribers attached."},{"content":"UX controls still work correctly, even when there are no subscribers listening to the events.","pos":[2264,2357],"source":"\nUX controls still work correctly, even when there are no subscribers\nlistening to the events."},{"content":"They both use designs based on events.","pos":[2358,2396]},{"content":"Return Values Require Delegates","pos":[2401,2432]},{"content":"Another consideration is the method prototype you would want for your delegate method.","pos":[2434,2520],"source":"Another consideration is the method prototype you would want for your\ndelegate method."},{"content":"As you've seen, the delegates used for events all have a void return type.","pos":[2521,2595],"source":" As you've seen, the delegates used for events all\nhave a void return type."},{"content":"You've also seen that there are idioms to create event handlers that do pass information back to event sources through modifying properties of the event argument object.","pos":[2596,2765],"source":" You've also seen that there are idioms to\ncreate event handlers that do pass information back to event sources\nthrough modifying properties of the event argument object."},{"content":"While these idioms do work, they are not as natural as returning a value from a method.","pos":[2766,2853],"source":" While these\nidioms do work, they are not as natural as returning a value from a\nmethod."},{"pos":[2855,3004],"content":"Notice that these two heuristics may often both be present: If your delegate method returns a value, it will likely impact the algorithm in some way.","source":"Notice that these two heuristics may often both be present: If your\ndelegate method returns a value, it will likely impact the algorithm\nin some way."},{"content":"Event Listeners Often Have Longer Lifetimes","pos":[3009,3052]},{"content":"This is a slightly weaker justification.","pos":[3055,3095]},{"content":"However, you may find that event-based designs are more natural when the event source will be raising events over a long period of time.","pos":[3096,3232],"source":" However, you may find that\nevent-based designs are more natural when the event source will be\nraising events over a long period of time."},{"content":"You can see examples of this for UX controls on many systems.","pos":[3233,3294],"source":" You can see examples of\nthis for UX controls on many systems."},{"content":"Once you subscribe to an event, the event source may raise events throughout the lifetime of the program.","pos":[3295,3400],"source":" Once you subscribe to an event,\nthe event source may raise events throughout the lifetime of the program."},{"content":"(You can unsubscribe from events when you no longer need them.)","pos":[3401,3464],"source":"\n(You can unsubscribe from events when you no longer need them.)"},{"pos":[3466,3622],"content":"Contrast that with many delegate-based designs, where a delegate is used as an argument to a method, and the delegate is not used after that method returns.","source":"Contrast that with many delegate-based designs, where a delegate is\nused as an argument to a method, and the delegate is not used after that\nmethod returns."},{"content":"Evaluate Carefully","pos":[3627,3645]},{"content":"The above considerations are not hard and fast rules.","pos":[3647,3700]},{"content":"Instead, they represent guidance that can help you decide which choice is best for your particular usage.","pos":[3701,3806],"source":" Instead, they\nrepresent guidance that can help you decide which choice is best for\nyour particular usage."},{"content":"Because they are similar, you can even prototype both, and consider which would be more natural to work with.","pos":[3807,3916],"source":" Because they are similar, you can even\nprototype both, and consider which would be more natural to work\nwith."},{"content":"They both handle late binding scenarios well.","pos":[3917,3962]},{"content":"Use the one that communicates your design the best.","pos":[3963,4014],"source":" Use the one\nthat communicates your design the best."}],"content":"---\ntitle: Distinguising Delegates and Events\ndescription: Distinguising Delegates and Events\nkeywords: .NET, .NET Core\nauthor: BillWagner\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: 0fdc8629-2fdb-4a7c-a433-5b9d04eaf911\n---\n\n# Distinguising Delegates and Events\n\n[Previous](modern-events.md)\n\nDevelopers that are new to the .NET Core platform often struggle\nwhen deciding between a design based on `delegates` and a design\nbased on `events`. This is a difficult concept, because the two\nlanguage features are very similar. Events are even built using\nthe language support for delegates. \n\nThey both offer a late binding scenario: they enable scenarios\nwhere a component communicates by calling a method that is only\nknown at runtime. They both support single and multiple subscriber\nmethods. You may find this referred to as singlecast and multicast\nsupport. They both support similar syntax for adding and removing\nhandlers. Finally, raising an event and calling a delegate use exactly the same method call syntax. They even both support the same `Invoke()`\nmethod syntax for use with the `?.` operator.\n\nWith all those similarities, it is easy to have trouble determining when\nto use which.\n\n## Listening to Events is Optional\n\nThe most important consideration in determining which language feature\nto use is whether or not there must be an attached subscriber. If your\ncode must call the code supplied by the subscriber, you should\nuse a design based on delegates. If your code can complete all its\nwork without calling any subscribers, you should use a\ndesign based on events. \n\nConsider the examples built during this section. The code you built\nusing `List.Sort()` must be given a comparer function in order to\nproperly sort the elements. LINQ queries must be supplied with delegates\nin order to determine what elements to return. Both used a design built\nwith delegates.\n\nConsider the `OnProgress` event handler. It reports progress on a task.\nThe task continues to proceed whether or not there are any listeners.\nThe `FileSearcher` is another example. It would still search and find\nall the files that were sought, even with no event subscribers attached.\nUX controls still work correctly, even when there are no subscribers\nlistening to the events. They both use designs based on events.\n\n## Return Values Require Delegates\n\nAnother consideration is the method prototype you would want for your\ndelegate method. As you've seen, the delegates used for events all\nhave a void return type. You've also seen that there are idioms to\ncreate event handlers that do pass information back to event sources\nthrough modifying properties of the event argument object. While these\nidioms do work, they are not as natural as returning a value from a\nmethod.\n\nNotice that these two heuristics may often both be present: If your\ndelegate method returns a value, it will likely impact the algorithm\nin some way.\n\n## Event Listeners Often Have Longer Lifetimes \n\nThis is a slightly weaker justification. However, you may find that\nevent-based designs are more natural when the event source will be\nraising events over a long period of time. You can see examples of\nthis for UX controls on many systems. Once you subscribe to an event,\nthe event source may raise events throughout the lifetime of the program.\n(You can unsubscribe from events when you no longer need them.)\n\nContrast that with many delegate-based designs, where a delegate is\nused as an argument to a method, and the delegate is not used after that\nmethod returns.\n\n## Evaluate Carefully\n\nThe above considerations are not hard and fast rules. Instead, they\nrepresent guidance that can help you decide which choice is best for\nyour particular usage. Because they are similar, you can even\nprototype both, and consider which would be more natural to work\nwith. They both handle late binding scenarios well. Use the one\nthat communicates your design the best.\n"}