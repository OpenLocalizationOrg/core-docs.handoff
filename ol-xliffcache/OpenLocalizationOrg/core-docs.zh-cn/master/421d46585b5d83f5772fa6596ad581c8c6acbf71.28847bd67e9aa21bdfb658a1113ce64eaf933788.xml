{"nodes":[{"pos":[11,34],"content":"Thread-Safe Collections","needQuote":true,"nodes":[{"content":"Thread-Safe Collections","pos":[0,23]}]},{"pos":[48,71],"content":"Thread-Safe Collections","needQuote":true,"nodes":[{"content":"Thread-Safe Collections","pos":[0,23]}]},{"pos":[82,97],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":"Thread-Safe Collections","pos":[301,324]},{"content":"The <bpt id=\"p1\">[</bpt>System.Collections.Concurrent<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)</ept> namespace includes several collection classes that are both thread-safe and scalable.","pos":[326,521],"source":"The [System.Collections.Concurrent](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent) namespace includes several collection classes that are both thread-safe and scalable."},{"content":"Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code.","pos":[522,668]},{"content":"When you write new code, use the concurrent collection classes whenever the collection will be writing to multiple threads concurrently.","pos":[669,805]},{"content":"If you are only reading from a shared collection, then you can use the classes in the <bpt id=\"p1\">[</bpt>System.Collections.Generic<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic)</ept> namespace.","pos":[806,1002],"source":" If you are only reading from a shared collection, then you can use the classes in the [System.Collections.Generic](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic) namespace."},{"content":"We recommend that you do not use <bpt id=\"p1\">[</bpt>System.Collections<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections)</ept> collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime.","pos":[1003,1215],"source":" We recommend that you do not use [System.Collections](https://docs.microsoft.com/dotnet/core/api/System.Collections) collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime."},{"content":"Fine-Grained Locking and Lock-Free Mechanisms","pos":[1220,1265]},{"content":"Some of the concurrent collection types use lightweight synchronization mechanisms such as <bpt id=\"p1\">[</bpt>SpinLock<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Threading.SpinLock)</ept>, <bpt id=\"p2\">[</bpt>SpinWait<ept id=\"p2\">](https://docs.microsoft.com/dotnet/core/api/System.Threading.SpinWait)</ept>, <bpt id=\"p3\">[</bpt>SemaphoreSlim<ept id=\"p3\">](https://docs.microsoft.com/dotnet/core/api/System.Threading.SemaphoreSlim)</ept>, and <bpt id=\"p4\">[</bpt>CountdownEvent<ept id=\"p4\">](https://docs.microsoft.com/dotnet/core/api/System.Threading.CountdownEvent)</ept>.","pos":[1267,1711],"source":"Some of the concurrent collection types use lightweight synchronization mechanisms such as [SpinLock](https://docs.microsoft.com/dotnet/core/api/System.Threading.SpinLock), [SpinWait](https://docs.microsoft.com/dotnet/core/api/System.Threading.SpinWait), [SemaphoreSlim](https://docs.microsoft.com/dotnet/core/api/System.Threading.SemaphoreSlim), and [CountdownEvent](https://docs.microsoft.com/dotnet/core/api/System.Threading.CountdownEvent)."},{"content":"These synchronization types typically use busy spinning for brief periods before they put the thread into a true <ph id=\"ph1\">`Wait`</ph> state.","pos":[1712,1838],"source":" These synchronization types typically use busy spinning for brief periods before they put the thread into a true `Wait` state."},{"content":"When wait times are expected to be very short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition.","pos":[1839,1993]},{"content":"For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a very high rate.","pos":[1994,2125]},{"content":"The <bpt id=\"p1\">[</bpt>ConcurrentQueue<ph id=\"ph1\">&amp;lt;</ph>T<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1)</ept> and <bpt id=\"p2\">[</bpt>ConcurrentStack<ph id=\"ph3\">&amp;lt;</ph>T<ph id=\"ph4\">&amp;gt;</ph><ept id=\"p2\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1)</ept> classes do not use locks at all.","pos":[2127,2405],"source":"The [ConcurrentQueue&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1) and [ConcurrentStack&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1) classes do not use locks at all."},{"content":"Instead, they rely on Interlocked operations to achieve thread-safety.","pos":[2406,2476]},{"pos":[2480,2827],"content":"[!NOTE]\nBecause the concurrent collections classes support [ICollection](https://docs.microsoft.com/dotnet/core/api/System.Collections.ICollection), they provide implementations for the `IsSynchronized` and `SyncRoot` properties, even though these properties are irrelevant. `IsSynchronized` always returns `false` and `SyncRoot` is always null.","leadings":["","> "],"nodes":[{"content":"Because the concurrent collections classes support [ICollection](https://docs.microsoft.com/dotnet/core/api/System.Collections.ICollection), they provide implementations for the `IsSynchronized` and `SyncRoot` properties, even though these properties are irrelevant. `IsSynchronized` always returns `false` and `SyncRoot` is always null.","pos":[8,345],"nodes":[{"content":"Because the concurrent collections classes support <bpt id=\"p1\">[</bpt>ICollection<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.ICollection)</ept>, they provide implementations for the <ph id=\"ph1\">`IsSynchronized`</ph> and <ph id=\"ph2\">`SyncRoot`</ph> properties, even though these properties are irrelevant.","pos":[0,266],"source":"Because the concurrent collections classes support [ICollection](https://docs.microsoft.com/dotnet/core/api/System.Collections.ICollection), they provide implementations for the `IsSynchronized` and `SyncRoot` properties, even though these properties are irrelevant."},{"content":"always returns <ph id=\"ph1\">`false`</ph> and <ph id=\"ph2\">`SyncRoot`</ph> is always null.","pos":[284,337],"source":" always returns `false` and `SyncRoot` is always null."}]}]},{"pos":[2829,2999],"content":"The following table lists the collection types in the <bpt id=\"p1\">[</bpt>System.Collections.Concurrent<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)</ept> namespace.","source":"The following table lists the collection types in the [System.Collections.Concurrent](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent) namespace."},{"content":"Type","pos":[3001,3005]},{"content":"Description","pos":[3008,3019]},{"content":"BlockingCollection<ph id=\"ph1\">&amp;lt;</ph>T","pos":[3040,3063],"source":"BlockingCollection&lt;T"},{"content":"Provides bounding and blocking functionality for any type that implements <bpt id=\"p1\">[</bpt>IProducerConsumerCollection<ph id=\"ph1\">&amp;lt;</ph>T<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)</ept>.","pos":[3166,3383],"source":"Provides bounding and blocking functionality for any type that implements [IProducerConsumerCollection&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1)."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>BlockingCollection Overview<ept id=\"p1\">](blockingcollection-overview.md)</ept>.","pos":[3384,3472],"source":" For more information, see [BlockingCollection Overview](blockingcollection-overview.md)."},{"content":"ConcurrentBag<ph id=\"ph1\">&amp;lt;</ph>T","pos":[3474,3492],"source":"ConcurrentBag&lt;T"},{"content":"Thread-safe implementation of an unordered collection of elements.","pos":[3590,3656]},{"content":"ConcurrentDictionary<ph id=\"ph1\">&amp;lt;</ph>TKey, TValue","pos":[3658,3694],"source":"ConcurrentDictionary&lt;TKey, TValue"},{"content":"Thread-safe implementation of a dictionary of key-value pairs.","pos":[3799,3861]},{"content":"ConcurrentQueue<ph id=\"ph1\">&amp;lt;</ph>T","pos":[3863,3883],"source":"ConcurrentQueue&lt;T"},{"content":"Thread-safe implementation of a FIFO (first-in, first-out) queue.","pos":[3983,4048]},{"content":"ConcurrentStack<ph id=\"ph1\">&amp;lt;</ph>T","pos":[4050,4070],"source":"ConcurrentStack&lt;T"},{"content":"Thread-safe implementation of a LIFO (last-in, first-out) stack.","pos":[4170,4234]},{"content":"IProducerConsumerCollection<ph id=\"ph1\">&amp;lt;</ph>T","pos":[4236,4268],"source":"IProducerConsumerCollection&lt;T"},{"pos":[4380,4458],"content":"The interface that a type must implement to be used in a <ph id=\"ph1\">`BlockingCollection`</ph>.","source":"The interface that a type must implement to be used in a `BlockingCollection`."},{"content":"Thread Synchronization in the .NET Framework version 1.0 and 2.0 Collections","pos":[4463,4539]},{"content":"The collections first introduced in the .NET Framework version 1.0 are found in the <bpt id=\"p1\">[</bpt>System.Collections<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections)</ept> namespace.","pos":[4541,4719],"source":"The collections first introduced in the .NET Framework version 1.0 are found in the [System.Collections](https://docs.microsoft.com/dotnet/core/api/System.Collections) namespace."},{"content":"These collections, which include the commonly used <bpt id=\"p1\">[</bpt>ArrayList<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.ArrayList)</ept> and <bpt id=\"p2\">[</bpt>Hashtable<ept id=\"p2\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Hashtable)</ept>, provide some thread-safety through the <ph id=\"ph1\">`Synchronized`</ph> property, which returns a thread-safe wrapper around the collection.","pos":[4720,5068],"source":" These collections, which include the commonly used [ArrayList](https://docs.microsoft.com/dotnet/core/api/System.Collections.ArrayList) and [Hashtable](https://docs.microsoft.com/dotnet/core/api/System.Collections.Hashtable), provide some thread-safety through the `Synchronized` property, which returns a thread-safe wrapper around the collection."},{"content":"The wrapper works by locking the entire collection on every add or remove operation.","pos":[5069,5153]},{"content":"Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock.","pos":[5154,5265]},{"content":"This is not scalable and can cause significant performance degradation for large collections.","pos":[5266,5359]},{"content":"Also, the design is not completely protected from race conditions.","pos":[5360,5426]},{"content":"The collection classes first introduced in the .NET Framework version 2.0 are found in the <bpt id=\"p1\">[</bpt>System.Collections.Generic<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic)</ept> namespace.","pos":[5429,5630],"source":"The collection classes first introduced in the .NET Framework version 2.0 are found in the [System.Collections.Generic](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic) namespace."},{"content":"These include <bpt id=\"p1\">[</bpt>List<ph id=\"ph1\">&amp;lt;</ph>T<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.List-1)</ept>, <bpt id=\"p2\">[</bpt>Dictionary<ph id=\"ph3\">&amp;lt;</ph>TKey, TValue<ph id=\"ph4\">&amp;gt;</ph><ept id=\"p2\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Dictionary-2)</ept>, and so on.","pos":[5631,5868],"source":" These include [List&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.List-1), [Dictionary&lt;TKey, TValue&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Dictionary-2), and so on."},{"content":"These classes provide improved type safety and performance compared to the <ph id=\"ph1\">`System.Collections`</ph> classes.","pos":[5869,5973],"source":" These classes provide improved type safety and performance compared to the `System.Collections` classes."},{"content":"However, the <ph id=\"ph1\">`System.Collections.Generic`</ph> collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently.","pos":[5974,6186],"source":" However, the `System.Collections.Generic` collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently."},{"pos":[6188,6464],"content":"We recommend the <ph id=\"ph1\">`System.Collections.Concurrent`</ph> collection classes because they provide not only the type safety of the <ph id=\"ph2\">`System.Collections.Generic`</ph> collection classes, but also more efficient and more complete thread safety than the <ph id=\"ph3\">`System.Collections`</ph> collections provide.","source":"We recommend the `System.Collections.Concurrent` collection classes because they provide not only the type safety of the `System.Collections.Generic` collection classes, but also more efficient and more complete thread safety than the `System.Collections` collections provide."},{"content":"Related Topics","pos":[6469,6483]},{"content":"Title","pos":[6485,6490]},{"content":"Description","pos":[6493,6504]},{"content":"BlockingCollection Overview","pos":[6526,6553]},{"pos":[6589,6662],"content":"Describes the functionality provided by the <ph id=\"ph1\">`BlockingCollection&lt;T&gt;`</ph> type.","source":"Describes the functionality provided by the `BlockingCollection<T>` type."},{"content":"When to Use a Thread-Safe Collection","pos":[6664,6700]},{"content":"Explains when is it appropriate to use a thread-safe collection.","pos":[6745,6809]},{"content":"How to: Add and Remove Items from a ConcurrentDictionary","pos":[6811,6867]},{"pos":[6903,6988],"content":"Describes how to add and remove elements from a <ph id=\"ph1\">`ConcurrentDictionary&lt;TKey, TValue&gt;`</ph>.","source":"Describes how to add and remove elements from a `ConcurrentDictionary<TKey, TValue>`."},{"content":"How to: Add and Take Items Individually from a BlockingCollection","pos":[6990,7055]},{"content":"Describes how to add and retrieve items from a blocking collection without using the read-only enumerator.","pos":[7089,7195]},{"content":"How to: Add Bounding and Blocking Functionality to a Collection","pos":[7197,7260]},{"pos":[7302,7432],"content":"Describes how to use any collection class as the underlying storage mechanism for an <ph id=\"ph1\">`IProducerConsumerCollection&lt;T&gt;;`</ph> collection.","source":"Describes how to use any collection class as the underlying storage mechanism for an `IProducerConsumerCollection<T>;` collection."},{"content":"How to: Use ForEach to Remove Items in a BlockingCollection","pos":[7434,7493]},{"pos":[7531,7607],"content":"Describes how to use <ph id=\"ph1\">`foreach`</ph> to remove all items in a blocking collection.","source":"Describes how to use `foreach` to remove all items in a blocking collection."},{"content":"How to: Use Arrays of Blocking Collections in a Pipeline","pos":[7609,7665]},{"content":"Describes how to use multiple blocking collections at the same time to implement a pipeline.","pos":[7714,7806]},{"content":"How to: Create an Object Pool by Using a ConcurrentBag","pos":[7808,7862]},{"content":"Shows how to use a concurrent bag to improve performance in scenarios where you can reuse objects instead of continually creating new ones.","pos":[7899,8038]},{"content":"Reference","pos":[8043,8052]},{"content":"System.Collections.Concurrent","pos":[8055,8084]}],"content":"---\ntitle: Thread-Safe Collections\ndescription: Thread-Safe Collections\nkeywords: .NET, .NET Core\nauthor: mairaw\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: 92d5515d-f5d6-4a09-8bbb-31865d678643\n---\n\n# Thread-Safe Collections\n\nThe [System.Collections.Concurrent](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent) namespace includes several collection classes that are both thread-safe and scalable. Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code. When you write new code, use the concurrent collection classes whenever the collection will be writing to multiple threads concurrently. If you are only reading from a shared collection, then you can use the classes in the [System.Collections.Generic](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic) namespace. We recommend that you do not use [System.Collections](https://docs.microsoft.com/dotnet/core/api/System.Collections) collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime.\n\n## Fine-Grained Locking and Lock-Free Mechanisms\n\nSome of the concurrent collection types use lightweight synchronization mechanisms such as [SpinLock](https://docs.microsoft.com/dotnet/core/api/System.Threading.SpinLock), [SpinWait](https://docs.microsoft.com/dotnet/core/api/System.Threading.SpinWait), [SemaphoreSlim](https://docs.microsoft.com/dotnet/core/api/System.Threading.SemaphoreSlim), and [CountdownEvent](https://docs.microsoft.com/dotnet/core/api/System.Threading.CountdownEvent). These synchronization types typically use busy spinning for brief periods before they put the thread into a true `Wait` state. When wait times are expected to be very short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition. For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a very high rate.\n\nThe [ConcurrentQueue&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1) and [ConcurrentStack&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1) classes do not use locks at all. Instead, they rely on Interlocked operations to achieve thread-safety.\n\n> [!NOTE]\n> Because the concurrent collections classes support [ICollection](https://docs.microsoft.com/dotnet/core/api/System.Collections.ICollection), they provide implementations for the `IsSynchronized` and `SyncRoot` properties, even though these properties are irrelevant. `IsSynchronized` always returns `false` and `SyncRoot` is always null.\n\nThe following table lists the collection types in the [System.Collections.Concurrent](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent) namespace.\n\nType | Description\n---- | -----------\n[BlockingCollection&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1) | Provides bounding and blocking functionality for any type that implements [IProducerConsumerCollection&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1). For more information, see [BlockingCollection Overview](blockingcollection-overview.md).\n[ConcurrentBag&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1) | Thread-safe implementation of an unordered collection of elements.\n[ConcurrentDictionary&lt;TKey, TValue&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentDictionary-2) | Thread-safe implementation of a dictionary of key-value pairs.\n[ConcurrentQueue&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1) | Thread-safe implementation of a FIFO (first-in, first-out) queue.\n[ConcurrentStack&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1) | Thread-safe implementation of a LIFO (last-in, first-out) stack.\n[IProducerConsumerCollection&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1) | The interface that a type must implement to be used in a `BlockingCollection`.\n\n## Thread Synchronization in the .NET Framework version 1.0 and 2.0 Collections\n\nThe collections first introduced in the .NET Framework version 1.0 are found in the [System.Collections](https://docs.microsoft.com/dotnet/core/api/System.Collections) namespace. These collections, which include the commonly used [ArrayList](https://docs.microsoft.com/dotnet/core/api/System.Collections.ArrayList) and [Hashtable](https://docs.microsoft.com/dotnet/core/api/System.Collections.Hashtable), provide some thread-safety through the `Synchronized` property, which returns a thread-safe wrapper around the collection. The wrapper works by locking the entire collection on every add or remove operation. Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock. This is not scalable and can cause significant performance degradation for large collections. Also, the design is not completely protected from race conditions. \n\nThe collection classes first introduced in the .NET Framework version 2.0 are found in the [System.Collections.Generic](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic) namespace. These include [List&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.List-1), [Dictionary&lt;TKey, TValue&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Dictionary-2), and so on. These classes provide improved type safety and performance compared to the `System.Collections` classes. However, the `System.Collections.Generic` collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently.\n\nWe recommend the `System.Collections.Concurrent` collection classes because they provide not only the type safety of the `System.Collections.Generic` collection classes, but also more efficient and more complete thread safety than the `System.Collections` collections provide.\n\n## Related Topics\n\nTitle | Description\n----- | -----------\n[BlockingCollection Overview](blockingcollection-overview.md) | Describes the functionality provided by the `BlockingCollection<T>` type.\n[When to Use a Thread-Safe Collection](when-to-use-a-thread-safe-collection.md) | Explains when is it appropriate to use a thread-safe collection.\n[How to: Add and Remove Items from a ConcurrentDictionary](how-to-add-and-remove-items.md) | Describes how to add and remove elements from a `ConcurrentDictionary<TKey, TValue>`.\n[How to: Add and Take Items Individually from a BlockingCollection](how-to-add-and-take-items.md) | Describes how to add and retrieve items from a blocking collection without using the read-only enumerator.\n[How to: Add Bounding and Blocking Functionality to a Collection](how-to-add-bounding-and-blocking.md ) | Describes how to use any collection class as the underlying storage mechanism for an `IProducerConsumerCollection<T>;` collection.\n[How to: Use ForEach to Remove Items in a BlockingCollection](how-to-use-foreach-to-remove.md ) | Describes how to use `foreach` to remove all items in a blocking collection.\n[How to: Use Arrays of Blocking Collections in a Pipeline](how-to-use-arrays-of-blockingcollections.md) | Describes how to use multiple blocking collections at the same time to implement a pipeline.\n[How to: Create an Object Pool by Using a ConcurrentBag](how-to-create-an-object-pool.md) | Shows how to use a concurrent bag to improve performance in scenarios where you can reuse objects instead of continually creating new ones.\n\n## Reference\n\n[System.Collections.Concurrent](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)\n\n\n\n\n\n\n \n\n\n"}