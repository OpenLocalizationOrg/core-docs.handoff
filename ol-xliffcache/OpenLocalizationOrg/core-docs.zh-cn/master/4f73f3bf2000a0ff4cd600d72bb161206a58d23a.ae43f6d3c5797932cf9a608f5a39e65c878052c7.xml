{"nodes":[{"content":"How to: Add and Take Items Individually from a BlockingCollection","pos":[12,77]},{"content":"How to: Add and Take Items Individually from a BlockingCollection","pos":[93,158]},{"pos":[170,185],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":"How to: Add and Take Items Individually from a BlockingCollection","pos":[389,454]},{"content":"This example shows how to add and remove items from a <bpt id=\"p1\">[</bpt>BlockingCollection<ph id=\"ph1\">&amp;lt;</ph>T<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">]( https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> in both a blocking and non-blocking manner.","pos":[456,679],"source":"This example shows how to add and remove items from a [BlockingCollection&lt;T&gt;]( https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1) in both a blocking and non-blocking manner."},{"content":"For more information on <ph id=\"ph1\">`BlockingCollection&lt;T&gt;`</ph>, see <bpt id=\"p1\">[</bpt>BlockingCollection Overview<ept id=\"p1\">](blockingcollection-overview.md)</ept>.","pos":[680,795],"source":" For more information on `BlockingCollection<T>`, see [BlockingCollection Overview](blockingcollection-overview.md)."},{"pos":[798,1012],"content":"For an example of how to enumerate a <ph id=\"ph1\">`BlockingCollection&lt;T&gt;`</ph> until it is empty and no more elements will be added, see <bpt id=\"p1\">[</bpt>How to: Use ForEach to Remove Items in a BlockingCollection<ept id=\"p1\">](how-to-use-foreach-to-remove.md)</ept>.","source":"For an example of how to enumerate a `BlockingCollection<T>` until it is empty and no more elements will be added, see [How to: Use ForEach to Remove Items in a BlockingCollection](how-to-use-foreach-to-remove.md)."},{"content":"Example","pos":[1017,1024]},{"content":"Example","pos":[2777,2784]},{"content":"This second example shows how to add and take items so that the operations will not block.","pos":[2786,2876]},{"content":"If no item is present, or maximum capacity on a bounded collection has been reached, or the timeout period has elapsed, then the <ph id=\"ph1\">`TryAdd`</ph> or <ph id=\"ph2\">`TryTake`</ph> operation returns false.","pos":[2877,3052],"source":" If no item is present, or maximum capacity on a bounded collection has been reached, or the timeout period has elapsed, then the `TryAdd` or `TryTake` operation returns false."},{"content":"This allows the thread to do some other useful work for awhile and then try again later to either retrieve a new item, or try to add the same item that could not be added previously.","pos":[3053,3235]},{"content":"The program also demonstrates how to implement cancellation when accessing a <ph id=\"ph1\">`BlockingCollection&lt;T&gt;`</ph>.","pos":[3236,3337],"source":" The program also demonstrates how to implement cancellation when accessing a `BlockingCollection<T>`."},{"content":"See Also","pos":[6891,6899]},{"content":"System.Collections.Concurrent","pos":[6902,6931]},{"content":"BlockingCollection Overview","pos":[7010,7037]}],"content":"---\ntitle: \"How to: Add and Take Items Individually from a BlockingCollection\"\ndescription: \"How to: Add and Take Items Individually from a BlockingCollection\"\nkeywords: .NET, .NET Core\nauthor: mairaw\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: 2b9d39ab-0993-4453-b021-b04870098bf7\n---\n\n# How to: Add and Take Items Individually from a BlockingCollection\n\nThis example shows how to add and remove items from a [BlockingCollection&lt;T&gt;]( https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1) in both a blocking and non-blocking manner. For more information on `BlockingCollection<T>`, see [BlockingCollection Overview](blockingcollection-overview.md). \n\nFor an example of how to enumerate a `BlockingCollection<T>` until it is empty and no more elements will be added, see [How to: Use ForEach to Remove Items in a BlockingCollection](how-to-use-foreach-to-remove.md).\n\n## Example\n\n```csharp\nusing System;\nusing System.Collections.Concurrent;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nclass Program\n{\n   static void Main()\n   {\n      // Increase or decrease this value as desired.\n      int itemsToAdd = 500;\n\n      // Preserve all the display output for Adds and Takes\n      Console.SetBufferSize(80, (itemsToAdd * 2) + 3);\n\n      // A bounded collection. Increase, decrease, or remove the\n      // maximum capacity argument to see how it impacts behavior.\n      BlockingCollection<int> numbers = new BlockingCollection<int>(50);\n\n\n      // A simple blocking consumer with no cancellation.\n      Task.Run(() =>\n      {\n          int i = -1;\n          while (!numbers.IsCompleted)\n          {\n              try\n              {\n                  i = numbers.Take();\n              }\n              catch (InvalidOperationException)\n              {\n                  Console.WriteLine(\"Adding was completed!\");\n                  break;\n              }\n              Console.WriteLine(\"Take:{0} \", i);\n\n              // Simulate a slow consumer. This will cause\n              // collection to fill up fast and thus Adds will block.\n              Thread.SpinWait(100000);\n          }\n\n          Console.WriteLine(\"\\r\\nNo more items to take. Press the Enter key to exit.\");\n      });\n\n      // A simple blocking producer with no cancellation.\n      Task.Run(() =>\n      {\n          for (int i = 0; i < itemsToAdd; i++) {\n              numbers.Add(i);\n              Console.WriteLine(\"Add:{0} Count={1}\", i, numbers.Count);\n          }\n\n          // See documentation for this method.\n          numbers.CompleteAdding();\n      });\n\n      // Keep the console display open in debug mode.\n      Console.ReadLine();\n   }\n}\n\n```\n\n## Example\n\nThis second example shows how to add and take items so that the operations will not block. If no item is present, or maximum capacity on a bounded collection has been reached, or the timeout period has elapsed, then the `TryAdd` or `TryTake` operation returns false. This allows the thread to do some other useful work for awhile and then try again later to either retrieve a new item, or try to add the same item that could not be added previously. The program also demonstrates how to implement cancellation when accessing a `BlockingCollection<T>`.\n\n```csharp\nusing System;\nusing System.Collections.Concurrent;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nclass ProgramWithCancellation\n{\n\n    static int inputs = 2000;\n\n    static void Main()\n    {\n        // The token source for issuing the cancelation request.\n        CancellationTokenSource cts = new CancellationTokenSource();\n\n        // A blocking collection that can hold no more than 100 items at a time.\n        BlockingCollection<int> numberCollection = new BlockingCollection<int>(100);\n\n        // Set console buffer to hold our prodigious output.\n        Console.SetBufferSize(80, 2000);\n\n        // The simplest UI thread ever invented.\n        Task.Run(() =>\n        {\n            if (Console.ReadKey(true).KeyChar == 'c')\n                cts.Cancel();\n        });\n\n        // Start one producer and one consumer.\n        Task t1 = Task.Run(() => NonBlockingConsumer(numberCollection, cts.Token));\n        Task t2 = Task.Run(() => NonBlockingProducer(numberCollection, cts.Token));\n\n        // Wait for the tasks to complete execution\n        Task.WaitAll(t1, t2);\n\n        cts.Dispose();\n        Console.WriteLine(\"Press the Enter key to exit.\");\n        Console.ReadLine();\n    }\n\n    static void NonBlockingConsumer(BlockingCollection<int> bc, CancellationToken ct)\n    {\n        while (!bc.IsCompleted)\n        {\n            int nextItem = 0;\n            try\n            {\n                if (!bc.TryTake(out nextItem, 0, ct))\n                {\n                    Console.WriteLine(\" Take Blocked\");\n                }\n                else\n                {\n                    Console.WriteLine(\" Take:{0}\", nextItem);\n                }\n            }\n\n            catch (OperationCanceledException)\n            {\n                Console.WriteLine(\"Taking canceled.\");\n                break;\n            }\n\n            // Slow down consumer just a little to cause\n            // collection to fill up faster, and lead to \"AddBlocked\"\n            Thread.SpinWait(500000);\n        }\n\n        Console.WriteLine(\"\\r\\nNo more items to take.\");\n    }\n\n    static void NonBlockingProducer(BlockingCollection<int> bc, CancellationToken ct)\n    {\n        int itemToAdd = 0;\n        bool success = false;\n\n        do\n        {\n            // Cancellation causes OCE. We know how to handle it.\n            try\n            {\n                // A shorter timeout causes more failures.\n                success = bc.TryAdd(itemToAdd, 2, ct);\n            }\n            catch (OperationCanceledException)\n            {\n                Console.WriteLine(\"Add loop canceled.\");\n                // Let other threads know we're done in case\n                // they aren't monitoring the cancellation token.\n                bc.CompleteAdding();\n                break;\n            }\n\n            if (success)\n            {\n                Console.WriteLine(\" Add:{0}\", itemToAdd);\n                itemToAdd++;\n            }\n            else\n            {\n                Console.Write(\" AddBlocked:{0} Count = {1}\", itemToAdd.ToString(), bc.Count);\n                // Don't increment nextItem. Try again on next iteration.\n\n                //Do something else useful instead.\n                UpdateProgress(itemToAdd);\n            }\n\n        } while (itemToAdd < inputs);\n\n        // No lock required here because only one producer.\n        bc.CompleteAdding();\n    }\n\n    static void UpdateProgress(int i)\n    {\n        double percent = ((double)i / inputs) * 100;\n        Console.WriteLine(\"Percent complete: {0}\", percent);\n    }\n}\n\n```\n\n## See Also\n\n[System.Collections.Concurrent]( https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)\n\n[BlockingCollection Overview](blockingcollection-overview.md)\n"}