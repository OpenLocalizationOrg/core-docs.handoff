{"nodes":[{"pos":[11,53],"content":"System.Delegate and the `delegate` keyword","needQuote":true,"nodes":[{"content":"System.Delegate and the `delegate` keyword","pos":[0,42]}]},{"pos":[67,109],"content":"System.Delegate and the `delegate` keyword","needQuote":true,"nodes":[{"content":"System.Delegate and the `delegate` keyword","pos":[0,42]}]},{"pos":[120,135],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"pos":[343,385],"content":"System.Delegate and the <ph id=\"ph1\">`delegate`</ph> keyword","source":"System.Delegate and the `delegate` keyword"},{"content":"Previous","pos":[388,396]},{"pos":[422,548],"content":"This article will cover the classes in the .NET framework that support delegates, and how those map to the <ph id=\"ph1\">`delegate`</ph> keyword.","source":"This article will cover the classes in the .NET framework\nthat support delegates, and how those map to the `delegate`\nkeyword."},{"content":"Defining Delegate Types","pos":[553,576]},{"content":"Let's start with the 'delegate' keyword, because that's primarily what you will use as you work with delegates.","pos":[578,689],"source":"Let's start with the 'delegate' keyword, because that's primarily what\nyou will use as you work with delegates."},{"content":"The code that the compiler generates when you use the <ph id=\"ph1\">`delegate`</ph> keyword will map to method calls that invoke members of the @System.Delegate and @System.MulticastDelegate classes.","pos":[690,871],"source":" The code that the\ncompiler generates when you use the `delegate` keyword will\nmap to method calls that invoke members of the @System.Delegate \nand @System.MulticastDelegate classes."},{"content":"You define a delegate type using syntax that is similar to defining a method signature.","pos":[874,961],"source":"You define a delegate type using syntax that is similar to defining\na method signature."},{"content":"You just add the <ph id=\"ph1\">`delegate`</ph> keyword to the definition.","pos":[962,1016],"source":" You just add the `delegate` keyword to the\ndefinition."},{"content":"Let's continue to use the List.Sort() method as our example.","pos":[1018,1078]},{"content":"The first step is to create a type for the comparison delegate:","pos":[1079,1142],"source":" The first\nstep is to create a type for the comparison delegate:"},{"content":"The compiler generates a class, derived from <ph id=\"ph1\">`System.Delegate`</ph> that matches the signature used (in this case, a method that returns an integer, and has two arguments).","pos":[1270,1437],"source":"The compiler generates a class, derived from `System.Delegate`\nthat matches the signature used (in this case, a method that\nreturns an integer, and has two arguments)."},{"content":"The type of that delegate is <ph id=\"ph1\">`Comparison`</ph>.","pos":[1438,1480],"source":" The type\nof that delegate is `Comparison`."},{"content":"The <ph id=\"ph1\">`Comparison`</ph> delegate type is a generic type.","pos":[1481,1530],"source":" The `Comparison` delegate\ntype is a generic type."},{"content":"For details on generics see <bpt id=\"p1\">[</bpt>here<ept id=\"p1\">](generics.md)</ept>.","pos":[1531,1579],"source":" For details on generics see [here](generics.md)."},{"content":"Notice that the syntax may appear as though it is declaring a variable, but it is actually declaring a <bpt id=\"p1\">*</bpt>type<ept id=\"p1\">*</ept>.","pos":[1581,1691],"source":"Notice that the syntax may appear as though it is declaring\na variable, but it is actually declaring a *type*."},{"content":"You can define delegate types inside classes, directly inside namespaces, or even in the global namespace.","pos":[1692,1798],"source":" You can\ndefine delegate types inside classes, directly inside namespaces,\nor even in the global namespace."},{"pos":[1802,1908],"content":"[!NOTE]\nDeclaring delegate types (or other types) directly in\nthe global namespace is not recommended.","leadings":["","> ","> "],"nodes":[{"content":"Declaring delegate types (or other types) directly in the global namespace is not recommended.","pos":[8,102],"source":"Declaring delegate types (or other types) directly in\nthe global namespace is not recommended."}]},{"content":"The compiler also generates add and remove handlers for this new type so that clients of this class can add and remove methods from an instance's invocation list.","pos":[1911,2073],"source":"The compiler also generates add and remove handlers for this new\ntype so that clients of this class can add and remove methods from an instance's\ninvocation list."},{"content":"The compiler will enforce that the signature of the method being added or removed matches the signature used when declaring the method.","pos":[2074,2209],"source":" The compiler will enforce that the signature\nof the method being added or removed matches the signature\nused when declaring the method."},{"content":"Declaring instances of delegates","pos":[2215,2247]},{"content":"After defining the delegate, you can create an instance of that type.","pos":[2249,2318]},{"content":"Like all variables in C#, you cannot declare delegate instances directly in a namespace, or in the global namespace.","pos":[2319,2435],"source":"\nLike all variables in C#, you cannot declare delegate instances directly\nin a namespace, or in the global namespace."},{"content":"The type of the variable is <ph id=\"ph1\">`Comparison&lt;T&gt;`</ph>, the delegate type defined earlier.","pos":[2549,2629],"source":"The type of the variable is `Comparison<T>`, the delegate type\n defined earlier."},{"content":"The name of the variable is <ph id=\"ph1\">`comparator`</ph>.","pos":[2630,2671],"source":" The name of the variable is `comparator`."},{"content":"That code snippet above declared a member variable inside a class.","pos":[2675,2741]},{"content":"You can also declare delegate variables that are local variables, or arguments to methods.","pos":[2742,2833],"source":" You can also\n declare delegate variables that are local variables, or arguments to methods."},{"content":"Invoking Delegates","pos":[2838,2856]},{"content":"You invoke the methods that are in the invocation list of a delegate by calling that delegate.","pos":[2858,2952],"source":"You invoke the methods that are in the invocation list of a delegate by calling\nthat delegate."},{"content":"Inside the <ph id=\"ph1\">`Sort()`</ph> method, the code will call the comparison method to determine which order to place objects:","pos":[2953,3064],"source":" Inside the `Sort()` method, the code will call the\ncomparison method to determine which order to place objects:"},{"content":"In the line above, the code <bpt id=\"p1\">*</bpt>invokes<ept id=\"p1\">*</ept> the method attached to the delegate.","pos":[3115,3189],"source":"In the line above, the code *invokes* the method attached to the delegate."},{"content":"You treat the variable as a method name, and invoke it using normal method call syntax.","pos":[3190,3277],"source":"\nYou treat the variable as a method name, and invoke it using normal\nmethod call syntax."},{"content":"That line of code makes an unsafe assumption: There's no guarantee that a target has been added to the delegate.","pos":[3279,3391],"source":"That line of code makes an unsafe assumption: There's no guarantee that\na target has been added to the delegate."},{"content":"If no targets have been attached, the line above would cause a <ph id=\"ph1\">`NullReferenceException`</ph> to be thrown.","pos":[3392,3493],"source":" If no targets have been attached,\nthe line above would cause a `NullReferenceException` to be thrown."},{"content":"The idioms used to address this problem are more complicated than a simple null-check, and are covered later in this <bpt id=\"p1\">[</bpt>series<ept id=\"p1\">](delegates-patterns.md)</ept>.","pos":[3494,3643],"source":" The\nidioms used to address this problem are more complicated than a simple\nnull-check, and are covered later in this [series](delegates-patterns.md)."},{"content":"Assigning, Adding and removing Invocation Targets","pos":[3648,3697]},{"pos":[3699,3790],"content":"That's how a delegate type is defined, and how delegate instances are declared and invoked.","source":"That's how a delegate type is defined, and how delegate instances\nare declared and invoked."},{"content":"Developers that want to use the <ph id=\"ph1\">`List.Sort()`</ph> method need to define a method whose signature matches the delegate type definition, and assign it to the delegate used by the sort method.","pos":[3792,3977],"source":"Developers that want to use the `List.Sort()` method need to define\na method whose signature matches the delegate type definition, and\nassign it to the delegate used by the sort method."},{"content":"This assignment adds the method to the invocation list of that delegate object.","pos":[3978,4057],"source":" This assignment\nadds the method to the invocation list of that delegate object."},{"content":"Suppose you wanted to sort a list of strings by their length.","pos":[4059,4120]},{"content":"Your comparison function might be the following:","pos":[4121,4169],"source":" Your\ncomparison function might be the following:"},{"content":"The method is declared as a private method.","pos":[4294,4337]},{"content":"That's fine.","pos":[4338,4350]},{"content":"You may not want this method to be part of your public interface.","pos":[4351,4416],"source":" You may not\nwant this method to be part of your public interface."},{"content":"It can still be used as the comparison method when attached to a delegate.","pos":[4417,4491],"source":" It can still\nbe used as the comparison method when attached to a delegate."},{"content":"The calling code will have this method attached to the target list of the delegate object, and can access it through that delegate.","pos":[4492,4623],"source":" The\ncalling code will have this method attached to the target list of\nthe delegate object, and can access it through that delegate."},{"pos":[4625,4705],"content":"You create that relationship by passing that method to the <ph id=\"ph1\">`List.Sort()`</ph> method:","source":"You create that relationship by passing that method to the\n`List.Sort()` method:"},{"content":"Notice that the method name is used, without parentheses.","pos":[4747,4804]},{"content":"Using the method as an argument tells the compiler to convert the method reference into a reference that can be used as a delegate invocation target, and attach that method as an invocation target.","pos":[4805,5002],"source":" Using the method\nas an argument tells the compiler to convert the method reference into a reference\nthat can be used as a delegate invocation target, and attach that method as\nan invocation target."},{"pos":[5004,5115],"content":"You could also have been explicit by declaring a variable of type 'Comparison<ph id=\"ph1\">&lt;string&gt;</ph>` and doing an assignment:","source":"You could also have been explicit by declaring a variable of type\n'Comparison<string>` and doing an assignment:"},{"pos":[5197,5368],"content":"In uses where the method being used as a delegate target is a small method, it's common to use <bpt id=\"p1\">[</bpt>Lambda Expression<ept id=\"p1\">](lambda-expressions.md)</ept> syntax to perform the assignment:","source":"In uses where the method being used as a delegate target is a small method,\nit's common to use [Lambda Expression](lambda-expressions.md) syntax\nto perform the assignment:"},{"pos":[5489,5595],"content":"Using Lambda Expressions for delegate targets is covered more in a <bpt id=\"p1\">[</bpt>later section<ept id=\"p1\">](delegates-patterns.md)</ept>.","source":"Using Lambda Expressions for delegate targets\nis covered more in a [later section](delegates-patterns.md)."},{"content":"The Sort() example typically attaches a single target method to the delegate.","pos":[5597,5674],"source":"The Sort() example typically attaches a single target method to the\ndelegate."},{"content":"However, delegate objects do support invocation lists that have multiple target methods attached to a delegate object.","pos":[5675,5793],"source":" However, delegate objects do support invocation lists that\nhave multiple target methods attached to a delegate object."},{"content":"Delegate and MulticastDelegate classes","pos":[5798,5836]},{"content":"The language support desccribed above provides the features and support you'll typically need to work with delegates.","pos":[5838,5955],"source":"The language support desccribed above provides the features\nand support you'll typically need to work with delegates."},{"content":"These features are built on two classes in the .NET Core framework: @System.Delegate and @\"System.MulticastDelegate\".","pos":[5956,6073],"source":" These\nfeatures are built on two classes in the .NET Core\nframework: @System.Delegate and @\"System.MulticastDelegate\"."},{"pos":[6075,6326],"content":"The <ph id=\"ph1\">`System.Delegate`</ph> class, and its single direct sub-class, <ph id=\"ph2\">`System.MulticastDelegate`</ph>, provide the framework support for creating delegates, registering methods as delegate targets, and invoking all methods that are registered as a delegate target.","source":"The `System.Delegate` class, and its single direct sub-class,\n`System.MulticastDelegate`, provide the framework support for\ncreating delegates, registering methods as delegate targets,\nand invoking all methods that are registered as a delegate\ntarget."},{"content":"Interestingly, the <ph id=\"ph1\">`System.Delegate`</ph> and <ph id=\"ph2\">`System.MulticastDelegate`</ph> classes are not themselves delegate types.","pos":[6329,6439],"source":"Interestingly, the `System.Delegate` and `System.MulticastDelegate`\nclasses are not themselves delegate types."},{"content":"They do provide the basis for all specific delegate types.","pos":[6440,6498],"source":" They do provide the\nbasis for all specific delegate types."},{"content":"That same language design process mandated that you cannot declare a class that derives from <ph id=\"ph1\">`Delegate`</ph> or <ph id=\"ph2\">`MulticastDelegate`</ph>.","pos":[6499,6626],"source":" That same language\ndesign process mandated that you cannot declare a class that derives\nfrom `Delegate` or `MulticastDelegate`."},{"content":"The C# language rules prohibit it.","pos":[6627,6661]},{"pos":[6664,6814],"content":"Instead, the C# compiler creates instances of a class derived from <ph id=\"ph1\">`MulticastDelegate`</ph> when you use the C# language keyword to declare delegate types.","source":"Instead, the C# compiler creates instances of a class derived from `MulticastDelegate`\nwhen you use the C# language keyword to declare delegate types."},{"content":"This design has its roots in the first release of C# and .NET.","pos":[6816,6878]},{"content":"One goal for the design team was to ensure that the language enforced type safety when using delegates.","pos":[6879,6982],"source":" One\ngoal for the design team was to ensure that the language enforced\ntype safety when using delegates."},{"content":"That meant ensuring that delegates were invoked with the right type and number of arguments.","pos":[6983,7075],"source":" That meant ensuring that delegates\nwere invoked with the right type and number of arguments."},{"content":"And, that any return type was correctly indicated at compile time.","pos":[7076,7142],"source":" And, that\nany return type was correctly indicated at compile time."},{"content":"Delegates were part of the 1.0 .NET release, which was before generics.","pos":[7143,7214],"source":" Delegates\nwere part of the 1.0 .NET release, which was before generics."},{"pos":[7216,7367],"content":"The best way to enforce this type safety was for the compiler to create the concrete delegate classes that represented the method signature being used.","source":"The best way to enforce this type safety was for the compiler to\ncreate the concrete delegate classes that represented the\nmethod signature being used."},{"content":"Even though you cannot create derived classes directly, you will use the methods defined on these classes.","pos":[7369,7475],"source":"Even though you cannot create derived classes directly, you will\nuse the methods defined on these classes."},{"content":"Let's go through the most common methods that you will use when you work with delegates.","pos":[7476,7564],"source":" Let's go through\nthe most common methods that you will use when you work with delegates."},{"content":"The first, most important fact to remember is that every delegate you work with is derived from <ph id=\"ph1\">`MulticastDelegate`</ph>.","pos":[7566,7682],"source":"The first, most important fact to remember is that every delegate you\nwork with is derived from `MulticastDelegate`."},{"content":"A multicast delegate means that more than one method target can be invoked when invoking through a delegate.","pos":[7683,7791],"source":" A multicast delegate means\nthat more than one method target can be invoked when invoking through\na delegate."},{"content":"The original design considered making a distinction between delegates where only one target method could be attached and invoked, and delegates where multiple target methods could be attached and invoked.","pos":[7792,7996],"source":" The original design considered making a distinction between\ndelegates where only one target method could be attached and invoked,\nand delegates where multiple target methods could be attached and\ninvoked."},{"content":"That distinction proved to be less useful in practice than originally thought.","pos":[7997,8075],"source":" That distinction proved to be less useful in practice than\noriginally thought."},{"content":"The two different classes were already created, and have been in the framework since its initial public release.","pos":[8076,8188],"source":" The two different classes were already created,\nand have been in the framework since its initial public release."},{"content":"The methods that you will use the most with delegates are <ph id=\"ph1\">`Invoke()`</ph> and <ph id=\"ph2\">`BeginInvoke()` / `EndInvoke()`</ph>.","pos":[8190,8295],"source":"The methods that you will use the most with delegates are `Invoke()` and\n`BeginInvoke()` / `EndInvoke()`."},{"content":"will invoke all the methods that have been attached to a particular delegate instance.","pos":[8307,8393],"source":" will invoke all the methods that\nhave been attached to a particular delegate instance."},{"content":"As you saw above, you typically invoke delegates using the method call syntax on the delegate variable.","pos":[8394,8497],"source":" As you saw above, you\ntypically invoke delegates using the method call syntax on the delegate\nvariable."},{"content":"As you'll see <bpt id=\"p1\">[</bpt>later in this series<ept id=\"p1\">](delegates-patterns.md)</ept>, there are patterns that work directly with these methods.","pos":[8498,8616],"source":" As you'll see [later in this series](delegates-patterns.md),\nthere are patterns that work directly with these methods."},{"pos":[8618,8772],"content":"Now that you've seen the language syntax and the classes that support delegates, let's examine how strongly typed delegates are used, created and invoked.","source":"Now that you've seen the language syntax and the classes that support\ndelegates, let's examine how strongly typed delegates are used, created\nand invoked."},{"content":"Next","pos":[8775,8779]}],"content":"---\ntitle: System.Delegate and the `delegate` keyword\ndescription: System.Delegate and the `delegate` keyword\nkeywords: .NET, .NET Core\nauthor: BillWagner\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: f3742fda-13c2-4283-8966-9e21c2674393\n---\n\n# System.Delegate and the `delegate` keyword\n\n[Previous](delegates-overview.md)\n\nThis article will cover the classes in the .NET framework\nthat support delegates, and how those map to the `delegate`\nkeyword.\n\n## Defining Delegate Types\n\nLet's start with the 'delegate' keyword, because that's primarily what\nyou will use as you work with delegates. The code that the\ncompiler generates when you use the `delegate` keyword will\nmap to method calls that invoke members of the @System.Delegate \nand @System.MulticastDelegate classes. \n\nYou define a delegate type using syntax that is similar to defining\na method signature. You just add the `delegate` keyword to the\ndefinition.\n\nLet's continue to use the List.Sort() method as our example. The first\nstep is to create a type for the comparison delegate:\n\n```cs\n// From the .NET Core library\n\n// Define the delegate type:\npublic delegate int Comparison<in T>(T left, T right);\n```\n\nThe compiler generates a class, derived from `System.Delegate`\nthat matches the signature used (in this case, a method that\nreturns an integer, and has two arguments). The type\nof that delegate is `Comparison`. The `Comparison` delegate\ntype is a generic type. For details on generics see [here](generics.md).\n\nNotice that the syntax may appear as though it is declaring\na variable, but it is actually declaring a *type*. You can\ndefine delegate types inside classes, directly inside namespaces,\nor even in the global namespace.\n\n> [!NOTE]\n> Declaring delegate types (or other types) directly in\n> the global namespace is not recommended. \n\nThe compiler also generates add and remove handlers for this new\ntype so that clients of this class can add and remove methods from an instance's\ninvocation list. The compiler will enforce that the signature\nof the method being added or removed matches the signature\nused when declaring the method. \n\n## Declaring instances of delegates\n\nAfter defining the delegate, you can create an instance of that type.\nLike all variables in C#, you cannot declare delegate instances directly\nin a namespace, or in the global namespace.\n\n```cs\n// inside a class definition:\n\n// Declare an instance of that type:\npublic Comparison<T> comparator;\n```\n\nThe type of the variable is `Comparison<T>`, the delegate type\n defined earlier. The name of the variable is `comparator`.\n \n That code snippet above declared a member variable inside a class. You can also\n declare delegate variables that are local variables, or arguments to methods.\n\n## Invoking Delegates\n\nYou invoke the methods that are in the invocation list of a delegate by calling\nthat delegate. Inside the `Sort()` method, the code will call the\ncomparison method to determine which order to place objects:\n\n```cs\nint result = comparator(left, right);\n```\n\nIn the line above, the code *invokes* the method attached to the delegate.\nYou treat the variable as a method name, and invoke it using normal\nmethod call syntax.\n\nThat line of code makes an unsafe assumption: There's no guarantee that\na target has been added to the delegate. If no targets have been attached,\nthe line above would cause a `NullReferenceException` to be thrown. The\nidioms used to address this problem are more complicated than a simple\nnull-check, and are covered later in this [series](delegates-patterns.md).\n\n## Assigning, Adding and removing Invocation Targets\n\nThat's how a delegate type is defined, and how delegate instances\nare declared and invoked.\n\nDevelopers that want to use the `List.Sort()` method need to define\na method whose signature matches the delegate type definition, and\nassign it to the delegate used by the sort method. This assignment\nadds the method to the invocation list of that delegate object.\n\nSuppose you wanted to sort a list of strings by their length. Your\ncomparison function might be the following:\n\n```cs\nprivate static int CompareLength(string left, string right)\n{\n    return left.Length.CompareTo(right.Length);\n}\n```\n\nThe method is declared as a private method. That's fine. You may not\nwant this method to be part of your public interface. It can still\nbe used as the comparison method when attached to a delegate. The\ncalling code will have this method attached to the target list of\nthe delegate object, and can access it through that delegate.\n\nYou create that relationship by passing that method to the\n`List.Sort()` method:\n\n```cs\nphrases.Sort(CompareLength);\n```\n\nNotice that the method name is used, without parentheses. Using the method\nas an argument tells the compiler to convert the method reference into a reference\nthat can be used as a delegate invocation target, and attach that method as\nan invocation target.\n\nYou could also have been explicit by declaring a variable of type\n'Comparison<string>` and doing an assignment:\n\n```cs\nComparison<string> comparer = CompareLength;\nphrases.Sort(comparer);\n```\n\nIn uses where the method being used as a delegate target is a small method,\nit's common to use [Lambda Expression](lambda-expressions.md) syntax\nto perform the assignment:\n\n```cs\nComparison<string> comparer = (left, right) => left.Length.CompareTo(right.Length);\nphrases.Sort(comparer);\n```\n\nUsing Lambda Expressions for delegate targets\nis covered more in a [later section](delegates-patterns.md).\n\nThe Sort() example typically attaches a single target method to the\ndelegate. However, delegate objects do support invocation lists that\nhave multiple target methods attached to a delegate object.\n\n## Delegate and MulticastDelegate classes\n\nThe language support desccribed above provides the features\nand support you'll typically need to work with delegates. These\nfeatures are built on two classes in the .NET Core\nframework: @System.Delegate and @\"System.MulticastDelegate\".\n\nThe `System.Delegate` class, and its single direct sub-class,\n`System.MulticastDelegate`, provide the framework support for\ncreating delegates, registering methods as delegate targets,\nand invoking all methods that are registered as a delegate\ntarget. \n\nInterestingly, the `System.Delegate` and `System.MulticastDelegate`\nclasses are not themselves delegate types. They do provide the\nbasis for all specific delegate types. That same language\ndesign process mandated that you cannot declare a class that derives\nfrom `Delegate` or `MulticastDelegate`. The C# language rules prohibit it.\n \nInstead, the C# compiler creates instances of a class derived from `MulticastDelegate`\nwhen you use the C# language keyword to declare delegate types.\n\nThis design has its roots in the first release of C# and .NET. One\ngoal for the design team was to ensure that the language enforced\ntype safety when using delegates. That meant ensuring that delegates\nwere invoked with the right type and number of arguments. And, that\nany return type was correctly indicated at compile time. Delegates\nwere part of the 1.0 .NET release, which was before generics.\n\nThe best way to enforce this type safety was for the compiler to\ncreate the concrete delegate classes that represented the\nmethod signature being used.\n\nEven though you cannot create derived classes directly, you will\nuse the methods defined on these classes. Let's go through\nthe most common methods that you will use when you work with delegates.\n\nThe first, most important fact to remember is that every delegate you\nwork with is derived from `MulticastDelegate`. A multicast delegate means\nthat more than one method target can be invoked when invoking through\na delegate. The original design considered making a distinction between\ndelegates where only one target method could be attached and invoked,\nand delegates where multiple target methods could be attached and\ninvoked. That distinction proved to be less useful in practice than\noriginally thought. The two different classes were already created,\nand have been in the framework since its initial public release.\n\nThe methods that you will use the most with delegates are `Invoke()` and\n`BeginInvoke()` / `EndInvoke()`. `Invoke()` will invoke all the methods that\nhave been attached to a particular delegate instance. As you saw above, you\ntypically invoke delegates using the method call syntax on the delegate\nvariable. As you'll see [later in this series](delegates-patterns.md),\nthere are patterns that work directly with these methods.\n\nNow that you've seen the language syntax and the classes that support\ndelegates, let's examine how strongly typed delegates are used, created\nand invoked.\n\n[Next](delegates-strongly-typed.md)"}