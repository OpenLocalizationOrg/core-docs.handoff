{"nodes":[{"pos":[11,52],"content":".NET Core CLI test communication protocol","needQuote":true,"nodes":[{"content":".NET Core CLI test communication protocol","pos":[0,41]}]},{"pos":[66,107],"content":".NET Core CLI test communication protocol","needQuote":true,"nodes":[{"content":".NET Core CLI test communication protocol","pos":[0,41]}]},{"pos":[118,133],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":".NET Core CLI test communication protocol","pos":[336,377]},{"content":"Introduction","pos":[382,394]},{"content":"Anytime you pass a port to dotnet test, the command will run in design time.","pos":[395,471]},{"content":"That means that dotnet test will connect to that port using TCP and will then exchange an established set of messages with whatever else is connected to that port.","pos":[472,635],"source":" That means that dotnet test will connect to that port\nusing TCP and will then exchange an established set of messages with whatever else is connected to that port."},{"content":"When this happens, the runner also receives a new port that dotnet test will use to communicate with it.","pos":[636,740],"source":" When this happens, the runner\nalso receives a new port that dotnet test will use to communicate with it."},{"content":"The reason why the runner also uses TCP to communicate with dotnet test is because in design mode, it is not sufficient to just output results to the console.","pos":[741,899],"source":" The reason why the runner also uses TCP to\ncommunicate with dotnet test is because in design mode, it is not sufficient to just output results to the console."},{"content":"The command needs to send the adapter structure messages containing the results of the test execution.","pos":[900,1003],"source":" The \ncommand needs to send the adapter structure messages containing the results of the test execution."},{"content":"Communication protocol at design time.","pos":[1009,1047]},{"content":"Because during design time, dotnet test connects to a port when it starts up, the adapter needs to be listening on that port otherwise dotnet test will fail.","pos":[1052,1210],"source":"Because during design time, dotnet test connects to a port when it starts up, the adapter needs to be listening on \nthat port otherwise dotnet test will fail."},{"content":"We did it like this so that the adapter could reserve all the ports it needs by binding and listening to them before dotnet test ran and tried to get ports for the runner.","pos":[1211,1383],"source":" We did it like this so that the adapter could reserve all the ports it needs \nby binding and listening to them before dotnet test ran and tried to get ports for the runner."},{"content":"Once dotnet test starts, it sends a TestSession.Connected message to the adapter indicating that it is ready to receive messages.","pos":[1387,1516]},{"content":"It is possible to send an optional <bpt id=\"p1\">[</bpt>version check<ept id=\"p1\">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/ProtocolVersionMessage.cs)</ept> message with the adapter version of the protocol in it.","pos":[1520,1755],"source":"It is possible to send an optional \n[version check](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/ProtocolVersionMessage.cs) \nmessage with the adapter version of the protocol in it."},{"content":"Dotnet test will send back the version of the protocol that it supports.","pos":[1756,1828]},{"content":"All messages have the format described here: <bpt id=\"p1\">[</bpt>Message.cs<ept id=\"p1\">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/Message.cs)</ept>.","pos":[1830,2001],"source":"All messages have the format described here: \n[Message.cs](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/Message.cs)."},{"content":"The payload formats for each message is described in links to the classes used to serialize/deserialize the information in the description of the protocol.","pos":[2002,2158],"source":" \nThe payload formats for each message is described in links to the classes used to serialize/deserialize the information in the description of the protocol."},{"content":"Test Execution","pos":[2165,2179]},{"content":"Test Execution","pos":[2182,2196]},{"content":"After the optional version check, the adapter sends a TestExecution.GetTestRunnerProcessStartInfo, with the <bpt id=\"p1\">[</bpt>tests<ept id=\"p1\">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept> it wants to execute inside of it.","pos":[2249,2519],"source":"After the optional version check, the adapter sends a TestExecution.GetTestRunnerProcessStartInfo, with the \n[tests](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs) it wants to execute inside of it."},{"content":"Dotnet test sends back a FileName and Arguments inside a <bpt id=\"p1\">[</bpt>TestStartInfo<ept id=\"p1\">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/dotnet/commands/dotnet-test/TestStartInfo.cs)</ept> payload that the adapter can use to start the runner.","pos":[2520,2741],"source":" Dotnet test sends back a FileName and Arguments inside a [TestStartInfo](https://github.com/dotnet/cli/blob/rel/1.0.0/src/dotnet/commands/dotnet-test/TestStartInfo.cs) payload that the adapter can use to start the runner."},{"content":"In the past, we would send the list of tests to run as part of that argument, but we were actually going over the command line size limit for some test projects.","pos":[2742,2903]},{"content":"As part of the arguments, we send a port that the runner should connect to and for executing tests, a --wait-command flag, that indicates that the runner should connect to the port and wait for commands, instead of going ahead and executing the tests.","pos":[2909,3160]},{"content":"At this point, the adapter can launch the runner (and attach to it for debugging if it chooses to).","pos":[3164,3263]},{"content":"Once the runner starts, it sends dotnet test a TestRunner.WaitCommand message that indicates it is ready to receive commands, at which point dotnet test sends a TestRunner.Execute with the list of <bpt id=\"p1\">[</bpt>tests<ept id=\"p1\">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs)</ept> to run.","pos":[3267,3599],"source":"Once the runner starts, it sends dotnet test a TestRunner.WaitCommand message that indicates it is ready to receive commands, at which point dotnet test sends a TestRunner.Execute with the list of [tests](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs) to run."},{"content":"This bypasses the command line size limit described above.","pos":[3600,3658]},{"pos":[3662,3933],"content":"The runner then sends dotnet test (and it passes forward to the adapter) a TestExecution.TestStarted for each tests as they start with the <bpt id=\"p1\">[</bpt>test<ept id=\"p1\">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept> information inside of it.","source":"The runner then sends dotnet test (and it passes forward to the adapter) a TestExecution.TestStarted for each tests as they start with the [test](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs) information inside of it."},{"pos":[3937,4192],"content":"The runner also sends dotnet test (and it forwards to the adapter) a TestExecution.TestResult for each test with the <bpt id=\"p1\">[</bpt>individual result<ept id=\"p1\">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/TestResult.cs)</ept> of the test.","source":"The runner also sends dotnet test (and it forwards to the adapter) a TestExecution.TestResult for each test with the [individual result](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/TestResult.cs) of the test."},{"content":"After all tests finish, the runner sends a TestRunner.Completed message to dotnet test, which dotnet test sends as TestExecution.Completed to the adapter.","pos":[4196,4350]},{"content":"Once the adapter is done, it sends dotnet test a TestSession.Terminate which will cause dotnet test to shutdown.","pos":[4354,4466]},{"content":"Test discovery","pos":[4473,4487]},{"content":"Test discovery","pos":[4490,4504]},{"content":"After the optional version check, the adapter sends a TestDiscovery.Start message.","pos":[4558,4640]},{"content":"Because in this case, the adapter does not need to attach to the process, dotnet test will start the runner itself.","pos":[4641,4756]},{"content":"Also, since there is no long list of arguments to be passed to the runner, no --wait-command flag is needed to be passed to the runner.","pos":[4757,4892]},{"content":"dotnet test only passes a --list argument to the runner, which means the runner should not run the tests, just list them.","pos":[4893,5014]},{"pos":[5018,5239],"content":"The runner then sends dotnet test (and it passes forward to the adapter) a TestDiscovery.TestFound for each <bpt id=\"p1\">[</bpt>test<ept id=\"p1\">](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs)</ept> found.","source":"The runner then sends dotnet test (and it passes forward to the adapter) a TestDiscovery.TestFound for each [test](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs) found."},{"content":"After all tests are discovered, the runner sends a TestRunner.Completed message to dotnet test, which dotnet test sends as TestDiscovery.Completed to the adapter.","pos":[5243,5405]},{"content":"Once the adapter is done, it sends dotnet test a TestSession.Terminate which will cause dotnet test to shutdown.","pos":[5409,5521]}],"content":"---\ntitle: .NET Core CLI test communication protocol\ndescription: .NET Core CLI test communication protocol\nkeywords: .NET, .NET Core\nauthor: mairaw\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: 88cba792-3640-41de-b55d-00f575e9d5e2\n---\n\n#.NET Core CLI test communication protocol\n\n## Introduction\nAnytime you pass a port to dotnet test, the command will run in design time. That means that dotnet test will connect to that port\nusing TCP and will then exchange an established set of messages with whatever else is connected to that port. When this happens, the runner\nalso receives a new port that dotnet test will use to communicate with it. The reason why the runner also uses TCP to\ncommunicate with dotnet test is because in design mode, it is not sufficient to just output results to the console. The \ncommand needs to send the adapter structure messages containing the results of the test execution.\n\n### Communication protocol at design time.\n\n1. Because during design time, dotnet test connects to a port when it starts up, the adapter needs to be listening on \nthat port otherwise dotnet test will fail. We did it like this so that the adapter could reserve all the ports it needs \nby binding and listening to them before dotnet test ran and tried to get ports for the runner.\n2. Once dotnet test starts, it sends a TestSession.Connected message to the adapter indicating that it is ready to receive messages.\n3. It is possible to send an optional \n[version check](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/ProtocolVersionMessage.cs) \nmessage with the adapter version of the protocol in it. Dotnet test will send back the version of the protocol that it supports.\n\nAll messages have the format described here: \n[Message.cs](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/Message.cs). \nThe payload formats for each message is described in links to the classes used to serialize/deserialize the information in the description of the protocol.\n\n#### Test Execution\n![Test Execution](./media/test-protocol/dotnet-test-execute.png)\n\n1. After the optional version check, the adapter sends a TestExecution.GetTestRunnerProcessStartInfo, with the \n[tests](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs) it wants to execute inside of it. Dotnet test sends back a FileName and Arguments inside a [TestStartInfo](https://github.com/dotnet/cli/blob/rel/1.0.0/src/dotnet/commands/dotnet-test/TestStartInfo.cs) payload that the adapter can use to start the runner. In the past, we would send the list of tests to run as part of that argument, but we were actually going over the command line size limit for some test projects.\n  1. As part of the arguments, we send a port that the runner should connect to and for executing tests, a --wait-command flag, that indicates that the runner should connect to the port and wait for commands, instead of going ahead and executing the tests.\n2. At this point, the adapter can launch the runner (and attach to it for debugging if it chooses to).\n3. Once the runner starts, it sends dotnet test a TestRunner.WaitCommand message that indicates it is ready to receive commands, at which point dotnet test sends a TestRunner.Execute with the list of [tests](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Messages/RunTestsMessage.cs) to run. This bypasses the command line size limit described above.\n4. The runner then sends dotnet test (and it passes forward to the adapter) a TestExecution.TestStarted for each tests as they start with the [test](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs) information inside of it.\n5. The runner also sends dotnet test (and it forwards to the adapter) a TestExecution.TestResult for each test with the [individual result](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/TestResult.cs) of the test.\n6. After all tests finish, the runner sends a TestRunner.Completed message to dotnet test, which dotnet test sends as TestExecution.Completed to the adapter.\n7. Once the adapter is done, it sends dotnet test a TestSession.Terminate which will cause dotnet test to shutdown.\n\n#### Test discovery\n![Test discovery](./media/test-protocol/dotnet-test-discover.png)\n\n1. After the optional version check, the adapter sends a TestDiscovery.Start message. Because in this case, the adapter does not need to attach to the process, dotnet test will start the runner itself. Also, since there is no long list of arguments to be passed to the runner, no --wait-command flag is needed to be passed to the runner. dotnet test only passes a --list argument to the runner, which means the runner should not run the tests, just list them.\n2. The runner then sends dotnet test (and it passes forward to the adapter) a TestDiscovery.TestFound for each [test](https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.Extensions.Testing.Abstractions/Test.cs) found.\n3. After all tests are discovered, the runner sends a TestRunner.Completed message to dotnet test, which dotnet test sends as TestDiscovery.Completed to the adapter.\n4. Once the adapter is done, it sends dotnet test a TestSession.Terminate which will cause dotnet test to shutdown."}