{"nodes":[{"content":"How to: Add and Remove Items from a ConcurrentDictionary","pos":[12,68]},{"content":"How to: Add and Remove Items from a ConcurrentDictionary","pos":[84,140]},{"pos":[152,167],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":"How to: Add and Remove Items from a ConcurrentDictionary","pos":[371,427]},{"content":"This example shows how to add, retrieve, update, and remove items from a <bpt id=\"p1\">[</bpt>System.Collections.Concurrent.ConcurrentDictionary<ph id=\"ph1\">&amp;lt;</ph>TKey, TValue<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentDictionary-2)</ept>.","pos":[429,672],"source":"This example shows how to add, retrieve, update, and remove items from a [System.Collections.Concurrent.ConcurrentDictionary&lt;TKey, TValue&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentDictionary-2)."},{"content":"This collection class is a thread-safe implementation.","pos":[673,727]},{"content":"We recommend that you use it whenever multiple threads might be attempting to access the elements concurrently.","pos":[728,839]},{"content":"provides several convenience methods that make it unnecessary for code to first check whether a key exists before it attempts to add or remove data.","pos":[878,1026]},{"content":"The following table lists these convenience methods and describes when to use them.","pos":[1027,1110]},{"content":"Method","pos":[1112,1118]},{"content":"Use when...","pos":[1121,1132]},{"content":"You want to add a new value for a specified key and, if the key already exists, you want to replace its value.","pos":[1170,1280]},{"content":"You want to retrieve the existing value for a specified key and, if the key does not exist, you want to specify a key/value pair.","pos":[1294,1423]},{"pos":[1432,1461],"content":", <ph id=\"ph1\">`TryGetValue`</ph>, <ph id=\"ph2\">`TryUpdate`</ph>,","source":", `TryGetValue`, `TryUpdate`, "},{"content":"You want to add, get, update, or remove a key/value pair, and, if the key already exists or the attempt fails for any other reason, you want to take some alternative action.","pos":[1476,1649]},{"content":"Example","pos":[1654,1661]},{"content":"<bpt id=\"p1\">[</bpt>ConcurrentDictionary<ph id=\"ph1\">&amp;lt;</ph>TKey, TValue<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentDictionary-2)</ept> is designed for multithreaded scenarios.","pos":[12688,12868],"source":"[ConcurrentDictionary&lt;TKey, TValue&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentDictionary-2) is designed for multithreaded scenarios."},{"content":"You do not have to use locks in your code to add or remove items from the collection.","pos":[12869,12954]},{"content":"However, it is always possible for one thread to retrieve a value, and another thread to immediately update the collection by giving the same key a new value.","pos":[12955,13113]},{"content":"Also, although all methods of <ph id=\"ph1\">`ConcurrentDictionary&lt;TKey, TValue&gt;`</ph> are thread-safe, not all methods are atomic, specifically <ph id=\"ph2\">`GetOrAdd`</ph> and <ph id=\"ph3\">`AddOrUpdate`</ph>.","pos":[13115,13269],"source":"Also, although all methods of `ConcurrentDictionary<TKey, TValue>` are thread-safe, not all methods are atomic, specifically `GetOrAdd` and `AddOrUpdate`."},{"content":"The user delegate that is passed to these methods is invoked outside of the dictionary's internal lock.","pos":[13270,13373]},{"content":"(This is done to prevent unknown code from blocking all threads.) Therefore it is possible for this sequence of events to occur:","pos":[13374,13502]},{"pos":[13507,13615],"content":"threadA calls <ph id=\"ph1\">`GetOrAdd`</ph>, finds no item and creates a new item to Add by invoking the valueFactory delegate.","source":"threadA calls `GetOrAdd`, finds no item and creates a new item to Add by invoking the valueFactory delegate."},{"pos":[13620,13805],"content":"threadB calls <ph id=\"ph1\">`GetOrAdd`</ph> concurrently, its valueFactory delegate is invoked and it arrives at the internal lock before threadA, and so its new key-value pair is added to the dictionary.","source":"threadB calls `GetOrAdd` concurrently, its valueFactory delegate is invoked and it arrives at the internal lock before threadA, and so its new key-value pair is added to the dictionary."},{"content":"threadA's user delegate completes, and the thread arrives at the lock, but now sees that the item exists already","pos":[13810,13922]},{"content":"threadA performs a \"Get\", and returns the data that was previously added by threadB.","pos":[13927,14011]},{"content":"Therefore, it is not guaranteed that the data that is returned by <ph id=\"ph1\">`GetOrAdd`</ph> is the same data that was created by the thread's valueFactory.","pos":[14013,14153],"source":"Therefore, it is not guaranteed that the data that is returned by `GetOrAdd` is the same data that was created by the thread's valueFactory."},{"content":"A similar sequence of events can occur when <ph id=\"ph1\">`AddOrUpdate`</ph> is called.","pos":[14154,14222],"source":" A similar sequence of events can occur when `AddOrUpdate` is called."},{"content":"See Also","pos":[14228,14236]},{"content":"System.Collections.Concurrent","pos":[14239,14268]},{"content":"Thread-Safe Collections","pos":[14346,14369]}],"content":"---\ntitle: \"How to: Add and Remove Items from a ConcurrentDictionary\"\ndescription: \"How to: Add and Remove Items from a ConcurrentDictionary\"\nkeywords: .NET, .NET Core\nauthor: mairaw\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: b7c04a5f-a8e6-42ae-8c84-0e1ae18896eb\n---\n\n# How to: Add and Remove Items from a ConcurrentDictionary\n\nThis example shows how to add, retrieve, update, and remove items from a [System.Collections.Concurrent.ConcurrentDictionary&lt;TKey, TValue&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentDictionary-2). This collection class is a thread-safe implementation. We recommend that you use it whenever multiple threads might be attempting to access the elements concurrently.\n\n`ConcurrentDictionary<TKey, TValue>` provides several convenience methods that make it unnecessary for code to first check whether a key exists before it attempts to add or remove data. The following table lists these convenience methods and describes when to use them.\n\nMethod | Use when...\n------ | -----------\n`AddOrUpdate` | You want to add a new value for a specified key and, if the key already exists, you want to replace its value.\n`GetOrAdd` | You want to retrieve the existing value for a specified key and, if the key does not exist, you want to specify a key/value pair.\n`TryAdd`, `TryGetValue`, `TryUpdate`, `TryRemove` | You want to add, get, update, or remove a key/value pair, and, if the key already exists or the attempt fails for any other reason, you want to take some alternative action.\n\n## Example\n\n```csharp\nnamespace DictionaryHowTo\n{\n    using System;\n    using System.Collections.Concurrent;\n    using System.Collections.Generic;\n    using System.Linq;\n    using System.Text;\n    using System.Threading;\n    using System.Threading.Tasks;\n\n    // The type of the Value to store in the dictionary:\n    class CityInfo : IEqualityComparer<CityInfo>\n    {\n        public string Name { get; set; }\n        public DateTime lastQueryDate { get; set; }\n        public decimal Longitude { get; set; }\n        public decimal Latitude { get; set; }\n        public int[] RecentHighTemperatures { get; set; }\n\n        public CityInfo(string name, decimal longitude, decimal latitude, int[] temps)\n        {\n            Name = name;\n            lastQueryDate = DateTime.Now;\n            Longitude = longitude;\n            Latitude = latitude;\n            RecentHighTemperatures = temps;\n        }\n\n        public CityInfo()\n        {\n        }\n\n        public CityInfo(string key)\n        {\n            Name = key;\n            // MaxValue means \"not initialized\"\n            Longitude = Decimal.MaxValue;\n            Latitude = Decimal.MaxValue;\n            lastQueryDate = DateTime.Now;\n            RecentHighTemperatures = new int[] { 0 };\n\n        }\n        public bool Equals(CityInfo x, CityInfo y)\n        {\n            return x.Name == y.Name && x.Longitude == y.Longitude && x.Latitude == y.Latitude;\n        }\n\n        public int GetHashCode(CityInfo obj)\n        {\n            CityInfo ci = (CityInfo)obj;\n            return ci.Name.GetHashCode();\n        }\n    }\n\n    class Program\n    {\n        // Create a new concurrent dictionary.\n        static ConcurrentDictionary<string, CityInfo> cities = new ConcurrentDictionary<string, CityInfo>();\n\n        static void Main(string[] args)\n        {\n            CityInfo[] data = \n            {\n                new CityInfo(){ Name = \"Boston\", Latitude = 42.358769M, Longitude = -71.057806M, RecentHighTemperatures = new int[] {56, 51, 52, 58, 65, 56,53}},\n                new CityInfo(){ Name = \"Miami\", Latitude = 25.780833M, Longitude = -80.195556M, RecentHighTemperatures = new int[] {86,87,88,87,85,85,86}},\n                new CityInfo(){ Name = \"Los Angeles\", Latitude = 34.05M, Longitude = -118.25M, RecentHighTemperatures =   new int[] {67,68,69,73,79,78,78}},\n                new CityInfo(){ Name = \"Seattle\", Latitude = 47.609722M, Longitude =  -122.333056M, RecentHighTemperatures =   new int[] {49,50,53,47,52,52,51}},\n                new CityInfo(){ Name = \"Toronto\", Latitude = 43.716589M, Longitude = -79.340686M, RecentHighTemperatures =   new int[] {53,57, 51,52,56,55,50}},\n                new CityInfo(){ Name = \"Mexico City\", Latitude = 19.432736M, Longitude = -99.133253M, RecentHighTemperatures =   new int[] {72,68,73,77,76,74,73}},\n                new CityInfo(){ Name = \"Rio de Janiero\", Latitude = -22.908333M, Longitude = -43.196389M, RecentHighTemperatures =   new int[] {72,68,73,82,84,78,84}},\n                new CityInfo(){ Name = \"Quito\", Latitude = -0.25M, Longitude = -78.583333M, RecentHighTemperatures =   new int[] {71,69,70,66,65,64,61}}\n            };\n\n            // Add some key/value pairs from multiple threads.\n            Task[] tasks = new Task[2];\n\n            tasks[0] = Task.Run(() =>\n            {\n                for (int i = 0; i < 2; i++)\n                {\n                    if (cities.TryAdd(data[i].Name, data[i]))\n                        Console.WriteLine(\"Added {0} on thread {1}\", data[i],\n                            Thread.CurrentThread.ManagedThreadId);\n                    else \n                        Console.WriteLine(\"Could not add {0}\", data[i]);\n                }\n            });\n\n            tasks[1] = Task.Run(() =>\n            {\n                for (int i = 2; i < data.Length; i++)\n                {\n                    if (cities.TryAdd(data[i].Name, data[i]))\n                        Console.WriteLine(\"Added {0} on thread {1}\", data[i],\n                            Thread.CurrentThread.ManagedThreadId);\n                    else\n                        Console.WriteLine(\"Could not add {0}\", data[i]);\n                }\n            });\n\n            // Output results so far.\n            Task.WaitAll(tasks);\n\n            // Enumerate collection from the app main thread.\n            // Note that ConcurrentDictionary is the one concurrent collection\n            // that does not support thread-safe enumeration.\n            foreach (var city in cities)\n            {\n                Console.WriteLine(\"{0} has been added.\", city.Key);\n            }\n\n            AddOrUpdateWithoutRetrieving();\n            RetrieveValueOrAdd();\n            RetrieveAndUpdateOrAdd();  \n\n            Console.WriteLine(\"Press any key.\");\n            Console.ReadKey();\n        }\n\n        // This method shows how to add key-value pairs to the dictionary\n        // in scenarios where the key might already exist.\n        private static void AddOrUpdateWithoutRetrieving()\n        {\n            // Sometime later. We receive new data from some source.\n            CityInfo ci = new CityInfo() { Name = \"Toronto\",\n                                            Latitude = 43.716589M,\n                                            Longitude = -79.340686M,\n                                            RecentHighTemperatures = new int[] { 54, 59, 67, 82, 87, 55, -14 } };\n\n            // Try to add data. If it doesn't exist, the object ci is added. If it does\n            // already exist, update existingVal according to the custom logic in the \n            // delegate.\n            cities.AddOrUpdate(ci.Name, ci,\n                (key, existingVal) =>\n                {\n                    // If this delegate is invoked, then the key already exists.\n                    // Here we make sure the city really is the same city we already have.\n                    // (Support for multiple cities of the same name is left as an exercise for the reader.)\n                    if (ci != existingVal)\n                        throw new ArgumentException(\"Duplicate city names are not allowed: {0}.\", ci.Name);\n\n                    // The only updatable fields are the temerature array and lastQueryDate.\n                    existingVal.lastQueryDate = DateTime.Now;\n                    existingVal.RecentHighTemperatures = ci.RecentHighTemperatures;\n                    return existingVal;\n                });\n\n            // Verify that the dictionary contains the new or updated data.\n            Console.Write(\"Most recent high temperatures for {0} are: \", cities[ci.Name].Name);\n            int[] temps = cities[ci.Name].RecentHighTemperatures;\n            foreach (var temp in temps) Console.Write(\"{0}, \", temp);\n            Console.WriteLine();\n        }\n\n        // This method shows how to use data and ensure that it has been\n        // added to the dictionary.\n        private static void RetrieveValueOrAdd()\n        {\n            string searchKey = \"Caracas\";\n            CityInfo retrievedValue = null;\n\n            try\n            {\n                retrievedValue = cities.GetOrAdd(searchKey, GetDataForCity(searchKey));\n            }\n            catch (ArgumentException e)\n            {\n                Console.WriteLine(e.Message);\n            }\n\n            // Use the data.\n            if (retrievedValue != null)\n            {\n                Console.Write(\"Most recent high temperatures for {0} are: \", retrievedValue.Name);\n                int[] temps = cities[retrievedValue.Name].RecentHighTemperatures;\n                foreach (var temp in temps) Console.Write(\"{0}, \", temp);\n            }\n            Console.WriteLine();\n        }\n\n\n\n\n        // This method shows how to retrieve a value from the dictionary,\n        // when you expect that the key/value pair already exists,\n        // and then possibly update the dictionary with a new value for the key.\n        private static void RetrieveAndUpdateOrAdd()\n        {\n            CityInfo retrievedValue;\n            string searchKey = \"Buenos Aires\";\n\n            if (cities.TryGetValue(searchKey, out retrievedValue))\n            {\n                // use the data\n                Console.Write(\"Most recent high temperatures for {0} are: \", retrievedValue.Name);\n                int[] temps = retrievedValue.RecentHighTemperatures;\n                foreach (var temp in temps) Console.Write(\"{0}, \", temp);\n\n                // Make a copy of the data. Our object will update its lastQueryDate automatically.\n                CityInfo newValue = new CityInfo(retrievedValue.Name,\n                                                retrievedValue.Longitude,\n                                                retrievedValue.Latitude,\n                                                retrievedValue.RecentHighTemperatures);\n\n                // Replace the old value with the new value.\n                if (!cities.TryUpdate(searchKey, retrievedValue, newValue))\n                {\n                    //The data was not updated. Log error, throw exception, etc.\n                    Console.WriteLine(\"Could not update {0}\", retrievedValue.Name);\n                }\n            }\n            else\n            {\n                // Add the new key and value. Here we call a method to retrieve\n                // the data. Another option is to add a default value here and \n                // update with real data later on some other thread.\n                CityInfo newValue = GetDataForCity(searchKey);\n                if( cities.TryAdd(searchKey, newValue))\n                {\n                    // use the data\n                    Console.Write(\"Most recent high temperatures for {0} are: \", newValue.Name);\n                    int[] temps = newValue.RecentHighTemperatures;\n                    foreach (var temp in temps) Console.Write(\"{0}, \", temp);\n                }\n                else\n                    Console.WriteLine(\"Unable to add data for {0}\", searchKey);\n            }\n        }\n\n        //Assume this method knows how to find long/lat/temp info for any specified city.\n        static CityInfo GetDataForCity(string name)\n        {\n            // Real implementation left as exercise for the reader.\n            if (String.CompareOrdinal(name, \"Caracas\") == 0)\n                return new CityInfo() { Name = \"Caracas\", \n                                        Longitude = 10.5M, \n                                        Latitude = -66.916667M,\n                                        RecentHighTemperatures = new int[] { 91, 89, 91, 91, 87, 90, 91 } };\n            else if (String.CompareOrdinal(name, \"Buenos Aires\") == 0)\n                return new CityInfo() { Name = \"Buenos Aires\", \n                                        Longitude = -34.61M, \n                                        Latitude = -58.369997M, \n                                        RecentHighTemperatures = new int[] { 80, 86, 89, 91, 84, 86, 88 } };\n            else\n                throw new ArgumentException(\"Cannot find any data for {0}\", name);\n        }\n    }\n}\n\n```\n[ConcurrentDictionary&lt;TKey, TValue&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentDictionary-2) is designed for multithreaded scenarios. You do not have to use locks in your code to add or remove items from the collection. However, it is always possible for one thread to retrieve a value, and another thread to immediately update the collection by giving the same key a new value.\n\nAlso, although all methods of `ConcurrentDictionary<TKey, TValue>` are thread-safe, not all methods are atomic, specifically `GetOrAdd` and `AddOrUpdate`. The user delegate that is passed to these methods is invoked outside of the dictionary's internal lock. (This is done to prevent unknown code from blocking all threads.) Therefore it is possible for this sequence of events to occur:\n\n1. threadA calls `GetOrAdd`, finds no item and creates a new item to Add by invoking the valueFactory delegate.\n\n2. threadB calls `GetOrAdd` concurrently, its valueFactory delegate is invoked and it arrives at the internal lock before threadA, and so its new key-value pair is added to the dictionary.\n\n3. threadA's user delegate completes, and the thread arrives at the lock, but now sees that the item exists already\n\n4. threadA performs a \"Get\", and returns the data that was previously added by threadB.\n\nTherefore, it is not guaranteed that the data that is returned by `GetOrAdd` is the same data that was created by the thread's valueFactory. A similar sequence of events can occur when `AddOrUpdate` is called. \n\n## See Also\n\n[System.Collections.Concurrent](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)\n\n[Thread-Safe Collections](index.md)\n\n"}