{"nodes":[{"pos":[11,20],"content":"Iterators","needQuote":true,"nodes":[{"content":"Iterators","pos":[0,9]}]},{"pos":[34,43],"content":"Iterators","needQuote":true,"nodes":[{"content":"Iterators","pos":[0,9]}]},{"pos":[54,69],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":"Iterators","pos":[277,286]},{"content":"Almost every program you write will have some need to iterate over a collection.","pos":[288,368],"source":"Almost every program you write will have some need to iterate\nover a collection."},{"content":"You'll write code that examines every item in a collection.","pos":[369,428],"source":" You'll write code that examines every item in\na collection."},{"content":"You'll also create iterator methods which are methods that produces an iterator for the elements of that class.","pos":[431,542],"source":"You'll also create iterator methods which are methods that produces an\niterator for the elements of that class."},{"content":"These can be used for:","pos":[543,565]},{"content":"Performing an action on each item in a collection.","pos":[569,619]},{"content":"Enumerating a custom collection.","pos":[622,654]},{"pos":[657,702],"content":"Extending <bpt id=\"p1\">[</bpt>LINQ<ept id=\"p1\">](linq.md)</ept> or other libraries.","source":"Extending [LINQ](linq.md) or other libraries."},{"pos":[705,784],"content":"Creating a data pipeline where data flows efficiently through iterator methods.","source":"Creating a data pipeline where data flows efficiently through iterator\nmethods."},{"content":"The C# language provides features for both these scenarios.","pos":[786,845],"source":"The C# language provides\nfeatures for both these scenarios."},{"content":"This article provides an overview of those features.","pos":[846,898],"source":" This article provides an overview\nof those features."},{"content":"Iterating with foreach","pos":[903,925]},{"pos":[927,1083],"content":"Enumerating a collection is simple: The <ph id=\"ph1\">`foreach`</ph> keyword enumerates a collection, executing the embedded statement once for each element in the collection:","source":"Enumerating a collection is simple: The `foreach` keyword enumerates\na collection, executing the embedded statement once for each element\nin the collection:"},{"content":"That's all there is to it.","pos":[1173,1199]},{"content":"To iterate over all the contents of a collection, the <ph id=\"ph1\">`foreach`</ph> statement is all you need.","pos":[1200,1290],"source":" To iterate over all the contents of a collection,\nthe `foreach` statement is all you need."},{"content":"The <ph id=\"ph1\">`foreach`</ph> statement isn't magic, though.","pos":[1291,1335],"source":" The `foreach` statement isn't magic,\nthough."},{"content":"It relies on two generic interfaces defined in the .NET core library in order to generate the code necessary to iterate a collection: <ph id=\"ph1\">`IEnumerable&lt;T&gt;`</ph> and <ph id=\"ph2\">`IEnumerator&lt;T&gt;`</ph>.","pos":[1336,1508],"source":" It relies on two generic interfaces defined in the .NET core library in order\nto generate the code necessary to iterate a collection: `IEnumerable<T>` and\n`IEnumerator<T>`."},{"content":"This mechanism is explained in more detail below.","pos":[1509,1558]},{"content":"Both of these interfaces also have non-generic counterparts: <ph id=\"ph1\">`IEnumerable`</ph> and <ph id=\"ph2\">`IEnumerator`</ph>.","pos":[1560,1654],"source":"Both of these interfaces also have non-generic counterparts: `IEnumerable` and \n`IEnumerator`."},{"content":"The <bpt id=\"p1\">[</bpt>generic<ept id=\"p1\">](generics.md)</ept> versions are preferred for modern code.","pos":[1655,1721],"source":" The [generic](generics.md) versions are preferred for modern code."},{"content":"Enumeration sources with iterator methods","pos":[1726,1767]},{"content":"Another great feature of the C# language enables you to build methods that create a source for an enumeration.","pos":[1769,1879],"source":"Another great feature of the C# language enables you to build methods that create\na source for an enumeration."},{"content":"These are referred to as <bpt id=\"p1\">*</bpt>iterator methods<ept id=\"p1\">*</ept>.","pos":[1880,1924],"source":" These are referred to as *iterator methods*."},{"content":"An iterator method defines how to generate the objects in a sequence when requested.","pos":[1925,2009],"source":" An iterator\nmethod defines how to generate the objects in a sequence when requested."},{"content":"You use the <ph id=\"ph1\">`yield return`</ph> contextual keywords to define an iterator method.","pos":[2010,2086],"source":" You\nuse the `yield return` contextual keywords to define an iterator method."},{"content":"You could write this method to produce the sequence of integers from 0 through 9:","pos":[2089,2170]},{"content":"The code above shows distinct <ph id=\"ph1\">`yield return`</ph> statements to highlight the fact that you can use multiple discrete <ph id=\"ph2\">`yield return`</ph> statements in an iterator method.","pos":[2435,2596],"source":"The code above shows distinct `yield return` statements to highlight the fact that\nyou can use multiple discrete `yield return` statements in an iterator method."},{"content":"You can (and often do) use other language constructs to simplify the code of an iterator method.","pos":[2597,2693],"source":"\nYou can (and often do) use other language constructs to simplify the code of an\niterator method."},{"content":"The method definition below produces the exact same sequence of numbers:","pos":[2694,2766],"source":" The method definition below produces the exact same sequence\nof numbers:"},{"content":"You don't have to decide one or the other.","pos":[2903,2945]},{"content":"You can have as many <ph id=\"ph1\">`yield return`</ph> statements as necessary to meet the needs of your method:","pos":[2946,3039],"source":" You can have as many `yield return`\nstatements as necessary to meet the needs of your method:"},{"content":"That's the basic syntax.","pos":[3282,3306]},{"content":"Let's consider a real world example where you would write an iterator method.","pos":[3307,3384],"source":" Let's consider a real world example where you would\nwrite an iterator method."},{"content":"Imagine you're on an IoT project and the device sensors generate a very large stream of data.","pos":[3385,3478],"source":" Imagine you're on an IoT project and the device\nsensors generate a very large stream of data."},{"content":"To get a feel for the data, you might write a method that samples every Nth data element.","pos":[3479,3568],"source":" To get a feel for the data, you\nmight write a method that samples every Nth data element."},{"content":"This small iterator method does the trick:","pos":[3569,3611],"source":" This small iterator\nmethod does the trick:"},{"content":"There is one important restriction on iterator methods: you can't have both a <ph id=\"ph1\">`return`</ph> statement and a <ph id=\"ph2\">`yield return`</ph> statement in the same method.","pos":[3852,3999],"source":"There is one important restriction on iterator methods: you can't have both a\n`return` statement and a `yield return` statement in the same method."},{"content":"The following will not compile:","pos":[4000,4031],"source":" The following\nwill not compile:"},{"content":"This restriction normally isn't a problem.","pos":[4341,4383]},{"content":"You have a choice of either using <ph id=\"ph1\">`yield return`</ph> throughout the method, or separating the original method into multiple methods, some using <ph id=\"ph2\">`return`</ph>, and some using <ph id=\"ph3\">`yield return`</ph>.","pos":[4384,4564],"source":" You have a choice of either using\n`yield return` throughout the method, or separating the original method into\nmultiple methods, some using `return`, and some using `yield return`."},{"pos":[4566,4639],"content":"You can modify the last method slightly to use <ph id=\"ph1\">`yield return`</ph> everywhere:","source":"You can modify the last method slightly to use `yield return` everywhere:"},{"content":"Sometimes, the right answer is to split an iterator method into two different methods.","pos":[4949,5035],"source":"Sometimes, the right answer is to split an iterator method into two different\nmethods."},{"content":"One that uses <ph id=\"ph1\">`return`</ph>, and a second that uses <ph id=\"ph2\">`yield return`</ph>.","pos":[5036,5098],"source":" One that uses `return`, and a second that uses `yield return`."},{"content":"Consider a situation where you might want to return an empty collection, or the first 5 odd numbers, based on a boolean argument.","pos":[5099,5228],"source":" Consider\na situation where you might want to return an empty collection, or the first 5\nodd numbers, based on a boolean argument."},{"content":"You could write that as these two methods:","pos":[5229,5271],"source":" You could write that as these two\nmethods:"},{"content":"Look at the methods above.","pos":[5610,5636]},{"content":"The first uses the standard <ph id=\"ph1\">`return`</ph> statement to return either an empy collection, or the iterator created by the second method.","pos":[5637,5766],"source":" The first uses the standard `return` statement to return\neither an empy collection, or the iterator created by the second method."},{"content":"The second method uses the <ph id=\"ph1\">`yield return`</ph> statement to create the requested sequence.","pos":[5767,5852],"source":" The second\nmethod uses the `yield return` statement to create the requested sequence."},{"pos":[5857,5873],"content":"Deeper Dive into"},{"content":"The <ph id=\"ph1\">`foreach`</ph> statement expands into a standard idiom that uses the <ph id=\"ph2\">`IEnumable&lt;T&gt;`</ph> and <ph id=\"ph3\">`IEnumerator&lt;T&gt;`</ph> interfaces to iterate across all elements of a colleciton.","pos":[5885,6047],"source":"The `foreach` statement expands into a standard idiom that uses the\n`IEnumable<T>` and `IEnumerator<T>` interfaces to iterate across all\nelements of a colleciton."},{"content":"It also  minimizes errors developers make by not properly managing resources.","pos":[6048,6125],"source":" It also  minimizes errors developers make\nby not properly managing resources."},{"pos":[6128,6239],"content":"The compiler translates the <ph id=\"ph1\">`foreach`</ph> loop shown in the first example into something similar to this construct:","source":"The compiler translates the `foreach` loop shown in the first\nexample into something similar to this construct:"},{"content":"The construct above represents the code generated by the C# compiler as of version 5 and above.","pos":[6419,6514],"source":"The construct above represents the code generated by the C# compiler as of\nversion 5 and above."},{"content":"Prior to version 5, the <ph id=\"ph1\">`item`</ph> variable had a different scope:","pos":[6515,6577],"source":" Prior to version 5, the `item` variable had a different scope:"},{"content":"This was changed because the earlier behavior could lead to subtle and hard to diagnose bugs involving lambda expressions.","pos":[6806,6928],"source":"This was changed because the earlier behavior could lead to subtle and hard\nto diagnose bugs involving lambda expressions."},{"content":"See the section on <bpt id=\"p1\">[</bpt>lambda expressions<ept id=\"p1\">](lambda-expressions.md)</ept> for more information.","pos":[6929,7013],"source":" See the section on\n[lambda expressions](lambda-expressions.md) for more information."},{"content":"The exact code generated by the compiler is somewhat more complicated, and handles situations where the object returned by <ph id=\"ph1\">`GetEnumerator()`</ph> implements the <ph id=\"ph2\">`IDisposable`</ph> interface.","pos":[7016,7196],"source":"The exact code generated by the compiler is somewhat more complicated, and\nhandles situations where the object returned by `GetEnumerator()` implements\nthe `IDisposable` interface."},{"content":"The full expansion generates code more like this:","pos":[7197,7246]},{"content":"The manner in which the enumerator is disposed of depends on the characteristics of the type of <ph id=\"ph1\">`enumerator`</ph>.","pos":[7537,7646],"source":"The manner in which the enumerator is disposed of depends on the characteristics of\nthe type of `enumerator`."},{"content":"In the general case, the <ph id=\"ph1\">`finally`</ph> clause expands to:","pos":[7647,7700],"source":" In the general case, the `finally` clause expands to:"},{"pos":[7770,7955],"content":"However, if the type of <ph id=\"ph1\">`enumerator`</ph> is a sealed type and there is no implicit conversion from the type of <ph id=\"ph2\">`enumerator`</ph> to <ph id=\"ph3\">`IDisposable`</ph>, the <ph id=\"ph4\">`finally`</ph> clause expands to an empty block:","source":"However, if the type of `enumerator` is a sealed type and there is no implicit\nconversion from the type of `enumerator` to `IDisposable`, the `finally` clause\nexpands to an empty block:"},{"pos":[7981,8143],"content":"If there is an implicit conversion from the type of <ph id=\"ph1\">`enumerator`</ph> to <ph id=\"ph2\">`IDisposable`</ph>, and <ph id=\"ph3\">`enumerator`</ph> is a non-nullable value type, the <ph id=\"ph4\">`finally`</ph> clause expands to:","source":"If there is an implicit conversion from the type of `enumerator` to `IDisposable`,\nand `enumerator` is a non-nullable value type, the `finally` clause expands to:"},{"content":"Thankfully, you don't need to remember all these details.","pos":[8210,8267]},{"content":"The <ph id=\"ph1\">`foreach`</ph> statement handles all those nuances for you.","pos":[8268,8326],"source":" The `foreach` statement\nhandles all those nuances for you."},{"content":"The compiler will generate the correct code for any of these constructs.","pos":[8327,8399],"source":" The compiler will generate the correct code for\nany of these constructs."}],"content":"---\ntitle: Iterators\ndescription: Iterators\nkeywords: .NET, .NET Core\nauthor: BillWagner\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: 5cf36f45-f91a-4fca-a0b7-87f233e108e9\n---\n\n# Iterators\n\nAlmost every program you write will have some need to iterate\nover a collection. You'll write code that examines every item in\na collection. \n\nYou'll also create iterator methods which are methods that produces an\niterator for the elements of that class. These can be used for:\n\n+ Performing an action on each item in a collection.\n+ Enumerating a custom collection.\n+ Extending [LINQ](linq.md) or other libraries.\n+ Creating a data pipeline where data flows efficiently through iterator\nmethods.\n\nThe C# language provides\nfeatures for both these scenarios. This article provides an overview\nof those features.\n\n## Iterating with foreach\n\nEnumerating a collection is simple: The `foreach` keyword enumerates\na collection, executing the embedded statement once for each element\nin the collection:\n \n```cs\nforeach (var item in collection)\n{\n   Console.WriteLine(item.ToString());\n}\n```\n\nThat's all there is to it. To iterate over all the contents of a collection,\nthe `foreach` statement is all you need. The `foreach` statement isn't magic,\nthough. It relies on two generic interfaces defined in the .NET core library in order\nto generate the code necessary to iterate a collection: `IEnumerable<T>` and\n`IEnumerator<T>`. This mechanism is explained in more detail below.\n\nBoth of these interfaces also have non-generic counterparts: `IEnumerable` and \n`IEnumerator`. The [generic](generics.md) versions are preferred for modern code.\n\n## Enumeration sources with iterator methods\n\nAnother great feature of the C# language enables you to build methods that create\na source for an enumeration. These are referred to as *iterator methods*. An iterator\nmethod defines how to generate the objects in a sequence when requested. You\nuse the `yield return` contextual keywords to define an iterator method. \n\nYou could write this method to produce the sequence of integers from 0 through 9:\n\n```cs\npublic IEnumerable<int> GetSingleDigitNumbers()\n{\n    yield return 0;\n    yield return 1;\n    yield return 2;\n    yield return 3;\n    yield return 4;\n    yield return 5;\n    yield return 6;\n    yield return 7;\n    yield return 8;\n    yield return 9;\n}\n```\n\nThe code above shows distinct `yield return` statements to highlight the fact that\nyou can use multiple discrete `yield return` statements in an iterator method.\nYou can (and often do) use other language constructs to simplify the code of an\niterator method. The method definition below produces the exact same sequence\nof numbers:\n\n```cs\npublic IEnumerable<int> GetSingleDigitNumbers()\n{\n    int index = 0;\n    while (index++ < 10)\n        yield return index;\n}\n```\n\nYou don't have to decide one or the other. You can have as many `yield return`\nstatements as necessary to meet the needs of your method:\n\n```cs\npublic IEnumerable<int> GetSingleDigitNumbers()\n{\n    int index = 0;\n    while (index++ < 10)\n        yield return index;\n        \n    yield return 50;\n    \n    index = 100;\n    while (index++ < 110)\n        yield return index;\n}\n```\n\nThat's the basic syntax. Let's consider a real world example where you would\nwrite an iterator method. Imagine you're on an IoT project and the device\nsensors generate a very large stream of data. To get a feel for the data, you\nmight write a method that samples every Nth data element. This small iterator\nmethod does the trick:\n\n```cs\npublic static IEnumerable<T> Sample(this IEnumerable<T> sourceSequence, int interval)\n{\n    int index = 0;\n    foreach (T item in sourceSequence)\n    {\n        if (index++ % interval == 0)\n            yield return item;\n    }\n}\n```\n\nThere is one important restriction on iterator methods: you can't have both a\n`return` statement and a `yield return` statement in the same method. The following\nwill not compile:\n\n```cs\npublic IEnumerable<int> GetSingleDigitNumbers()\n{\n    int index = 0;\n    while (index++ < 10)\n        yield return index;\n        \n    yield return 50;\n   \n    // generates a compile time error: \n    var items = new int[] {100, 101, 102, 103, 104, 105, 106, 107, 108, 109 };\n    return items;  \n}\n```\n\nThis restriction normally isn't a problem. You have a choice of either using\n`yield return` throughout the method, or separating the original method into\nmultiple methods, some using `return`, and some using `yield return`.\n\nYou can modify the last method slightly to use `yield return` everywhere:\n\n```cs\npublic IEnumerable<int> GetSingleDigitNumbers()\n{\n    int index = 0;\n    while (index++ < 10)\n        yield return index;\n        \n    yield return 50;\n   \n    var items = new int[] {100, 101, 102, 103, 104, 105, 106, 107, 108, 109 };\n    foreach (var item in items)\n        yield return item;\n}\n```\n \nSometimes, the right answer is to split an iterator method into two different\nmethods. One that uses `return`, and a second that uses `yield return`. Consider\na situation where you might want to return an empty collection, or the first 5\nodd numbers, based on a boolean argument. You could write that as these two\nmethods:\n\n```cs\npublic IEnumerable<int> GetSingleDigitOddNumbers(bool getCollection)\n{\n    if (getCollection == false)\n        return new int[0];\n    else\n        return IteratorMethod();\n}\n\nprivate IEnumerable<int> IteratorMethod()\n{\n    int index = 0;\n    while (index++ < 10)\n        if (index % 2 == 1)\n            yield return index;\n}\n```\n \nLook at the methods above. The first uses the standard `return` statement to return\neither an empy collection, or the iterator created by the second method. The second\nmethod uses the `yield return` statement to create the requested sequence.\n\n## Deeper Dive into `foreach`\n\nThe `foreach` statement expands into a standard idiom that uses the\n`IEnumable<T>` and `IEnumerator<T>` interfaces to iterate across all\nelements of a colleciton. It also  minimizes errors developers make\nby not properly managing resources. \n\nThe compiler translates the `foreach` loop shown in the first\nexample into something similar to this construct:\n\n```cs\nIEnumerator<int> enumerator = collection.GetEnumerator();\nwhile (enumerator.MoveNext())\n{\n    var item = enumerator.Current;\n    Console.WriteLine(item.ToString());\n}\n```\n\nThe construct above represents the code generated by the C# compiler as of\nversion 5 and above. Prior to version 5, the `item` variable had a different scope:\n\n```cs\n// C# versions 1 through 4:\nIEnumerator<int> enumerator = collection.GetEnumerator();\nint item = default(int);\nwhile (enumerator.MoveNext())\n{\n    item = enumerator.Current;\n    Console.WriteLine(item.ToString());\n}\n```\n\nThis was changed because the earlier behavior could lead to subtle and hard\nto diagnose bugs involving lambda expressions. See the section on\n[lambda expressions](lambda-expressions.md) for more information. \n\nThe exact code generated by the compiler is somewhat more complicated, and\nhandles situations where the object returned by `GetEnumerator()` implements\nthe `IDisposable` interface. The full expansion generates code more like this:\n\n```cs\n{\n    var enumerator = collection.GetEnumerator();\n    try \n    {\n        while (enumerator.MoveNext())\n        {\n            var item = enumerator.Current;\n            Console.WriteLine(item.ToString());\n        }\n    } finally \n    {\n        // dispose of enumerator.\n    }\n}\n```\n\nThe manner in which the enumerator is disposed of depends on the characteristics of\nthe type of `enumerator`. In the general case, the `finally` clause expands to:\n\n```cs\nfinally \n{\n   (enumerator as IDisposable)?.Dispose();\n} \n```\n\nHowever, if the type of `enumerator` is a sealed type and there is no implicit\nconversion from the type of `enumerator` to `IDisposable`, the `finally` clause\nexpands to an empty block:\n```cs\nfinally \n{\n} \n```\n\nIf there is an implicit conversion from the type of `enumerator` to `IDisposable`,\nand `enumerator` is a non-nullable value type, the `finally` clause expands to:\n\n```cs\nfinally \n{\n   ((IDisposable)enumerator).Dispose();\n} \n```\n\nThankfully, you don't need to remember all these details. The `foreach` statement\nhandles all those nuances for you. The compiler will generate the correct code for\nany of these constructs. \n\n\n"}