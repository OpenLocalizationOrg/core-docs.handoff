{"nodes":[{"pos":[11,28],"content":"Working with LINQ","needQuote":true,"nodes":[{"content":"Working with LINQ","pos":[0,17]}]},{"pos":[42,59],"content":"Working with LINQ","needQuote":true,"nodes":[{"content":"Working with LINQ","pos":[0,17]}]},{"pos":[70,85],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":"Working with LINQ","pos":[293,310]},{"content":"Introduction","pos":[315,327]},{"content":"This tutorial teaches you a number of features in .NET Core and the C# language.","pos":[328,408]},{"content":"You’ll learn:","pos":[409,422]},{"content":"How to generate sequences with LINQ","pos":[428,463]},{"content":"How to write methods that can be easily used in LINQ queries.","pos":[468,529]},{"content":"How to distinguish between eager and lazy evaluation.","pos":[534,587]},{"content":"You'll learn these techniques by building an application that demonstrates one of the basic skills of any magician: the <bpt id=\"p1\">[</bpt>faro shuffle<ept id=\"p1\">](https://en.wikipedia.org/wiki/Faro_shuffle)</ept>.","pos":[589,768],"source":"You'll learn these techniques by building an application that demonstrates\none of the basic skills of any magician: the\n[faro shuffle](https://en.wikipedia.org/wiki/Faro_shuffle)."},{"content":"Briefly, a faro shuffle is a technique where you split a card deck exactly in half, then the shuffle interleaves each one card from each half to rebuild the original deck.","pos":[769,940],"source":" Briefly,\na faro shuffle is a technique where you split a card deck exactly in half,\nthen the shuffle interleaves each one card from each half to rebuild the\noriginal deck."},{"pos":[942,1070],"content":"Magicians use this technique because every card is in a known location after each shuffle, and the order is a repeating pattern.","source":"Magicians use this technique because every card is in a known location\nafter each shuffle, and the order is a repeating pattern."},{"content":"For our purposes, it is a light hearted look at manipulating sequences of data.","pos":[1073,1152],"source":"For our purposes, it is a light hearted look at manipulating sequences\nof data."},{"content":"The application you'll build will construct a card deck, and then perform a sequence of shuffles, writing the sequence out each time.","pos":[1153,1286],"source":" The application you'll build will construct a card deck, and\nthen perform a sequence of shuffles, writing the sequence out each time."},{"content":"You'll also compare the updated order to the original order.","pos":[1287,1347],"source":"\nYou'll also compare the updated order to the original order."},{"content":"This tutorial has multiple steps.","pos":[1349,1382]},{"content":"After each step, you can run the application and see the progress.","pos":[1383,1449],"source":" After each step, you can run the\napplication and see the progress."},{"content":"Prerequisites","pos":[1455,1468]},{"content":"You’ll need to setup your machine to run .NET core.","pos":[1469,1520]},{"content":"You can find the installation instructions on the <bpt id=\"p1\">[</bpt>.NET Core<ept id=\"p1\">](https://www.microsoft.com/net/core)</ept> page.","pos":[1521,1624],"source":" You can find the\ninstallation instructions on the [.NET Core](https://www.microsoft.com/net/core)\npage."},{"content":"You can run this application on Windows, Ubuntu Linux, OS X or in a Docker container.","pos":[1625,1710],"source":" You can run this\napplication on Windows, Ubuntu Linux, OS X or in a Docker container."},{"content":"You’ll need to install your favorite code editor.","pos":[1711,1761],"source":" \nYou’ll need to install your favorite code editor."},{"content":"The descriptions below use <bpt id=\"p1\">[</bpt>Visual Studio Code<ept id=\"p1\">](https://code.visualstudio.com/)</ept> which is an open source, cross platform editor.","pos":[1762,1889],"source":" The descriptions below\nuse [Visual Studio Code](https://code.visualstudio.com/) which is an open\nsource, cross platform editor."},{"content":"However, you can use whatever tools you are comfortable with.","pos":[1890,1951],"source":" However, you can use whatever tools you are\ncomfortable with."},{"content":"Create the Application","pos":[1956,1978]},{"content":"The first step is to create a new application.","pos":[1980,2026]},{"content":"Open a command prompt and create a new directory for your application.","pos":[2027,2097],"source":" Open a command prompt and\ncreate a new directory for your application."},{"content":"Make that the current directory.","pos":[2098,2130],"source":" Make that the current\ndirectory."},{"content":"Type the command \"dotnet new\" at the command prompt.","pos":[2131,2183]},{"content":"This creates the starter files for a basic “Hello World” application.","pos":[2184,2253],"source":" This\ncreates the starter files for a basic “Hello World” application."},{"content":"If you've never used C# before, <bpt id=\"p1\">[</bpt>this tutorial<ept id=\"p1\">](console-teleprompter.md)</ept> explains the structure of a C# program.","pos":[2255,2367],"source":"If you've never used C# before, [this tutorial](console-teleprompter.md)\nexplains the structure of a C# program."},{"content":"You can read that and then return here to learn more about LINQ.","pos":[2368,2432],"source":" You can read that and then\nreturn here to learn more about LINQ."},{"content":"Creating the Data Set","pos":[2438,2459]},{"content":"Let's start by creating a deck of cards.","pos":[2461,2501]},{"content":"You'll do this using a LINQ query that has two sources (one for the four suits, one for the thirteen values).","pos":[2502,2611],"source":" You'll do this using a LINQ\nquery that has two sources (one for the four suits, one for the\nthirteen values)."},{"content":"You'll combine those source into a 52 card deck.","pos":[2612,2660]},{"content":"Here's the query:","pos":[2662,2679]},{"content":"The multiple <ph id=\"ph1\">`from`</ph> clauses produce a <ph id=\"ph2\">`SelectMany`</ph>, which creates a single sequence from combining each element in the first sequence with each element in the second sequence.","pos":[2820,2995],"source":"The multiple `from` clauses produce a `SelectMany`, which creates\na single sequence from combining each element in the first sequence\nwith each element in the second sequence."},{"content":"The order is important for our purposes.","pos":[2996,3036],"source":" The order is important\nfor our purposes."},{"content":"The first element in the first source sequence (Suits) is combined with every element in the second sequence (Values).","pos":[3037,3155],"source":" The first element in the first source sequence\n(Suits) is combined with every element in the second sequence (Values)."},{"content":"This produces all thirteen cards of first suit.","pos":[3156,3203],"source":"\nThis produces all thirteen cards of first suit."},{"content":"That process is repeated with each element in the first sequence (Suits).","pos":[3204,3277],"source":" That process is repeated\nwith each element in the first sequence (Suits)."},{"content":"The end result is a deck of cards ordered by suits, followed by values.","pos":[3278,3349],"source":" The end result is a deck of cards\nordered by suits, followed by values."},{"content":"Next, you'll need to build the Suits() and Ranks() methods.","pos":[3351,3410]},{"content":"Let's start with a really simple set of <bpt id=\"p1\">*</bpt>iterator methods<ept id=\"p1\">*</ept> that generate the sequence as an enumerable of strings:","pos":[3411,3525],"source":" Let's start\nwith a really simple set of *iterator methods* that generate the sequence\nas an enumerable of strings:"},{"content":"These two methods both utilize the <ph id=\"ph1\">`yield return`</ph> syntax to produce a sequence as they run.","pos":[4051,4142],"source":"These two methods both utilize the `yield return` syntax to produce a sequence\nas they run."},{"content":"The compiler builds an object that implements <ph id=\"ph1\">`IEnumerable&lt;T&gt;`</ph> and generates the sequence of strings as they are requested.","pos":[4143,4266],"source":" The compiler builds an object that implements `IEnumerable<T>`\nand generates the sequence of strings as they are requested."},{"content":"Go ahead and run the sample you've built at this point.","pos":[4268,4323]},{"content":"It will display all 52 cards in the deck.","pos":[4324,4365],"source":" It will display\nall 52 cards in the deck."},{"content":"You may find it very helpful to run this sample under a debugger to observe how the <ph id=\"ph1\">`Suits()`</ph> and <ph id=\"ph2\">`Values()`</ph> methods execute.","pos":[4366,4491],"source":" You may find it very helpful to run this sample\nunder a debugger to observe how the `Suits()` and `Values()` methods\nexecute."},{"content":"You can clearly see that each string in each sequence is generated only as it is needed.","pos":[4492,4580],"source":" You can clearly see that each string in each sequence is generated\nonly as it is needed."},{"content":"Manipulating the Order","pos":[4585,4607]},{"content":"Next, let's build a utility method that can perform the shuffle.","pos":[4609,4673]},{"content":"The first step is to split the deck in two.","pos":[4674,4717],"source":" The first step\nis to split the deck in two."},{"content":"The <ph id=\"ph1\">`Take()`</ph> and <ph id=\"ph2\">`Skip()`</ph> methods that are part of the LINQ APIs provide that feature for us:","pos":[4718,4811],"source":" The `Take()` and `Skip()` methods that are\npart of the LINQ APIs provide that feature for us:"},{"content":"The shuffle method doesn't exist in the standard library, so you'll have to write your own.","pos":[4893,4984],"source":"The shuffle method doesn't exist in the standard library, so you'll have\nto write your own."},{"content":"This new method illustrates several techniques that you'll use with LINQ-based programs, so let's explain each part of the method in steps.","pos":[4985,5124],"source":" This new method illustrates several techniques that you'll\nuse with LINQ-based programs, so let's explain each part of the method in\nsteps."},{"pos":[5126,5185],"content":"The signature for the method creates an <bpt id=\"p1\">*</bpt>extension method<ept id=\"p1\">*</ept>:","source":"The signature for the method creates an *extension method*:"},{"content":"An extension method is a special purpose <bpt id=\"p1\">*</bpt>static method.<ept id=\"p1\">*</ept>","pos":[5308,5365],"source":"An extension method is a special purpose *static method.*"},{"content":"You can see the addition of the <ph id=\"ph1\">`this`</ph> modifier on the first argument to the method.","pos":[5366,5450],"source":"\nYou can see the addition of the `this` modifier on the first\nargument to the method."},{"content":"That means you call the method as though it were a member method of the type of the first argument.","pos":[5451,5550],"source":" That means you call the method as though\nit were a member method of the type of the first argument."},{"content":"Extension methods can be declared only inside <ph id=\"ph1\">`static`</ph> classes, so let's create a new static class called <ph id=\"ph2\">`extensions`</ph> for this functionality.","pos":[5552,5694],"source":"Extension methods can be declared only inside `static` classes, so\nlet's create a new static class called `extensions` for this functionality."},{"content":"You'll add more extension methods as you continue this tutorial, and those will be placed in the same class.","pos":[5695,5803],"source":"\nYou'll add more extension methods as you continue this tutorial, and those\nwill be placed in the same class."},{"content":"This method declaration also follows a standard idiom where the input and output types are <ph id=\"ph1\">`IEnumerable&lt;T&gt;`</ph>.","pos":[5805,5913],"source":"This method declaration also follows a standard idiom where the input and\noutput types are `IEnumerable<T>`."},{"content":"That practice enables LINQ methods to be chained together to perform more complex queries.","pos":[5914,6004],"source":" That practice enables LINQ methods to\nbe chained together to perform more complex queries."},{"content":"You will be enumerating both sequences at once, interleaving the elements, and creating one object.","pos":[6313,6412],"source":"You will be enumerating both sequences at once, interleaving the elements,\nand creating one object."},{"content":"Writing a LINQ method that works with two sequences requires that you understand how <ph id=\"ph1\">`IEnumerable`</ph> works.","pos":[6414,6519],"source":"  Writing a LINQ method that works with two\nsequences requires that you understand how `IEnumerable` works."},{"content":"The <ph id=\"ph1\">`IEnumerable`</ph> interface has one method: <ph id=\"ph2\">`GetEnumerator()`</ph>.","pos":[6521,6583],"source":"The `IEnumerable` interface has one method: `GetEnumerator()`."},{"content":"The object returned by <ph id=\"ph1\">`GetEnumerator()`</ph> has a method to move to the next element, and a property that retrieves the current element in the sequence.","pos":[6584,6733],"source":" The object\nreturned by `GetEnumerator()` has a method to move to the next element,\nand a property that retrieves the current element in the sequence."},{"content":"You will use those two members to enumerate the collection and return the elements.","pos":[6734,6817],"source":" You\nwill use those two members to enumerate the collection and return the\nelements."},{"content":"This Interleave method will be an iterator method, so instead of building a collection and returning the collection, you'll use the <ph id=\"ph1\">`yield return`</ph> syntax shown above.","pos":[6818,6985],"source":" This Interleave method will be an iterator method, so instead\nof building a collection and returning the collection, you'll use the \n`yield return` syntax shown above."},{"content":"Here's the implementation of that method:","pos":[6988,7029]},{"pos":[7395,7487],"content":"Now that you've written this method, go back to the <ph id=\"ph1\">`Main`</ph> method and shuffle the deck once:","source":"Now that you've written this method, go back to the `Main` method\nand shuffle the deck once:"},{"content":"Comparisons","pos":[7958,7969]},{"content":"Let's see how many shuffles it takes to set the deck back to its original order.","pos":[7971,8051],"source":"Let's see how many shuffles it takes to set the deck back to its\noriginal order."},{"content":"You'll need to write a method that determines if two sequences are equal.","pos":[8052,8125],"source":" You'll need to write a method that determines if\ntwo sequences are equal."},{"content":"After you have that method, you'll need to place the code that shuffles the deck in a loop, and check to see when the deck is back in order.","pos":[8126,8266],"source":" After you have that method, you'll need to\nplace the code that shuffles the deck in a loop, and check to see when\nthe deck is back in order."},{"content":"Writing a method to determine if the two sequences are equal should be straightforward.","pos":[8268,8355],"source":"Writing a method to determine if the two sequences are equal should\nbe straightforward."},{"content":"It's a similar structure to the method you wrote to shuffle the deck.","pos":[8356,8425],"source":" It's a similar structure to the method you wrote\nto shuffle the deck."},{"content":"Only this time, instead of yield returning each element, you'll compare the matching elements of each sequence.","pos":[8426,8537],"source":" Only this time, instead of yield returning each\nelement, you'll compare the matching elements of each sequence."},{"content":"When the entire sequence has been enumerated, if every element matches, the sequences are the same:","pos":[8538,8637],"source":" When\nthe entire sequence has been enumerated, if every element matches,\nthe sequences are the same:"},{"content":"This shows a second Linq idiom: terminal methods.","pos":[9001,9050]},{"content":"They take a sequence as input (or in this case, two sequences), and return a single scalar value.","pos":[9051,9148],"source":" They take a sequence as input\n(or in this case, two sequences), and return a single scalar value."},{"content":"These methods, when they are used, are always the final method of a query.","pos":[9149,9223],"source":" These methods,\nwhen they are used, are always the final method of a query."},{"content":"(Hence the name).","pos":[9224,9241]},{"content":"You can see this in action when you use it to determine when the deck is back in its original order.","pos":[9244,9344],"source":"You can see this in action when you use it to determine when the deck\nis back in its original order."},{"content":"Put the shuffle code inside a loop, and stop when the sequence is back in its original order by applying the <ph id=\"ph1\">`SequenceEquals()`</ph> method.","pos":[9345,9480],"source":" Put the shuffle code inside a loop, and stop when\nthe sequence is back in its original order by applying the `SequenceEquals()`\nmethod."},{"content":"You can see it would always be the final method in any query, because it returns a single value instead of a sequence:","pos":[9481,9599],"source":" You can see it would always be the final method in any query, because it\nreturns a single value instead of a sequence:"},{"pos":[9909,10040],"content":"Run the sample, and see how the deck rearranges on each shuffle, until it returns to its original configuration after 8 iterations.","source":"Run the sample, and see how the deck rearranges on each shuffle, until\nit returns to its original configuration after 8 iterations."},{"content":"Optimizations","pos":[10045,10058]},{"content":"The sample you've built so far executes an <bpt id=\"p1\">*</bpt>in shuffle<ept id=\"p1\">*</ept>, where the top and bottom cards stay the same on each run.","pos":[10060,10174],"source":"The sample you've built so far executes an *in shuffle*, where the\ntop and bottom cards stay the same on each run."},{"content":"Let's make one change, and run an <bpt id=\"p1\">*</bpt>out shuffle<ept id=\"p1\">*</ept>, where all 52 cards change position.","pos":[10175,10259],"source":" Let's make one change,\nand run an *out shuffle*, where all 52 cards change position."},{"content":"For an out shuffle, you interleave the deck so that the first card in the bottom half becomes the first card in the deck.","pos":[10260,10381],"source":" For an out shuffle,\nyou interleave the deck so that the first card in the bottom half becomes the\nfirst card in the deck."},{"content":"That means the last card in the top half becomes the bottom card.","pos":[10382,10447],"source":" That means the last card in the top half becomes the bottom\ncard."},{"content":"That's just a one line change.","pos":[10448,10478]},{"content":"Update the call to shuffle to change the order of the top and bottom halves of the deck:","pos":[10479,10567],"source":" Update the call to shuffle to change the order\nof the top and bottom halves of the deck:"},{"content":"Run the program again, and you'll see that it takes 52 iterations for the deck to reorder itself.","pos":[10649,10746],"source":"Run the program again, and you'll see that it takes 52 iterations for the\ndeck to reorder itself."},{"content":"You'll also start to notice some serious performance degradations as the program continues to run.","pos":[10747,10845],"source":" You'll also start to notice some serious performance degradations\nas the program continues to run."},{"content":"There are a number of reasons for this.","pos":[10847,10886]},{"content":"Let's tackle one of the major causes: inefficient use of <bpt id=\"p1\">*</bpt>lazy evaluation<ept id=\"p1\">*</ept>.","pos":[10887,10962],"source":" Let's tackle one of the major causes: inefficient\nuse of *lazy evaluation*."},{"content":"LINQ queries are evaluated lazily.","pos":[10964,10998]},{"content":"The sequences are generated only as the elements are requested.","pos":[10999,11062]},{"content":"Usually, that's a major benefit of LINQ.","pos":[11063,11103],"source":"\nUsually, that's a major benefit of LINQ."},{"content":"However, in a use such as this program, this causes exponential growth in execution time.","pos":[11104,11193],"source":" However, in a use such as this program, this causes\nexponential growth in execution time."},{"content":"The original deck was generated using a LINQ query.","pos":[11195,11246]},{"content":"Each shuffle is generated by performing three LINQ queries on the previous deck.","pos":[11247,11327],"source":" Each shuffle is generated by performing three\nLINQ queries on the previous deck."},{"content":"All these are performed lazily.","pos":[11328,11359]},{"content":"That also means they are performed again each time the sequence is requested.","pos":[11360,11437],"source":" That also means they are performed\nagain each time the sequence is requested."},{"content":"By the time you get to the 52nd iteration, you're regenerating the original deck many, many times.","pos":[11438,11536],"source":" By the time you get to the 52nd iteration, you're regenerating\nthe original deck many, many times."},{"content":"Let's write a log to demonstrate this behavior.","pos":[11537,11584]},{"content":"Then, you'll fix it.","pos":[11585,11605]},{"content":"Here's a log method that can be appended to any query to mark that the query executed.","pos":[11607,11693]},{"content":"Next, instrument the definition of each query with a log message:","pos":[11932,11997]},{"content":"Notice that you don't log every time you access a query.","pos":[12950,13006]},{"content":"You log only when you create the original query.","pos":[13007,13055],"source":" You log only when you create\nthe original query."},{"content":"The program still takes a long time to run, but now you can see why.","pos":[13056,13124]},{"content":"If you run out of patience running the outer shuffle with logging turned on, switch back to the inner shuffle.","pos":[13125,13235],"source":"\nIf you run out of patience running the outer shuffle with logging turned on, switch back\nto the inner shuffle."},{"content":"You'll still see the lazy evaluation effects.","pos":[13236,13281]},{"content":"In one run, it executes 2592 queries, including all the value and suit generation.","pos":[13282,13364],"source":" In one run, it executes\n2592 queries, including all the value and suit generation."},{"content":"There is an easy way to update this program to avoid all those executions.","pos":[13366,13440]},{"content":"There are LINQ methods <ph id=\"ph1\">`ToArray()`</ph> and <ph id=\"ph2\">`ToList()`</ph> that cause the query to run, and store the results in an array or a list, respectively.","pos":[13441,13579],"source":" There are \nLINQ methods `ToArray()` and `ToList()` that cause the query to run, and store the results\nin an array or a list, respectively."},{"content":"You use these methods to cache the data results of a query rather than execute the source query again.","pos":[13580,13682],"source":" You use these methods to cache the data results of a query\nrather than execute the source query again."},{"content":"Append the queries that generate the card decks with a call to <ph id=\"ph1\">`ToArray()`</ph> and run the query again:","pos":[13684,13783],"source":"  Append the queries that generate the card decks\nwith a call to `ToArray()` and run the query again:"},{"content":"Run again, and the inner shuffle is down to 30 queries.","pos":[14798,14853]},{"content":"Run again with the outer shuffle and you'll see similar improvements.","pos":[14854,14923],"source":" Run again with the outer shuffle\nand you'll see similar improvements."},{"content":"(It now executes 162 queries).","pos":[14924,14954]},{"content":"Don't misinterpret this example by thinking that all queries should run eagerly.","pos":[14956,15036],"source":"Don't misinterpret this example by thinking that all queries should run\neagerly."},{"content":"This example is designed to highlight the use cases where lazy evaluation can cause performance difficulties.","pos":[15037,15146],"source":" This example is designed to highlight the use cases where lazy\nevaluation can cause performance difficulties."},{"content":"That's because each new arrangement of the deck of cards is built from the previous arrangement.","pos":[15147,15243],"source":" That's because each new\narrangement of the deck of cards is built from the previous arrangement."},{"content":"Using lazy evaluation means each new deck configuration is built from the original deck, even executing the code that built the <ph id=\"ph1\">`startingDeck`</ph>.","pos":[15244,15387],"source":"\nUsing lazy evaluation means each new deck configuration is built from\nthe original deck, even executing the code that built the `startingDeck`."},{"content":"That causes a large amount of extra work.","pos":[15388,15429],"source":"\nThat causes a large amount of extra work."},{"content":"In practice, some algorithms run much better using eager evaluation, and others run much better using lazy evaluation.","pos":[15432,15550],"source":"In practice, some algorithms run much better using eager evaluation, and others run much\nbetter using lazy evaluation."},{"content":"(In general, lazy evaluation is a much better choice when the data source is a separate process, like a database engine.","pos":[15551,15671],"source":" (In general, lazy evaluation is a much better choice\nwhen the data source is a separate process, like a database engine."},{"content":"In those cases, lazy evaluation enables more complex queries to execute only one round trip to the database process.) LINQ enables both lazy and eager evaluation.","pos":[15672,15834],"source":" In those cases,\nlazy evaluation enables more complex queries to execute only one round trip to the\ndatabase process.) LINQ enables both lazy and eager evaluation."},{"content":"Measure, and pick the best choice.","pos":[15835,15869],"source":" Measure, and pick\nthe best choice."},{"content":"Preparing for New Features","pos":[15874,15900]},{"content":"The code you've written for this sample is an example of creating a simple prototype that does the job.","pos":[15902,16005],"source":"The code you've written for this sample is an example of creating a simple prototype that does the\njob."},{"content":"This is a great way to explore a problem space, and for many features, it may be the best permanent solution.","pos":[16006,16115],"source":" This is a great way to explore a problem space, and for many features, it may be\nthe best permanent solution."},{"content":"You've leveraged <bpt id=\"p1\">*</bpt>anonymous types<ept id=\"p1\">*</ept> for the cards, and each card is represented by strings.","pos":[16116,16206],"source":" You've leveraged *anonymous types* for the cards, and each\ncard is represented by strings."},{"content":"<bpt id=\"p1\">*</bpt>Anonymous Types<ept id=\"p1\">*</ept> have many productivity advantages.","pos":[16208,16260],"source":"*Anonymous Types* have many productivity advantages."},{"content":"You don't need to define a class yourself to represent the storage.","pos":[16261,16328],"source":" You don't need to define a class yourself\nto represent the storage."},{"content":"The compiler generates the type for you.","pos":[16329,16369]},{"content":"The compiler generated type utilizes many of the best practices for simple data objects.","pos":[16370,16458],"source":" The compiler generated type\nutilizes many of the best practices for simple data objects."},{"content":"It's <bpt id=\"p1\">*</bpt>immutable<ept id=\"p1\">*</ept>, meaning that none of its properties can be changed after it has been constructed.","pos":[16459,16558],"source":" It's *immutable*, meaning that\nnone of its properties can be changed after it has been constructed."},{"content":"Anonymous types are internal to an assembly, so they aren't seen as part of the public API for that assembly.","pos":[16559,16668],"source":" Anonymous types are\ninternal to an assembly, so they aren't seen as part of the public API for that assembly."},{"content":"Anonymous types also contain an override of the <ph id=\"ph1\">`ToString()`</ph> method that returns a formatted string with each of the values.","pos":[16669,16793],"source":"\nAnonymous types also contain an override of the `ToString()` method that returns a formatted\nstring with each of the values."},{"content":"Anonymous types also have disadvantages.","pos":[16795,16835]},{"content":"They don't have accessible names, so you can't use them as return values or arguments.","pos":[16836,16922],"source":" They don't have accessible names, so you can't use\nthem as return values or arguments."},{"content":"You'll notice that any methods above that used these anonymous types are generic methods.","pos":[16923,17012],"source":" You'll notice that any methods above that used these anonymous\ntypes are generic methods."},{"content":"The override of <ph id=\"ph1\">`ToString()`</ph> may not be what you want as the application grows more features.","pos":[17013,17106],"source":" The override of `ToString()` may not be what you want as the application\ngrows more features."},{"content":"The sample also uses strings for the suit and the rank of each card.","pos":[17109,17177]},{"content":"That's quite open ended.","pos":[17178,17202]},{"content":"The C# type system can help us make better code, by leveraging <ph id=\"ph1\">`enum`</ph> types for those values.","pos":[17203,17296],"source":"\nThe C# type system can help us make better code, by leveraging `enum` types for those\nvalues."},{"content":"Start with the suits.","pos":[17298,17319]},{"content":"This is a perfect time to use an <ph id=\"ph1\">`enum`</ph>:","pos":[17320,17360],"source":" This is a perfect time to use an `enum`:"},{"pos":[17442,17500],"content":"The <ph id=\"ph1\">`Suits()`</ph> method also changes type and implementation:","source":"The `Suits()` method also changes type and implementation:"},{"content":"Next, do the same change with the Rank of the cards:","pos":[17671,17723]},{"content":"And the method that generates them:","pos":[17886,17921]},{"content":"As one final cleanup, let's make a type to represent the card, instead of relying on an anonymous type.","pos":[18336,18440],"source":"As one final cleanup, let's make a type to represent the card, instead of \nrelying on an anonymous type."},{"content":"Anonymous types are great for lightweight, local types, but in this example, the playing card is one of the main concepts.","pos":[18441,18563],"source":" Anonymous types are great for lightweight,\nlocal types, but in this example, the playing card is one of the main\nconcepts."},{"content":"It should be a concrete type.","pos":[18564,18593]},{"content":"This type uses <bpt id=\"p1\">*</bpt>auto-implemented read-only properties<ept id=\"p1\">*</ept> which are set in the constructor, and then cannot be modified.","pos":[18902,19019],"source":"This type uses *auto-implemented read-only properties* which are set\nin the constructor, and then cannot be modified."},{"content":"It also makes use of the new <bpt id=\"p1\">*</bpt>string interpolation<ept id=\"p1\">*</ept> feature that makes it easier to format string output.","pos":[19020,19125],"source":" It also makes use of\nthe new *string interpolation* feature that makes it easier to format\nstring output."},{"content":"Update the query that generates the starting deck to use the new type:","pos":[19127,19197]},{"content":"Compile and run again.","pos":[19472,19494]},{"content":"The output is a little cleaner, and the code is a bit more clear and can be extended more easily.","pos":[19495,19592],"source":" The output is a little cleaner, and the code is a bit\nmore clear and can be extended more easily."},{"content":"Conclusion","pos":[19597,19607]},{"content":"This sample should you some of the methods used in LINQ, how to create your own methods that will be easily used with LINQ enabled code.","pos":[19609,19745],"source":"This sample should you some of the methods used in LINQ, how to create your\nown methods that will be easily used with LINQ enabled code."},{"content":"It also showed you the differences between lazy and eager evaluation, and the affect that decision can have on performance.","pos":[19746,19869],"source":" It also showed\nyou the differences between lazy and eager evaluation, and the affect that\ndecision can have on performance."},{"content":"And, you learned a bit about one magician's technique.","pos":[19871,19925]},{"content":"Magician's use the faro shuffle because they can control where every card moves in the deck.","pos":[19926,20018],"source":" Magician's use the\nfaro shuffle because they can control where every card moves in the deck."},{"content":"In some tricks, the magician has an audience member place a card on top of the deck, and shuffles a few times, knowing where that card goes.","pos":[20019,20159],"source":"\nIn some tricks, the magician has an audience member place a card on top\nof the deck, and shuffles a few times, knowing where that card goes."},{"content":"Other illusions require the deck set a certain way.","pos":[20160,20211],"source":" Other\nillusions require the deck set a certain way."},{"content":"A magician will set the deck prior to performing the trick.","pos":[20212,20271],"source":" A magician will set the deck\nprior to performing the trick."},{"content":"Then she will shuffle the deck 5 times using an inner shuffle.","pos":[20272,20334],"source":" Then she will shuffle the deck 5 times\nusing an inner shuffle."},{"content":"On stage, she can show what looks like a random deck, shuffle it 3 more times, and have the deck set exactly how she wants.","pos":[20335,20458],"source":" On stage, she can show what looks like a random\ndeck, shuffle it 3 more times, and have the deck set exactly how she wants."}],"content":"---\ntitle: Working with LINQ\ndescription: Working with LINQ\nkeywords: .NET, .NET Core\nauthor: BillWagner\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: 0db12548-82cb-4903-ac88-13103d70aa77\n---\n\n# Working with LINQ\n\n## Introduction\nThis tutorial teaches you a number of features in .NET Core and the C# language. You’ll learn:\n\n*   How to generate sequences with LINQ\n*   How to write methods that can be easily used in LINQ queries.\n*   How to distinguish between eager and lazy evaluation.\n\nYou'll learn these techniques by building an application that demonstrates\none of the basic skills of any magician: the\n[faro shuffle](https://en.wikipedia.org/wiki/Faro_shuffle). Briefly,\na faro shuffle is a technique where you split a card deck exactly in half,\nthen the shuffle interleaves each one card from each half to rebuild the\noriginal deck.\n\nMagicians use this technique because every card is in a known location\nafter each shuffle, and the order is a repeating pattern. \n\nFor our purposes, it is a light hearted look at manipulating sequences\nof data. The application you'll build will construct a card deck, and\nthen perform a sequence of shuffles, writing the sequence out each time.\nYou'll also compare the updated order to the original order.\n\nThis tutorial has multiple steps. After each step, you can run the\napplication and see the progress.\n\n\n## Prerequisites\nYou’ll need to setup your machine to run .NET core. You can find the\ninstallation instructions on the [.NET Core](https://www.microsoft.com/net/core)\npage. You can run this\napplication on Windows, Ubuntu Linux, OS X or in a Docker container. \nYou’ll need to install your favorite code editor. The descriptions below\nuse [Visual Studio Code](https://code.visualstudio.com/) which is an open\nsource, cross platform editor. However, you can use whatever tools you are\ncomfortable with.\n\n## Create the Application\n\nThe first step is to create a new application. Open a command prompt and\ncreate a new directory for your application. Make that the current\ndirectory. Type the command \"dotnet new\" at the command prompt. This\ncreates the starter files for a basic “Hello World” application.\n\nIf you've never used C# before, [this tutorial](console-teleprompter.md)\nexplains the structure of a C# program. You can read that and then\nreturn here to learn more about LINQ. \n\n## Creating the Data Set\n\nLet's start by creating a deck of cards. You'll do this using a LINQ\nquery that has two sources (one for the four suits, one for the\nthirteen values). You'll combine those source into a 52 card deck.\n\nHere's the query:\n\n```cs\nvar startingDeck = from s in Suits()\n                   from r in Ranks()\n                   select new { Suit = s, Rank = r };\n```\n\nThe multiple `from` clauses produce a `SelectMany`, which creates\na single sequence from combining each element in the first sequence\nwith each element in the second sequence. The order is important\nfor our purposes. The first element in the first source sequence\n(Suits) is combined with every element in the second sequence (Values).\nThis produces all thirteen cards of first suit. That process is repeated\nwith each element in the first sequence (Suits). The end result is a deck of cards\nordered by suits, followed by values.\n\nNext, you'll need to build the Suits() and Ranks() methods. Let's start\nwith a really simple set of *iterator methods* that generate the sequence\nas an enumerable of strings:\n\n```cs\nstatic IEnumerable<string> Suits()\n{\n    yield return \"clubs\";\n    yield return \"diamonds\";\n    yield return \"hearts\";\n    yield return \"spades\";\n}\n\nstatic IEnumerable<string> Ranks()\n{\n    yield return \"two\";\n    yield return \"three\";\n    yield return \"four\";\n    yield return \"five\";\n    yield return \"six\";\n    yield return \"seven\";\n    yield return \"eight\";\n    yield return \"nine\";\n    yield return \"ten\";\n    yield return \"jack\";\n    yield return \"queen\";\n    yield return \"king\";\n    yield return \"ace\";\n}\n```\n\nThese two methods both utilize the `yield return` syntax to produce a sequence\nas they run. The compiler builds an object that implements `IEnumerable<T>`\nand generates the sequence of strings as they are requested.\n\nGo ahead and run the sample you've built at this point. It will display\nall 52 cards in the deck. You may find it very helpful to run this sample\nunder a debugger to observe how the `Suits()` and `Values()` methods\nexecute. You can clearly see that each string in each sequence is generated\nonly as it is needed.\n\n## Manipulating the Order\n\nNext, let's build a utility method that can perform the shuffle. The first step\nis to split the deck in two. The `Take()` and `Skip()` methods that are\npart of the LINQ APIs provide that feature for us:\n\n```cs\nvar top = startingDeck.Take(26);\nvar bottom = startingDeck.Skip(26);\n```\n\nThe shuffle method doesn't exist in the standard library, so you'll have\nto write your own. This new method illustrates several techniques that you'll\nuse with LINQ-based programs, so let's explain each part of the method in\nsteps.\n\nThe signature for the method creates an *extension method*:\n\n```cs\npublic static IEnumerable<T> InterleaveSequenceWith<T>\n    (this IEnumerable<T> first, IEnumerable<T> second)\n```\n\nAn extension method is a special purpose *static method.*\nYou can see the addition of the `this` modifier on the first\nargument to the method. That means you call the method as though\nit were a member method of the type of the first argument.\n\nExtension methods can be declared only inside `static` classes, so\nlet's create a new static class called `extensions` for this functionality.\nYou'll add more extension methods as you continue this tutorial, and those\nwill be placed in the same class.\n\nThis method declaration also follows a standard idiom where the input and\noutput types are `IEnumerable<T>`. That practice enables LINQ methods to\nbe chained together to perform more complex queries.\n\n```cs\nusing System.Collections.Generic;\n\nnamespace LinqFaroShuffle\n{\n    public static class Extensions\n    {\n        public static IEnumerable<T> InterleaveSequenceWith<T>\n            (this IEnumerable<T> first, IEnumerable<T> second)\n        {\n            // implementation coming.\n        }\n    }\n}\n```\n\nYou will be enumerating both sequences at once, interleaving the elements,\nand creating one object.  Writing a LINQ method that works with two\nsequences requires that you understand how `IEnumerable` works.\n\nThe `IEnumerable` interface has one method: `GetEnumerator()`. The object\nreturned by `GetEnumerator()` has a method to move to the next element,\nand a property that retrieves the current element in the sequence. You\nwill use those two members to enumerate the collection and return the\nelements. This Interleave method will be an iterator method, so instead\nof building a collection and returning the collection, you'll use the \n`yield return` syntax shown above. \n\nHere's the implementation of that method:\n\n```cs\npublic static IEnumerable<T> InterleaveSequenceWith<T>\n    (this IEnumerable<T> first, IEnumerable<T> second)\n{\n    var firstIter = first.GetEnumerator();\n    var secondIter = second.GetEnumerator();\n    while (firstIter.MoveNext() && secondIter.MoveNext())\n    {\n        yield return firstIter.Current;\n        yield return secondIter.Current;\n    }\n}\n```\n\nNow that you've written this method, go back to the `Main` method\nand shuffle the deck once:\n\n```cs\npublic static void Main(string[] args)\n{\n    var startingDeck = from s in Suits()\n                       from r in Ranks()\n                       select new { Suit = s, Rank = r };\n    foreach (var c in startingDeck)\n        Console.WriteLine(c);\n        \n    var top = startingDeck.Take(26);\n    var bottom = startingDeck.Skip(26);\n    \n    var shuffle = top.InterleaveSequenceWith(bottom);\n    foreach (var c in shuffle)\n        Console.WriteLine(c);\n}\n```\n\n## Comparisons\n\nLet's see how many shuffles it takes to set the deck back to its\noriginal order. You'll need to write a method that determines if\ntwo sequences are equal. After you have that method, you'll need to\nplace the code that shuffles the deck in a loop, and check to see when\nthe deck is back in order.\n\nWriting a method to determine if the two sequences are equal should\nbe straightforward. It's a similar structure to the method you wrote\nto shuffle the deck. Only this time, instead of yield returning each\nelement, you'll compare the matching elements of each sequence. When\nthe entire sequence has been enumerated, if every element matches,\nthe sequences are the same:\n\n```cs\npublic static bool SequenceEquals<T>(this IEnumerable<T> first, IEnumerable<T> second)\n{\n    var firstIter = first.GetEnumerator();\n    var secondIter = second.GetEnumerator();\n    while (firstIter.MoveNext() && secondIter.MoveNext())\n    {\n        if (!firstIter.Current.Equals(secondIter.Current))\n            return false;\n    }\n    return true;\n}\n```\n\nThis shows a second Linq idiom: terminal methods. They take a sequence as input\n(or in this case, two sequences), and return a single scalar value. These methods,\nwhen they are used, are always the final method of a query. (Hence the name). \n\nYou can see this in action when you use it to determine when the deck\nis back in its original order. Put the shuffle code inside a loop, and stop when\nthe sequence is back in its original order by applying the `SequenceEquals()`\nmethod. You can see it would always be the final method in any query, because it\nreturns a single value instead of a sequence:\n\n```cs\nvar times = 0;\nvar shuffle = startingDeck;\ndo\n{\n    shuffle = shuffle.Take(26).InterleaveSequenceWith(shuffle.Skip(26));\n\n    foreach (var c in shuffle)\n        Console.WriteLine(c);\n\n    Console.WriteLine();\n    times++;\n} while (!startingDeck.SequenceEquals(shuffle));\nConsole.WriteLine(times);\n```\n\nRun the sample, and see how the deck rearranges on each shuffle, until\nit returns to its original configuration after 8 iterations.\n\n## Optimizations\n\nThe sample you've built so far executes an *in shuffle*, where the\ntop and bottom cards stay the same on each run. Let's make one change,\nand run an *out shuffle*, where all 52 cards change position. For an out shuffle,\nyou interleave the deck so that the first card in the bottom half becomes the\nfirst card in the deck. That means the last card in the top half becomes the bottom\ncard. That's just a one line change. Update the call to shuffle to change the order\nof the top and bottom halves of the deck:\n\n```cs\nshuffle = shuffle.Skip(26).InterleaveSequenceWith(shuffle.Take(26));\n```\n\nRun the program again, and you'll see that it takes 52 iterations for the\ndeck to reorder itself. You'll also start to notice some serious performance degradations\nas the program continues to run.\n\nThere are a number of reasons for this. Let's tackle one of the major causes: inefficient\nuse of *lazy evaluation*.\n\nLINQ queries are evaluated lazily. The sequences are generated only as the elements are requested.\nUsually, that's a major benefit of LINQ. However, in a use such as this program, this causes\nexponential growth in execution time.\n\nThe original deck was generated using a LINQ query. Each shuffle is generated by performing three\nLINQ queries on the previous deck. All these are performed lazily. That also means they are performed\nagain each time the sequence is requested. By the time you get to the 52nd iteration, you're regenerating\nthe original deck many, many times. Let's write a log to demonstrate this behavior. Then, you'll fix it.\n\nHere's a log method that can be appended to any query to mark that the query executed.\n\n```cs\npublic static IEnumerable<T> LogQuery<T>(this IEnumerable<T> sequence, string tag)\n{\n    using (var writer = File.AppendText(\"debug.log\"))\n    {\n        writer.WriteLine($\"Executing Query {tag}\");\n    }\n    return sequence;\n}\n```\n\nNext, instrument the definition of each query with a log message:\n\n```cs\npublic static void Main(string[] args)\n{\nvar startingDeck = (from s in Suits().LogQuery(\"Suit Generation\")\n                    from r in Ranks().LogQuery(\"Rank Generation\")\n                    select new { Suit = s, Rank = r }).LogQuery(\"Starting Deck\");\n    foreach (var c in startingDeck)\n        Console.WriteLine(c);\n        \n    Console.WriteLine();\n    var times = 0;\n    var shuffle = startingDeck;\n    do\n    {\n        //shuffle = shuffle.Take(26).LogQuery(\"Top Half\")\n        //    .InterleaveSequenceWith(shuffle.Skip(26).LogQuery(\"Bottom Half\")).LogQuery(\"Shuffle\");\n\n        shuffle = shuffle.Skip(26).LogQuery(\"Bottom Half\")\n            .InterleaveSequenceWith(shuffle.Take(26).LogQuery(\"Top Half\")).LogQuery(\"Shuffle\");\n\n        foreach (var c in shuffle)\n            Console.WriteLine(c);\n        times++;\n        Console.WriteLine(times);\n    } while (!startingDeck.SequenceEquals(shuffle));\n    Console.WriteLine(times);\n}\n```\n\nNotice that you don't log every time you access a query. You log only when you create\nthe original query. The program still takes a long time to run, but now you can see why.\nIf you run out of patience running the outer shuffle with logging turned on, switch back\nto the inner shuffle. You'll still see the lazy evaluation effects. In one run, it executes\n2592 queries, including all the value and suit generation.\n\nThere is an easy way to update this program to avoid all those executions. There are \nLINQ methods `ToArray()` and `ToList()` that cause the query to run, and store the results\nin an array or a list, respectively. You use these methods to cache the data results of a query\nrather than execute the source query again.  Append the queries that generate the card decks\nwith a call to `ToArray()` and run the query again:\n\n```cs\npublic static void Main(string[] args)\n{\nvar startingDeck = (from s in Suits().LogQuery(\"Suit Generation\")\n                    from v in Ranks().LogQuery(\"Rank Generation\")\n                    select new { Suit = s, Rank = r })\n                    .LogQuery(\"Starting Deck\")\n                    .ToArray();\n    foreach (var c in startingDeck)\n        Console.WriteLine(c);\n        \n    Console.WriteLine();\n    var times = 0;\n    var shuffle = startingDeck;\n    do\n    {\n        shuffle = shuffle.Take(26).LogQuery(\"Top Half\")\n            .InterleaveSequenceWith(shuffle.Skip(26).LogQuery(\"Bottom Half\")).LogQuery(\"Shuffle\").ToArray();\n\n        //shuffle = shuffle.Skip(26).LogQuery(\"Bottom Half\")\n        //    .InterleaveSequenceWith(shuffle.Take(26).LogQuery(\"Top Half\")).LogQuery(\"Shuffle\");\n\n        foreach (var c in shuffle)\n            Console.WriteLine(c);\n        times++;\n        Console.WriteLine(times);\n    } while (!startingDeck.SequenceEquals(shuffle));\n    Console.WriteLine(times);\n}\n```\n\nRun again, and the inner shuffle is down to 30 queries. Run again with the outer shuffle\nand you'll see similar improvements. (It now executes 162 queries).\n\nDon't misinterpret this example by thinking that all queries should run\neagerly. This example is designed to highlight the use cases where lazy\nevaluation can cause performance difficulties. That's because each new\narrangement of the deck of cards is built from the previous arrangement.\nUsing lazy evaluation means each new deck configuration is built from\nthe original deck, even executing the code that built the `startingDeck`.\nThat causes a large amount of extra work. \n\nIn practice, some algorithms run much better using eager evaluation, and others run much\nbetter using lazy evaluation. (In general, lazy evaluation is a much better choice\nwhen the data source is a separate process, like a database engine. In those cases,\nlazy evaluation enables more complex queries to execute only one round trip to the\ndatabase process.) LINQ enables both lazy and eager evaluation. Measure, and pick\nthe best choice.\n\n## Preparing for New Features\n\nThe code you've written for this sample is an example of creating a simple prototype that does the\njob. This is a great way to explore a problem space, and for many features, it may be\nthe best permanent solution. You've leveraged *anonymous types* for the cards, and each\ncard is represented by strings.\n\n*Anonymous Types* have many productivity advantages. You don't need to define a class yourself\nto represent the storage. The compiler generates the type for you. The compiler generated type\nutilizes many of the best practices for simple data objects. It's *immutable*, meaning that\nnone of its properties can be changed after it has been constructed. Anonymous types are\ninternal to an assembly, so they aren't seen as part of the public API for that assembly.\nAnonymous types also contain an override of the `ToString()` method that returns a formatted\nstring with each of the values.\n\nAnonymous types also have disadvantages. They don't have accessible names, so you can't use\nthem as return values or arguments. You'll notice that any methods above that used these anonymous\ntypes are generic methods. The override of `ToString()` may not be what you want as the application\ngrows more features. \n\nThe sample also uses strings for the suit and the rank of each card. That's quite open ended.\nThe C# type system can help us make better code, by leveraging `enum` types for those\nvalues.\n\nStart with the suits. This is a perfect time to use an `enum`:\n\n```cs\npublic enum Suit\n{\n    Clubs,\n    Diamonds,\n    Hearts,\n    Spades\n}\n```\n\nThe `Suits()` method also changes type and implementation:\n\n```cs\nstatic IEnumerable<Suit> Suits()\n{\n    yield return Suit.Clubs;\n    yield return Suit.Diamonds;\n    yield return Suit.Hearts;\n    yield return Suit.Spades;\n}\n```\n\nNext, do the same change with the Rank of the cards:\n\n```cs\npublic enum Rank\n{\n    Two,\n    Three,\n    Four,\n    Five,\n    Six,\n    Seven,\n    Eight,\n    Nine,\n    Ten,\n    Jack,\n    Queen,\n    King,\n    Ace\n}\n```\n\nAnd the method that generates them:\n\n```cs\nstatic IEnumerable<Rank> Values()\n{\n    yield return Rank.Two;\n    yield return Rank.Three;\n    yield return Rank.Four;\n    yield return Rank.Five;\n    yield return Rank.Six;\n    yield return Rank.Seven;\n    yield return Rank.Eight;\n    yield return Rank.Nine;\n    yield return Rank.Ten;\n    yield return Rank.Jack;\n    yield return Rank.Queen;\n    yield return Rank.King;\n    yield return Rank.Ace;\n}\n```\n\nAs one final cleanup, let's make a type to represent the card, instead of \nrelying on an anonymous type. Anonymous types are great for lightweight,\nlocal types, but in this example, the playing card is one of the main\nconcepts. It should be a concrete type.\n\n```cs\npublic class PlayingCard\n{\n    public Suit CardSuit { get; }\n    public Rank CardRank { get; }\n    \n    public PlayingCard(Suit s, Rank r)\n    {\n        CardSuit = s;\n        CardRank = r;\n    }\n    \n    public override string ToString()\n    {\n        return $\"{CardRank} of {CardSuit}\";\n    }\n}\n```\n\nThis type uses *auto-implemented read-only properties* which are set\nin the constructor, and then cannot be modified. It also makes use of\nthe new *string interpolation* feature that makes it easier to format\nstring output.\n\nUpdate the query that generates the starting deck to use the new type:\n\n```cs\nvar startingDeck = (from s in Suits().LogQuery(\"Suit Generation\")\n                    from r in Ranks().LogQuery(\"Value Generation\")\n                    select new PlayingCard(s, r))\n                    .LogQuery(\"Starting Deck\")\n                    .ToArray();\n```\n\nCompile and run again. The output is a little cleaner, and the code is a bit\nmore clear and can be extended more easily.\n\n## Conclusion\n\nThis sample should you some of the methods used in LINQ, how to create your\nown methods that will be easily used with LINQ enabled code. It also showed\nyou the differences between lazy and eager evaluation, and the affect that\ndecision can have on performance.\n\nAnd, you learned a bit about one magician's technique. Magician's use the\nfaro shuffle because they can control where every card moves in the deck.\nIn some tricks, the magician has an audience member place a card on top\nof the deck, and shuffles a few times, knowing where that card goes. Other\nillusions require the deck set a certain way. A magician will set the deck\nprior to performing the trick. Then she will shuffle the deck 5 times\nusing an inner shuffle. On stage, she can show what looks like a random\ndeck, shuffle it 3 more times, and have the deck set exactly how she wants.\n"}