{"nodes":[{"pos":[11,87],"content":"Getting started with .NET Core on Windows/Linux/macOS using the command line","needQuote":true,"nodes":[{"content":"Getting started with .NET Core on Windows/Linux/macOS using the command line","pos":[0,76]}]},{"pos":[101,208],"content":"Getting started with .NET Core on Windows, Linux, or macOS using the .NET Core command line interface (CLI)","needQuote":true,"nodes":[{"content":"Getting started with .NET Core on Windows, Linux, or macOS using the .NET Core command line interface (CLI)","pos":[0,107]}]},{"pos":[219,234],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":"Getting started with .NET Core on Windows/Linux/macOS using the command line","pos":[440,516]},{"content":"This guide will show you how to use the .NET Core CLI tooling to build cross-platform console apps.","pos":[518,617]},{"content":"It will start with the most basic console app and eventually span multiple projects, including testing.","pos":[619,722]},{"content":"You'll add these features step-by-step, building on what you've already seen and built.","pos":[723,810]},{"pos":[812,910],"content":"If you're unfamiliar with the .NET Core CLI toolset, read <bpt id=\"p1\">[</bpt>the .NET Core SDK overview<ept id=\"p1\">](../sdk.md)</ept>.","source":"If you're unfamiliar with the .NET Core CLI toolset, read [the .NET Core SDK overview](../sdk.md)."},{"content":"Prerequisites","pos":[915,928]},{"content":"Before you begin, ensure you have the <bpt id=\"p1\">[</bpt>latest .NET Core CLI tooling<ept id=\"p1\">](https://www.microsoft.com/net/core)</ept>.","pos":[930,1035],"source":"Before you begin, ensure you have the [latest .NET Core CLI tooling](https://www.microsoft.com/net/core)."},{"content":"You'll also need a text editor.","pos":[1037,1068]},{"content":"Hello, Console App!","pos":[1073,1092]},{"content":"First, navigate to or create a new folder with a name you like.","pos":[1094,1157]},{"content":"\"Hello\" is the name chosen for the sample code, which can be found <bpt id=\"p1\">[</bpt>here<ept id=\"p1\">](https://github.com/dotnet/core-docs/tree/master/samples/core-projects/console-apps/Hello)</ept>.","pos":[1159,1323],"source":"  \"Hello\" is the name chosen for the sample code, which can be found [here](https://github.com/dotnet/core-docs/tree/master/samples/core-projects/console-apps/Hello)."},{"content":"Open up a command prompt and type the following:","pos":[1325,1373]},{"content":"Let's do a quick walkthrough:","pos":[1427,1456]},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">`dotnet new`</ph><ept id=\"p1\">](../tools/dotnet-new.md)</ept> creates an up-to-date <ph id=\"ph2\">`project.json`</ph> file with NuGet dependencies necessary to build a console app.","pos":[1480,1618],"source":"[`dotnet new`](../tools/dotnet-new.md) creates an up-to-date `project.json` file with NuGet dependencies necessary to build a console app."},{"content":"It also creates a <ph id=\"ph1\">`Program.cs`</ph>, a basic file containing the entry point for the application.","pos":[1620,1712],"source":"  It also creates a `Program.cs`, a basic file containing the entry point for the application."},{"pos":[1734,1735],"content":":"},{"pos":[2162,2163],"content":":"},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">`dotnet restore`</ph><ept id=\"p1\">](../tools/dotnet-restore.md)</ept> calls into NuGet to restore the tree of dependencies.","pos":[2443,2543],"source":"[`dotnet restore`](../tools/dotnet-restore.md) calls into NuGet to restore the tree of dependencies."},{"content":"NuGet analyzes the <ph id=\"ph1\">`project.json`</ph> file, downloads the dependencies stated in the file (or grabs them from a cache on your machine), and writes the <ph id=\"ph2\">`project.lock.json`</ph> file.","pos":[2544,2716],"source":" NuGet analyzes the `project.json` file, downloads the dependencies stated in the file (or grabs them from a cache on your machine), and writes the `project.lock.json` file."},{"content":"The <ph id=\"ph1\">`project.lock.json`</ph> file is necessary to be able to compile and run.","pos":[2718,2790],"source":"  The `project.lock.json` file is necessary to be able to compile and run."},{"content":"The <ph id=\"ph1\">`project.lock.json`</ph> file is a persisted and complete set of the graph of NuGet dependencies and other information describing an app.","pos":[2798,2934],"source":"The `project.lock.json` file is a persisted and complete set of the graph of NuGet dependencies and other information describing an app."},{"content":"This file is read by other tools, such as <ph id=\"ph1\">`dotnet build`</ph> and <ph id=\"ph2\">`dotnet run`</ph>, enabling them to process the source code with a correct set of NuGet dependencies and binding resolutions.","pos":[2936,3117],"source":"  This file is read by other tools, such as `dotnet build` and `dotnet run`, enabling them to process the source code with a correct set of NuGet dependencies and binding resolutions."},{"pos":[3144,3323],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">`dotnet run`</ph><ept id=\"p1\">](../tools/dotnet-run.md)</ept> calls <ph id=\"ph2\">`dotnet build`</ph> to ensure that the build targets have been built, and then calls <ph id=\"ph3\">`dotnet &lt;assembly.dll&gt;`</ph> to run the target application.","source":"[`dotnet run`](../tools/dotnet-run.md) calls `dotnet build` to ensure that the build targets have been built, and then calls `dotnet <assembly.dll>` to run the target application."},{"pos":[3364,3499],"content":"You can also execute <bpt id=\"p1\">[</bpt><ph id=\"ph1\">`dotnet build`</ph><ept id=\"p1\">](../tools/dotnet-build.md)</ept> to compile and the code without running the build console applications.","source":"You can also execute [`dotnet build`](../tools/dotnet-build.md) to compile and the code without running the build console applications."},{"content":"Building a self-contained application","pos":[3505,3542]},{"content":"Let's try compiling a self-contained application instead of a portable application.","pos":[3544,3627]},{"content":"You can read more about the <bpt id=\"p1\">[</bpt>types of portability in .NET Core<ept id=\"p1\">](../app-types.md)</ept> to learn about the different application types, and how they are deployed.","pos":[3628,3783],"source":" You can read more about the [types of portability in .NET Core](../app-types.md) to learn about the different application types, and how they are deployed."},{"content":"You need to make some changes to your <ph id=\"ph1\">`project.json`</ph> file to direct the tools to build a self-contained application.","pos":[3785,3901],"source":"You need to make some changes to your `project.json`\nfile to direct the tools to build a self-contained application."},{"content":"You can see these in the <bpt id=\"p1\">[</bpt>HelloNative<ept id=\"p1\">](https://github.com/dotnet/core-docs/tree/master/samples/core-projects/console-apps/HelloNative)</ept> project in the samples directory.","pos":[3902,4070],"source":" You can see these in the\n[HelloNative](https://github.com/dotnet/core-docs/tree/master/samples/core-projects/console-apps/HelloNative)\nproject in the samples directory."},{"content":"The first change is to remove the <ph id=\"ph1\">`\"type\": \"platform\"`</ph> element from all dependencies.","pos":[4072,4157],"source":"The first change is to remove the `\"type\": \"platform\"` element from all dependencies."},{"content":"This project's only dependency so far is <ph id=\"ph1\">`\"Microsoft.NETCore.App\"`</ph>.","pos":[4158,4226],"source":" \nThis project's only dependency so far is `\"Microsoft.NETCore.App\"`."},{"content":"The <ph id=\"ph1\">`dependencies`</ph> section should look like this:","pos":[4227,4276],"source":" The `dependencies` section should look like this:"},{"content":"Next, you need to add a <ph id=\"ph1\">`runtimes`</ph> node to specify all the target execution environments.","pos":[4376,4465],"source":"Next, you need to add a `runtimes` node to specify all the target execution environments."},{"content":"For example, the following <ph id=\"ph1\">`runtimes`</ph> node instructs the build system to create executables for the 64 bit version of Windows 10 and the 64 bit version of Mac OS X version 10.11.","pos":[4466,4644],"source":" For example, the following\n`runtimes` node instructs the build system to create executables for the 64 bit version of Windows 10 and the 64 bit version of Mac OS X version 10.11."},{"content":"The build system will generate native executables for the current environment.","pos":[4645,4723],"source":"\nThe build system will generate native executables for the current environment."},{"content":"If you are following these steps on a Windows machine, you'll build a Windows executable.","pos":[4724,4813],"source":" If you are following these steps on a Windows machine,\nyou'll build a Windows executable."},{"content":"If you are following these steps on a Mac, you'll build the OS X executable.","pos":[4814,4890]},{"pos":[4963,5043],"content":"See the full list of supported runtimes in the <bpt id=\"p1\">[</bpt>RID catalog<ept id=\"p1\">](../rid-catalog.md)</ept>.","source":"See the full list of supported runtimes in the [RID catalog](../rid-catalog.md)."},{"content":"After making those two changes you execute <ph id=\"ph1\">`dotnet restore`</ph>, followed by <ph id=\"ph2\">`dotnet build`</ph> to create the native executable.","pos":[5047,5167],"source":"After making those two changes you execute `dotnet restore`, followed by `dotnet build` to create the native executable."},{"content":"Then, you can run the generated native executable.","pos":[5168,5218],"source":" Then, you can run the generated\nnative executable."},{"content":"The following example shows the commands for Windows.","pos":[5221,5274]},{"content":"The example shows where the native executable gets generated and assumes that the project directory is named HelloNative.","pos":[5275,5396]},{"content":"You may notice that the native application takes slightly longer to build, but executes slightly faster.","pos":[5508,5612]},{"content":"This behavior becomes more noticeable as the application grows.","pos":[5613,5676],"source":" This behavior\nbecomes more noticeable as the application grows."},{"content":"The build process generates several more files when your <ph id=\"ph1\">`project.json`</ph> creates a native build.","pos":[5678,5773],"source":"The build process generates several more files when your `project.json` creates a native build."},{"content":"These files are created in <ph id=\"ph1\">`bin\\Debug\\netcoreapp1.0\\&lt;platform&gt;`</ph> where <ph id=\"ph2\">`&lt;platform&gt;`</ph> is the RID chosen.","pos":[5774,5875],"source":" These files\nare created in `bin\\Debug\\netcoreapp1.0\\<platform>` where `<platform>` is the RID chosen."},{"content":"In addition to the project's <ph id=\"ph1\">`HelloNative.dll`</ph> there is a <ph id=\"ph2\">`HelloNative.exe`</ph> that loads the runtime and starts the application.","pos":[5876,6002],"source":" In addition to the\nproject's `HelloNative.dll` there is a `HelloNative.exe` that loads the runtime and starts the application."},{"content":"Note that the name of the generated application changed because the project directory's name has changed.","pos":[6003,6108],"source":"\nNote that the name of the generated application changed because the project directory's name has changed."},{"content":"You may want to package this application to execute it on a machine that does not include the .NET runtime.","pos":[6112,6219]},{"content":"You do that using the <ph id=\"ph1\">`dotnet publish`</ph> command.","pos":[6220,6267],"source":"\nYou do that using the `dotnet publish` command."},{"content":"The <ph id=\"ph1\">`dotnet publish`</ph> command creates a new subdirectory under the <ph id=\"ph2\">`./bin/Debug/netcoreapp1.0/&lt;platform&gt;`</ph> directory called <ph id=\"ph3\">`publish`</ph>.","pos":[6268,6400],"source":" The `dotnet publish` command creates a new subdirectory\nunder the `./bin/Debug/netcoreapp1.0/<platform>` directory called `publish`."},{"content":"It copies the executable, all dependent DLLs and the framework to this sub directory.","pos":[6401,6486],"source":" It copies the executable,\nall dependent DLLs and the framework to this sub directory."},{"content":"You can package that directory to another machine (or a container) and execute the application there.","pos":[6487,6588],"source":" You can package that directory to another machine\n(or a container) and execute the application there."},{"content":"Let's contrast that with the behavior of <ph id=\"ph1\">`dotnet publish`</ph> in the first Hello World sample.","pos":[6591,6681],"source":"Let's contrast that with the behavior of `dotnet publish` in the first Hello World sample."},{"content":"That application is a <bpt id=\"p1\">*</bpt>portable application<ept id=\"p1\">*</ept>, which is the default type of application for .NET Core.","pos":[6682,6783],"source":" That application\nis a *portable application*, which is the default type of application for .NET Core."},{"content":"A portable application requires that .NET Core is installed on the target machine.","pos":[6784,6866],"source":" A portable application\nrequires that .NET Core is installed on the target machine."},{"content":"Portable applications can be built on one machine and executed anywhere.","pos":[6867,6939],"source":" Portable applications can be built on one machine\nand executed anywhere."},{"content":"Native applications must be built separately for each target machine.","pos":[6940,7009]},{"content":"creates a directory that has the application's DLL, and any dependent dlls that are not part of the platform installation.","pos":[7027,7149],"source":"\ncreates a directory that has the application's DLL, and any dependent dlls that are not part of the platform\ninstallation."},{"content":"Augmenting the program","pos":[7155,7177]},{"content":"Let's change the file just a little bit.","pos":[7179,7219]},{"content":"Fibonacci numbers are fun, so let's try that out (using the native version):","pos":[7221,7297],"source":"  Fibonacci numbers are fun, so let's try that out (using\nthe native version):"},{"pos":[7311,7312],"content":":"},{"content":"And running the program (assuming you're on Windows, and have changed the project directory name to Fibonacci):","pos":[8064,8175]},{"content":"And that's it!","pos":[8345,8359]},{"content":"You can augment <ph id=\"ph1\">`Program.cs`</ph> any way you like.","pos":[8361,8407],"source":"  You can augment `Program.cs` any way you like."},{"content":"Adding some new files","pos":[8412,8433]},{"content":"Single files are fine for simple one-off programs, but chances are you're going to want to break things out into multiple files if you're building anything which has multiple components.","pos":[8435,8621]},{"content":"Multiple files are a way to do that.","pos":[8623,8659]},{"content":"Create a new file and give it a unique namespace:","pos":[8661,8710]},{"pos":[8791,8834],"content":"Next, include it in your <ph id=\"ph1\">`Program.cs`</ph> file:","source":"Next, include it in your `Program.cs` file:"},{"content":"And finally, you can build it:","pos":[8897,8927]},{"content":"Now the fun part: making the new file do something!","pos":[8947,8998]},{"content":"Example: A Fibonacci Sequence Generator","pos":[9004,9043]},{"content":"Let's say you want to build off of the previous <bpt id=\"p1\">[</bpt>Fibonacci example<ept id=\"p1\">](https://github.com/dotnet/core-docs/tree/master/samples/core-projects/console-apps/Fibonacci)</ept> by caching some Fibonacci values and add some recursive flair.","pos":[9045,9269],"source":"Let's say you want to build off of the previous [Fibonacci example](https://github.com/dotnet/core-docs/tree/master/samples/core-projects/console-apps/Fibonacci) by caching some Fibonacci values and add some recursive flair."},{"content":"Your code for a <bpt id=\"p1\">[</bpt>better Fibonacci example<ept id=\"p1\">](https://github.com/dotnet/core-docs/tree/master/samples/core-projects/console-apps/FibonacciBetter)</ept> might look something like this:","pos":[9271,9445],"source":"  Your code for a [better Fibonacci example](https://github.com/dotnet/core-docs/tree/master/samples/core-projects/console-apps/FibonacciBetter) might look something like this:"},{"content":"Note that the use of <ph id=\"ph1\">`Dictionary&lt;int, int&gt;`</ph> and <ph id=\"ph2\">`IEnumerable&lt;int&gt;`</ph> means incorporating the <ph id=\"ph3\">`System.Collections`</ph> namespace.","pos":[10149,10271],"source":"Note that the use of `Dictionary<int, int>` and `IEnumerable<int>` means incorporating the `System.Collections` namespace."},{"content":"The <ph id=\"ph1\">`Microsoft.NetCore.App`</ph> package is a <bpt id=\"p1\">*</bpt>metapackage<ept id=\"p1\">*</ept> that contains many of the core assemblies from the .NET Framework.","pos":[10272,10393],"source":"\nThe `Microsoft.NetCore.App` package is a *metapackage* that contains many of the core\nassemblies from the .NET Framework."},{"content":"By including this metapackage, you've already included the <ph id=\"ph1\">`System.Collections.dll`</ph> assembly as part of your project.","pos":[10394,10511],"source":" By including this metapackage, you've already included\nthe `System.Collections.dll` assembly as part of your project."},{"content":"You can verify this by running <ph id=\"ph1\">`dotnet publish`</ph> and examining the files that are part of the installed package.","pos":[10512,10623],"source":" You can verify this by\nrunning `dotnet publish` and examining the files that are part of the installed\npackage."},{"content":"You'll see <ph id=\"ph1\">`System.Collections.dll`</ph> in the list.","pos":[10624,10672],"source":" You'll see `System.Collections.dll` in the list."},{"content":"Now adjust the <ph id=\"ph1\">`Main()`</ph> method in your <ph id=\"ph2\">`Program.cs`</ph> file as shown below.","pos":[11088,11160],"source":"Now adjust the `Main()` method in your `Program.cs` file as shown below."},{"content":"The example assumes that <ph id=\"ph1\">`Program.cs`</ph> has a <ph id=\"ph2\">`using System;`</ph> statement.","pos":[11161,11231],"source":" The example assumes that `Program.cs` has a `using System;` statement."},{"content":"If you have a <ph id=\"ph1\">`using static System.Console;`</ph> statement, remove <ph id=\"ph2\">`Console.`</ph> from <ph id=\"ph3\">`Console.WriteLine`</ph>.","pos":[11232,11331],"source":" If you have a `using static System.Console;` statement, remove `Console.` from `Console.WriteLine`."},{"content":"Finally, run it!","pos":[11527,11543]},{"content":"And that's it!","pos":[11608,11622]},{"content":"Using folders to organize code","pos":[11627,11657]},{"content":"Say you wanted to introduce some new types to do work on.","pos":[11659,11716]},{"content":"You can do this by adding more files and making sure to give them namespaces you can include in your <ph id=\"ph1\">`Program.cs`</ph> file.","pos":[11718,11837],"source":"  You can do this by adding more files and making sure to give them namespaces you can include in your `Program.cs` file."},{"content":"This works great when the size of your project is relatively small.","pos":[11941,12008]},{"content":"However, if you have a larger app with many different data types and potentially multiple layers, you may wish to organize things logically.","pos":[12010,12150]},{"content":"This is where folders come into play.","pos":[12152,12189]},{"content":"You can either follow along with <bpt id=\"p1\">[</bpt>the NewTypes sample project<ept id=\"p1\">](https://github.com/dotnet/core-docs/tree/master/samples/core-projects/console-apps/NewTypes)</ept> that this guide covers, or create your own files and folders.","pos":[12191,12408],"source":"  You can either follow along with [the NewTypes sample project](https://github.com/dotnet/core-docs/tree/master/samples/core-projects/console-apps/NewTypes) that this guide covers, or create your own files and folders."},{"content":"To begin, create a new folder under the root of your project.","pos":[12410,12471]},{"content":"is chosen here.","pos":[12482,12497]},{"content":"Now add some new types to the folder:","pos":[12558,12595]},{"pos":[12714,12847],"content":"Now, just as if they were files in the same directory, give them all the same namespace so you can include them in your <ph id=\"ph1\">`Program.cs`</ph>.","source":"Now, just as if they were files in the same directory, give them all the same namespace so you can include them in your `Program.cs`."},{"content":"Example: Pet Types","pos":[12853,12871]},{"pos":[12873,12970],"content":"This example creates two new types, <ph id=\"ph1\">`Dog`</ph> and <ph id=\"ph2\">`Cat`</ph>, and has them implement an interface, <ph id=\"ph3\">`IPet`</ph>.","source":"This example creates two new types, `Dog` and `Cat`, and has them implement an interface, `IPet`."},{"content":"Folder Structure:","pos":[12972,12989]},{"pos":[13098,13099],"content":":"},{"pos":[13225,13226],"content":":"},{"pos":[13372,13373],"content":":"},{"pos":[13523,13524],"content":":"},{"pos":[14014,14015],"content":":"},{"content":"And if you run this:","pos":[14302,14322]},{"pos":[14375,14445],"content":"New pet types can be added (such as a <ph id=\"ph1\">`Bird`</ph>), extending this project.","source":"New pet types can be added (such as a `Bird`), extending this project."},{"content":"Testing your Console App","pos":[14450,14474]},{"content":"You'll probably be wanting to test your projects at some point.","pos":[14476,14539]},{"content":"Here's a good way to do it:","pos":[14541,14568]},{"pos":[14573,14638],"content":"Move any source of your existing project into a new <ph id=\"ph1\">`src`</ph> folder.","source":"Move any source of your existing project into a new `src` folder."},{"pos":[14681,14708],"content":"Create a <ph id=\"ph1\">`/test`</ph> directory.","source":"Create a `/test` directory."},{"pos":[14763,14795],"content":"Create a new <ph id=\"ph1\">`global.json`</ph> file:","source":"Create a new `global.json` file:"},{"pos":[14881,14882],"content":":"},{"content":"This file tells the build system that this is a multi-project system, which allows it to look for dependencies in more than just the current folder it happens to be executing in.","pos":[14966,15144]},{"content":"This is important because it allows you to place a dependency on the code under test in your test project.","pos":[15146,15252]},{"content":"Example: Extending the NewTypes project","pos":[15261,15300]},{"content":"Now that the project system is in place, you can create your test project and start writing tests!","pos":[15302,15400]},{"content":"From here on out, this guide will use and extend <bpt id=\"p1\">[</bpt>the sample Types project<ept id=\"p1\">](https://github.com/dotnet/core-docs/tree/master/samples/core-projects/console-apps/NewTypes)</ept>.","pos":[15402,15571],"source":"  From here on out, this guide will use and extend [the sample Types project](https://github.com/dotnet/core-docs/tree/master/samples/core-projects/console-apps/NewTypes)."},{"content":"Additionally, it will use the <bpt id=\"p1\">[</bpt>Xunit<ept id=\"p1\">](https://xunit.github.io/)</ept> test framework.","pos":[15573,15652],"source":"  Additionally, it will use the [Xunit](https://xunit.github.io/) test framework."},{"content":"Feel free to follow along or create your own multi-project system with tests.","pos":[15654,15731]},{"content":"The whole project structure should look like this:","pos":[15734,15784]},{"content":"There are two new things to make sure you have in your test project:","pos":[16031,16099]},{"pos":[16104,16148],"content":"A correct <ph id=\"ph1\">`project.json`</ph> with the following:","source":"A correct `project.json` with the following:"},{"pos":[16155,16169],"content":"A reference to"},{"pos":[16183,16197],"content":"A reference to"},{"content":"A reference to the namespace corresponding to the code under test","pos":[16223,16288]},{"content":"An Xunit test class.","pos":[16293,16313]},{"pos":[16343,16344],"content":":"},{"pos":[16782,16783],"content":":"},{"content":"Now you can run tests!","pos":[17259,17281]},{"content":"The <bpt id=\"p1\">[</bpt><ph id=\"ph1\">`dotnet test`</ph><ept id=\"p1\">](../tools/dotnet-test.md)</ept> command runs the test runner you have specified in your project.","pos":[17283,17392],"source":"  The [`dotnet test`](../tools/dotnet-test.md) command runs the test runner you have specified in your project."},{"content":"Make sure you start at the top-level directory.","pos":[17393,17440]},{"content":"Output should look like this:","pos":[17508,17537]},{"content":"Conclusion","pos":[17874,17884]},{"content":"Hopefully this guide has helped you learn how to create a .NET Core console app, from the basics all the way up to a multi-project system with unit tests.","pos":[17887,18041]},{"content":"The next step is to create awesome console apps of your own!","pos":[18043,18103]},{"pos":[18106,18308],"content":"If a more advanced example of a console app interests you, check out the next tutorial: <bpt id=\"p1\">[</bpt>Using the CLI tools to write console apps: An advanced step-by-step guide<ept id=\"p1\">](cli-console-app-tutorial-advanced.md)</ept>.","source":"If a more advanced example of a console app interests you, check out the next tutorial: [Using the CLI tools to write console apps: An advanced step-by-step guide](cli-console-app-tutorial-advanced.md)."}],"content":"---\ntitle: Getting started with .NET Core on Windows/Linux/macOS using the command line\ndescription: Getting started with .NET Core on Windows, Linux, or macOS using the .NET Core command line interface (CLI)\nkeywords: .NET, .NET Core\nauthor: cartermp\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: be988f09-7349-43b0-97fb-3a703d4587ce\n---\n\n# Getting started with .NET Core on Windows/Linux/macOS using the command line\n\nThis guide will show you how to use the .NET Core CLI tooling to build cross-platform console apps.  It will start with the most basic console app and eventually span multiple projects, including testing. You'll add these features step-by-step, building on what you've already seen and built.\n\nIf you're unfamiliar with the .NET Core CLI toolset, read [the .NET Core SDK overview](../sdk.md).\n\n## Prerequisites\n\nBefore you begin, ensure you have the [latest .NET Core CLI tooling](https://www.microsoft.com/net/core).  You'll also need a text editor.\n\n## Hello, Console App!\n\nFirst, navigate to or create a new folder with a name you like.  \"Hello\" is the name chosen for the sample code, which can be found [here](https://github.com/dotnet/core-docs/tree/master/samples/core-projects/console-apps/Hello).\n\nOpen up a command prompt and type the following:\n\n```\n$ dotnet new\n$ dotnet restore\n$ dotnet run\n```\n\nLet's do a quick walkthrough:\n\n1. `$ dotnet new`\n\n   [`dotnet new`](../tools/dotnet-new.md) creates an up-to-date `project.json` file with NuGet dependencies necessary to build a console app.  It also creates a `Program.cs`, a basic file containing the entry point for the application.\n   \n   `project.json`:\n   ```json\n   {\n        \"version\": \"1.0.0-*\",\n        \"buildOptions\": {\n            \"emitEntryPoint\": true\n        },\n        \"dependencies\": {\n            \"Microsoft.NETCore.App\": {\n                \"type\": \"platform\",\n                \"version\": \"1.0.0\"\n            }\n        },   \n       \"frameworks\": {\n            \"netcoreapp1.0\": {\n                \"imports\": \"dnxcore50\"\n            }\n        }\n   }\n   ```\n   `Program.cs`:\n   ```csharp\n   using System;\n\n   namespace ConsoleApplication\n   {\n       public class Program\n       {\n           public static void Main(string[] args)\n           {\n               Console.WriteLine(\"Hello World!\");\n           }\n       }\n   }\n   ```\n\n2. `$ dotnet restore`\n\n   [`dotnet restore`](../tools/dotnet-restore.md) calls into NuGet to restore the tree of dependencies. NuGet analyzes the `project.json` file, downloads the dependencies stated in the file (or grabs them from a cache on your machine), and writes the `project.lock.json` file.  The `project.lock.json` file is necessary to be able to compile and run.\n   \n   The `project.lock.json` file is a persisted and complete set of the graph of NuGet dependencies and other information describing an app.  This file is read by other tools, such as `dotnet build` and `dotnet run`, enabling them to process the source code with a correct set of NuGet dependencies and binding resolutions.\n   \n3. `$ dotnet run`\n\n   [`dotnet run`](../tools/dotnet-run.md) calls `dotnet build` to ensure that the build targets have been built, and then calls `dotnet <assembly.dll>` to run the target application.\n   \n```\n$ dotnet run\nHello, World!\n```\n\nYou can also execute [`dotnet build`](../tools/dotnet-build.md) to compile and the code without running the build console applications.\n\n### Building a self-contained application\n\nLet's try compiling a self-contained application instead of a portable application. You can read more about the [types of portability in .NET Core](../app-types.md) to learn about the different application types, and how they are deployed.\n\nYou need to make some changes to your `project.json`\nfile to direct the tools to build a self-contained application. You can see these in the\n[HelloNative](https://github.com/dotnet/core-docs/tree/master/samples/core-projects/console-apps/HelloNative)\nproject in the samples directory.\n\nThe first change is to remove the `\"type\": \"platform\"` element from all dependencies. \nThis project's only dependency so far is `\"Microsoft.NETCore.App\"`. The `dependencies` section should look like this:\n\n```json\n\"dependencies\": {\n    \"Microsoft.NETCore.App\": {\n        \"version\": \"1.0.0\"\n    }\n},\n```\n\nNext, you need to add a `runtimes` node to specify all the target execution environments. For example, the following\n`runtimes` node instructs the build system to create executables for the 64 bit version of Windows 10 and the 64 bit version of Mac OS X version 10.11.\nThe build system will generate native executables for the current environment. If you are following these steps on a Windows machine,\nyou'll build a Windows executable. If you are following these steps on a Mac, you'll build the OS X executable.\n\n```json \n\"runtimes\": {\n  \"win10-x64\": {},\n  \"osx.10.11-x64\": {}\n}\n```\n\nSee the full list of supported runtimes in the [RID catalog](../rid-catalog.md). \n \nAfter making those two changes you execute `dotnet restore`, followed by `dotnet build` to create the native executable. Then, you can run the generated\nnative executable. \n\nThe following example shows the commands for Windows. The example shows where the native executable gets generated and assumes that the project directory is named HelloNative.\n\n```\n$ dotnet restore \n$ dotnet build \n$ .\\bin\\Debug\\netcoreapp1.0\\win10-x64\\HelloNative.exe\nHello World!\n```\n\nYou may notice that the native application takes slightly longer to build, but executes slightly faster. This behavior\nbecomes more noticeable as the application grows.\n\nThe build process generates several more files when your `project.json` creates a native build. These files\nare created in `bin\\Debug\\netcoreapp1.0\\<platform>` where `<platform>` is the RID chosen. In addition to the\nproject's `HelloNative.dll` there is a `HelloNative.exe` that loads the runtime and starts the application.\nNote that the name of the generated application changed because the project directory's name has changed.  \n\nYou may want to package this application to execute it on a machine that does not include the .NET runtime.\nYou do that using the `dotnet publish` command. The `dotnet publish` command creates a new subdirectory\nunder the `./bin/Debug/netcoreapp1.0/<platform>` directory called `publish`. It copies the executable,\nall dependent DLLs and the framework to this sub directory. You can package that directory to another machine\n(or a container) and execute the application there. \n\nLet's contrast that with the behavior of `dotnet publish` in the first Hello World sample. That application\nis a *portable application*, which is the default type of application for .NET Core. A portable application\nrequires that .NET Core is installed on the target machine. Portable applications can be built on one machine\nand executed anywhere. Native applications must be built separately for each target machine. `dotnet publish`\ncreates a directory that has the application's DLL, and any dependent dlls that are not part of the platform\ninstallation.\n\n### Augmenting the program\n\nLet's change the file just a little bit.  Fibonacci numbers are fun, so let's try that out (using\nthe native version):\n\n`Program.cs`:\n\n```csharp\nusing static System.Console;\n\nnamespace ConsoleApplication\n{\n    public class Program\n    {\n        public static int FibonacciNumber(int n)\n        {\n            int a = 0;\n            int b = 1;\n            int tmp;\n            \n            for (int i = 0; i < n; i++)\n            {\n                tmp = a;\n                a = b;\n                b += tmp;\n            }\n            \n            return a;   \n        }\n        \n        public static void Main(string[] args)\n        {\n            WriteLine(\"Hello World!\");\n            WriteLine(\"Fibonacci Numbers 1-15:\");\n            \n            for (int i = 0; i < 15; i++)\n            {\n                WriteLine($\"{i+1}: {FibonacciNumber(i)}\");\n            }\n        }\n    }\n}\n```\n\nAnd running the program (assuming you're on Windows, and have changed the project directory name to Fibonacci):\n\n```\n$ dotnet build\n$ .\\bin\\Debug\\netcoreapp1.0\\win10-x64\\Fibonacci.exe\n1: 0\n2: 1\n3: 1\n4: 2\n5: 3\n6: 5\n7: 8\n8: 13\n9: 21\n10: 34\n11: 55\n12: 89\n13: 144\n14: 233\n15: 377\n```\n\nAnd that's it!  You can augment `Program.cs` any way you like.\n\n## Adding some new files\n\nSingle files are fine for simple one-off programs, but chances are you're going to want to break things out into multiple files if you're building anything which has multiple components.  Multiple files are a way to do that.\n\nCreate a new file and give it a unique namespace:\n\n```csharp\nusing System;\n\nnamespace NumberFun\n{\n    // code can go here\n} \n```\n\nNext, include it in your `Program.cs` file:\n\n```csharp\nusing static System.Console;\nusing NumberFun;\n```\n\nAnd finally, you can build it:\n\n`$ dotnet build`\n\nNow the fun part: making the new file do something!\n\n### Example: A Fibonacci Sequence Generator\n\nLet's say you want to build off of the previous [Fibonacci example](https://github.com/dotnet/core-docs/tree/master/samples/core-projects/console-apps/Fibonacci) by caching some Fibonacci values and add some recursive flair.  Your code for a [better Fibonacci example](https://github.com/dotnet/core-docs/tree/master/samples/core-projects/console-apps/FibonacciBetter) might look something like this:\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\nnamespace NumberFun\n{\n    public class FibonacciGenerator\n    {\n        private Dictionary<int, int> _cache = new Dictionary<int, int>();\n        \n        private int Fib(int n) => n < 2 ? n : FibValue(n - 1) + FibValue(n - 2);\n        \n        private int FibValue(int n)\n        {\n            if (!_cache.ContainsKey(n))\n            {\n                _cache.Add(n, Fib(n));\n            }\n            \n            return _cache[n];\n        }\n        \n        public IEnumerable<int> Generate(int n)\n        {\n            for (int i = 0; i < n; i++)\n            {\n                yield return FibValue(i);\n            }\n        }\n    }\n}\n```\n\nNote that the use of `Dictionary<int, int>` and `IEnumerable<int>` means incorporating the `System.Collections` namespace.\nThe `Microsoft.NetCore.App` package is a *metapackage* that contains many of the core\nassemblies from the .NET Framework. By including this metapackage, you've already included\nthe `System.Collections.dll` assembly as part of your project. You can verify this by\nrunning `dotnet publish` and examining the files that are part of the installed\npackage. You'll see `System.Collections.dll` in the list. \n\n```json\n{ \n  \"version\": \"1.0.0-*\", \n  \"buildOptions\": { \n    \"debugType\": \"portable\", \n    \"emitEntryPoint\": true \n  }, \n  \"dependencies\": {}, \n  \"frameworks\": { \n    \"netcoreapp1.0\": { \n      \"dependencies\": { \n        \"Microsoft.NETCore.App\": { \n          \"version\": \"1.0.0\" \n        } \n      }, \n      \"imports\": \"dnxcore50\" \n    } \n  },\n  \"runtimes\": {\n    \"win10-x64\": {},\n    \"osx.10.11-x64\": {}\n  }\n}\n```\n\nNow adjust the `Main()` method in your `Program.cs` file as shown below. The example assumes that `Program.cs` has a `using System;` statement. If you have a `using static System.Console;` statement, remove `Console.` from `Console.WriteLine`.  \n\n```csharp\npublic static void Main(string[] args)\n{\n    var generator = new FibonacciGenerator();\n    foreach (var digit in generator.Generate(15))\n    {\n        WriteLine(digit);\n    }\n}\n```\n\nFinally, run it!\n\n```\n$ dotnet run\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n144\n233\n377\n```\n\nAnd that's it!\n\n## Using folders to organize code\n\nSay you wanted to introduce some new types to do work on.  You can do this by adding more files and making sure to give them namespaces you can include in your `Program.cs` file.\n\n```\n/MyProject\n|__Program.cs\n|__AccountInformation.cs\n|__MonthlyReportRecords.cs\n|__project.json\n```\n\nThis works great when the size of your project is relatively small.  However, if you have a larger app with many different data types and potentially multiple layers, you may wish to organize things logically.  This is where folders come into play.  You can either follow along with [the NewTypes sample project](https://github.com/dotnet/core-docs/tree/master/samples/core-projects/console-apps/NewTypes) that this guide covers, or create your own files and folders.\n\nTo begin, create a new folder under the root of your project.  `/Model` is chosen here.\n\n```\n/NewTypes\n|__/Model\n|__Program.cs\n|__project.json\n```\n\nNow add some new types to the folder:\n\n```\n/NewTypes\n|__/Model\n   |__AccountInformation.cs\n   |__MonthlyReportRecords.cs\n|__Program.cs\n|__project.json\n```\n\nNow, just as if they were files in the same directory, give them all the same namespace so you can include them in your `Program.cs`.\n\n### Example: Pet Types\n\nThis example creates two new types, `Dog` and `Cat`, and has them implement an interface, `IPet`.\n\nFolder Structure:\n\n```\n/NewTypes\n|__/Pets\n   |__Dog.cs\n   |__Cat.cs\n   |__IPet.cs\n|__Program.cs\n|__project.json\n```\n\n`IPet.cs`:\n```csharp\nusing System;\n\nnamespace Pets\n{\n    public interface IPet\n    {\n        string TalkToOwner();\n    }\n}\n```\n\n`Dog.cs`:\n```csharp\nusing System;\n\nnamespace Pets\n{\n    public class Dog : IPet\n    {\n        public string TalkToOwner() => \"Woof!\";\n    }\n}\n```\n\n`Cat.cs`:\n```csharp\nusing System;\n\nnamespace Pets\n{\n    public class Cat : IPet\n    {\n        public string TalkToOwner() => \"Meow!\";\n    }\n}\n```\n\n`Program.cs`:\n```csharp\nusing System;\nusing Pets;\nusing System.Collections.Generic;\n\nnamespace ConsoleApplication\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            List<IPet> pets = new List<IPet>\n            {\n                new Dog(),\n                new Cat()  \n            };\n            \n            foreach (var pet in pets)\n            {\n                Console.WriteLine(pet.TalkToOwner());\n            }\n        }\n    }\n}\n```\n\n`project.json`:\n```json\n{\n  \"version\": \"1.0.0-*\",\n  \"buildOptions\": {\n    \"emitEntryPoint\": true\n  },\n  \"dependencies\": {\n    \"Microsoft.NETCore.App\": {\n      \"type\": \"platform\",\n      \"version\": \"1.0.0\"\n    }\n  },\n  \"frameworks\": {\n    \"netcoreapp1.0\": {\n      \"imports\": \"dnxcore50\"\n    }\n  }\n}\n```\n\nAnd if you run this:\n\n```\n$ dotnet restore\n$ dotnet run\nWoof!\nMeow!\n```\n\nNew pet types can be added (such as a `Bird`), extending this project.\n\n## Testing your Console App\n\nYou'll probably be wanting to test your projects at some point.  Here's a good way to do it:\n\n1. Move any source of your existing project into a new `src` folder.\n\n   ```\n   /Project\n   |__/src\n   ```\n\n2. Create a `/test` directory.\n\n   ```\n   /Project\n   |__/src\n   |__/test\n   ```\n\n3. Create a new `global.json` file:\n\n   ```\n   /Project\n   |__/src\n   |__/test\n   |__global.json\n   ```\n\n   `global.json`:\n   ```json\n   {\n      \"projects\": [\n         \"src\", \"test\"\n      ]\n   }\n   ```\n\n   This file tells the build system that this is a multi-project system, which allows it to look for dependencies in more than just the current folder it happens to be executing in.  This is important because it allows you to place a dependency on the code under test in your test project.\n   \n### Example: Extending the NewTypes project\n\nNow that the project system is in place, you can create your test project and start writing tests!  From here on out, this guide will use and extend [the sample Types project](https://github.com/dotnet/core-docs/tree/master/samples/core-projects/console-apps/NewTypes).  Additionally, it will use the [Xunit](https://xunit.github.io/) test framework.  Feel free to follow along or create your own multi-project system with tests.\n\n\nThe whole project structure should look like this:\n\n```\n/NewTypes\n|__/src\n   |__/NewTypes\n      |__/Pets\n         |__Dog.cs\n         |__Cat.cs\n         |__IPet.cs\n      |__Program.cs\n      |__project.json\n|__/test\n   |__NewTypesTests\n      |__PetTests.cs\n      |__project.json\n|__global.json\n```\n\nThere are two new things to make sure you have in your test project:\n\n1. A correct `project.json` with the following:\n\n   * A reference to `xunit`\n   * A reference to `dotnet-test-xunit`\n   * A reference to the namespace corresponding to the code under test\n\n2. An Xunit test class.\n\n`NewTypesTests/project.json`:\n```json\n{\n  \"version\": \"1.0.0-*\",\n  \"testRunner\": \"xunit\",\n\n  \"dependencies\": {\n    \"Microsoft.NETCore.App\": {\n      \"type\":\"platform\",\n      \"version\": \"1.0.0\"\n    },\n    \"xunit\":\"2.2.0-beta2-build3300\",\n    \"dotnet-test-xunit\": \"2.2.0-preview2-build1029\",\n    \"NewTypes\": \"1.0.0\"\n  },\n  \"frameworks\": {\n    \"netcoreapp1.0\": {\n      \"imports\": [\n        \"dnxcore50\",\n        \"portable-net45+win8\" \n      ]\n    }\n  }\n}\n```\n\n`PetTests.cs`: \n```csharp\nusing System;\nusing Xunit;\nusing Pets;\npublic class PetTests\n{\n    [Fact]\n    public void DogTalkToOwnerTest()\n    {\n        string expected = \"Woof!\";\n        string actual = new Dog().TalkToOwner();\n        \n        Assert.Equal(expected, actual);\n    }\n    \n    [Fact]\n    public void CatTalkToOwnerTest()\n    {\n        string expected = \"Meow!\";\n        string actual = new Cat().TalkToOwner();\n        \n        Assert.Equal(expected, actual);\n    }\n}\n```\n   \nNow you can run tests!  The [`dotnet test`](../tools/dotnet-test.md) command runs the test runner you have specified in your project. Make sure you start at the top-level directory.\n \n```\n$ dotnet restore\n$ cd test/NewTypesTests\n$ dotnet test\n```\n \nOutput should look like this:\n \n```\nxUnit.net .NET CLI test runner (64-bit win10-x64)\n  Discovering: NewTypesTests\n  Discovered:  NewTypesTests\n  Starting:    NewTypesTests\n  Finished:    NewTypesTests\n=== TEST EXECUTION SUMMARY ===\n   NewTypesTests  Total: 2, Errors: 0, Failed: 0, Skipped: 0, Time: 0.144s\nSUMMARY: Total: 1 targets, Passed: 1, Failed: 0.\n```\n \n## Conclusion\n \nHopefully this guide has helped you learn how to create a .NET Core console app, from the basics all the way up to a multi-project system with unit tests.  The next step is to create awesome console apps of your own!\n \nIf a more advanced example of a console app interests you, check out the next tutorial: [Using the CLI tools to write console apps: An advanced step-by-step guide](cli-console-app-tutorial-advanced.md).\n"}