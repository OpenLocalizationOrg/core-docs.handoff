{"nodes":[{"pos":[11,54],"content":"Framework Types Supporting Expression Trees","needQuote":true,"nodes":[{"content":"Framework Types Supporting Expression Trees","pos":[0,43]}]},{"pos":[68,111],"content":"Framework Types Supporting Expression Trees","needQuote":true,"nodes":[{"content":"Framework Types Supporting Expression Trees","pos":[0,43]}]},{"pos":[122,137],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":"Framework Types Supporting Expression Trees","pos":[345,388]},{"content":"Previous -- Expression Trees Explained","pos":[391,429]},{"content":"There is a large list of classes in the .NET Core framework that work with Expression Trees.","pos":[463,555]},{"content":"You can see the full list <bpt id=\"p1\">[</bpt>here<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Linq.Expressions)</ept>.","pos":[556,657],"source":"\nYou can see the full\nlist [here](https://docs.microsoft.com/dotnet/core/api/System.Linq.Expressions)."},{"content":"Rather than run through the full list, let's understand how the framework classes have been designed.","pos":[658,759],"source":"\nRather than run through the full list, let's understand how the framework classes have been designed."},{"content":"In language design, an expression is a body of code that evaluates and returns a value.","pos":[761,848]},{"content":"Expressions may be very simple: the constant expression <ph id=\"ph1\">`1`</ph> returns the constant value of 1.","pos":[849,941],"source":" Expressions\nmay be very simple: the constant expression `1` returns the constant value of 1."},{"content":"They may be more complicated: The expression <ph id=\"ph1\">`(-B + Math.Sqrt(B*B + 4 * A * C)) / (2 * A)`</ph> returns one root for a quadratic equation (in the case where the equation has a solution).","pos":[942,1123],"source":" They may be more\ncomplicated: The expression `(-B + Math.Sqrt(B*B + 4 * A * C)) / (2 * A)` returns one root for a\nquadratic equation (in the case where the equation has a solution)."},{"content":"It all starts with System.Linq.Expression","pos":[1130,1171]},{"content":"One of the complexities of working with expression trees is that many different kinds of expressions are valid in many places in programs.","pos":[1173,1311],"source":"One of the complexities of working with expression trees is that many different\nkinds of expressions are valid in many places in programs."},{"content":"Consider an assignment expression.","pos":[1312,1346],"source":" Consider an assignment\nexpression."},{"content":"The right hand side of an assignment could be a constant value, a variable, a method call expression, or others.","pos":[1347,1459],"source":" The right hand side of an assignment could be a constant value, a variable,\na method call expression, or others."},{"content":"That language flexibility means that you may encounter many different expression types anywhere in the nodes of a tree when you traverse an expression tree.","pos":[1460,1616],"source":" That language flexibility means that you may encounter\nmany different expression types anywhere in the nodes of a tree when you traverse an\nexpression tree."},{"content":"Therefore, when you can work with the base expression type, that's the simplest way to work.","pos":[1617,1709],"source":" Therefore, when you can work with the base expression type, that's\nthe simplest way to work."},{"content":"However, sometimes you need to know more.","pos":[1710,1751]},{"content":"The base Expression class contains a <ph id=\"ph1\">`NodeType`</ph> property for this purpose.","pos":[1752,1826],"source":"\nThe base Expression class contains a `NodeType` property for this purpose."},{"content":"It returns an <ph id=\"ph1\">`ExpressionType`</ph> which is an enumeration of possible expression types.","pos":[1827,1911],"source":"\nIt returns an `ExpressionType` which is an enumeration of possible expression types."},{"content":"Once you know the type of the node, you can cast it to that type, and perform specific actions knowing the type of the expression node.","pos":[1912,2047],"source":"\nOnce you know the type of the node, you can cast it to that type, and perform\nspecific actions knowing the type of the expression node."},{"content":"You can search for certain node types, and then work with the specific properties of that kind of expression.","pos":[2048,2157],"source":" You can search for certain\nnode types, and then work with the specific properties of that kind of expression."},{"content":"For example, this code will print the name of a variable for a variable access expression.","pos":[2159,2249],"source":"For example, this code will print the name of a variable for a variable access\nexpression."},{"content":"I've followed the practice of checking the node type, then casting to a variable access expression and then checking the properties of the specific expression type:","pos":[2250,2414],"source":" I've followed the practice of checking the node type, then\ncasting to a variable access expression and then checking the properties of\nthe specific expression type:"},{"content":"Creating Expression Trees","pos":[2714,2739]},{"content":"The <ph id=\"ph1\">`System.Linq.Expression`</ph> class also contains many static methods to create expressions.","pos":[2741,2832],"source":"The `System.Linq.Expression` class also contains many static methods to create expressions."},{"content":"These methods create an expression node using the arguments supplied for its children.","pos":[2833,2919],"source":" These\nmethods create an expression node using the arguments supplied for its children."},{"content":"In this way, you build an expression up from its leaf nodes.","pos":[2920,2980],"source":" In this way,\nyou build an expression up from its leaf nodes."},{"content":"For example, this code builds an Add expression:","pos":[2981,3029]},{"content":"You can see from this simple example that many types are involved in creating and working with expression trees.","pos":[3222,3334],"source":"You can see from this simple example that many types are involved in creating and working\nwith expression trees."},{"content":"That complexity is necessary to provide the capabilities of the rich vocabulary provided by the C# language.","pos":[3335,3443],"source":" That complexity is necessary to provide the capabilities of\nthe rich vocabulary provided by the C# language."},{"content":"Navigating the APIs","pos":[3448,3467]},{"content":"There are Expression node types that map to almost all of the syntax elements of the C# language.","pos":[3468,3565],"source":"There are Expression node types that map to almost all of the syntax elements of the\nC# language."},{"content":"Each type has specific methods for that type of language element.","pos":[3566,3631]},{"content":"It's a lot to keep in your head at one time.","pos":[3632,3676],"source":" It's a lot\nto keep in your head at one time."},{"content":"Rather than try to memorize everything, here are the techniques I use to work with Expression trees:","pos":[3677,3777],"source":" Rather than try to memorize everything, here are the techniques\nI use to work with Expression trees:"},{"content":"Look at the members of the <ph id=\"ph1\">`ExpressionType`</ph> enum to determine possible nodes you should be examining.","pos":[3781,3882],"source":"Look at the members of the `ExpressionType` enum to determine possible nodes you should be\nexamining."},{"content":"This really helps when you want to traverse and understand an expression tree.","pos":[3883,3961]},{"content":"Look at the static members of the <ph id=\"ph1\">`Expression`</ph> class to build an expression.","pos":[3965,4041],"source":"Look at the static members of the `Expression` class to build an expression."},{"content":"Those methods can build any expression type from a set of its child nodes.","pos":[4042,4116],"source":" Those methods\ncan build any expression type from a set of its child nodes."},{"pos":[4120,4194],"content":"Look at the <ph id=\"ph1\">`ExpressionVisitor`</ph> class to build a modified expression tree.","source":"Look at the `ExpressionVisitor` class to build a modified expression tree."},{"content":"You'll find more as you look at each of those three areas.","pos":[4196,4254]},{"content":"Invariably, you will find what you need when you start with one of those three steps.","pos":[4255,4340],"source":" Invariably, you will find what you need when\nyou start with one of those three steps."},{"content":"Next -- Executing Expression Trees","pos":[4345,4379]}],"content":"---\ntitle: Framework Types Supporting Expression Trees\ndescription: Framework Types Supporting Expression Trees\nkeywords: .NET, .NET Core\nauthor: BillWagner\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: e9c85021-0d36-48af-91b7-aaaa66f22654\n---\n\n# Framework Types Supporting Expression Trees\n\n[Previous -- Expression Trees Explained](expression-trees-explained.md)\n\nThere is a large list of classes in the .NET Core framework that work with Expression Trees.\nYou can see the full\nlist [here](https://docs.microsoft.com/dotnet/core/api/System.Linq.Expressions).\nRather than run through the full list, let's understand how the framework classes have been designed.\n\nIn language design, an expression is a body of code that evaluates and returns a value. Expressions\nmay be very simple: the constant expression `1` returns the constant value of 1. They may be more\ncomplicated: The expression `(-B + Math.Sqrt(B*B + 4 * A * C)) / (2 * A)` returns one root for a\nquadratic equation (in the case where the equation has a solution).  \n\n## It all starts with System.Linq.Expression\n\nOne of the complexities of working with expression trees is that many different\nkinds of expressions are valid in many places in programs. Consider an assignment\nexpression. The right hand side of an assignment could be a constant value, a variable,\na method call expression, or others. That language flexibility means that you may encounter\nmany different expression types anywhere in the nodes of a tree when you traverse an\nexpression tree. Therefore, when you can work with the base expression type, that's\nthe simplest way to work. However, sometimes you need to know more.\nThe base Expression class contains a `NodeType` property for this purpose.\nIt returns an `ExpressionType` which is an enumeration of possible expression types.\nOnce you know the type of the node, you can cast it to that type, and perform\nspecific actions knowing the type of the expression node. You can search for certain\nnode types, and then work with the specific properties of that kind of expression.\n\nFor example, this code will print the name of a variable for a variable access\nexpression. I've followed the practice of checking the node type, then\ncasting to a variable access expression and then checking the properties of\nthe specific expression type:\n\n```cs\nExpression<Func<int, int>> addFive = (num) => num + 5;\n\nif (addFive.NodeType == ExpressionType.Lambda)\n{\n    var lambdaExp = (LambdaExpression)addFive;\n\n    var parameter = lambdaExp.Parameters.First();\n\n    Console.WriteLine(parameter.Name);\n    Console.WriteLine(parameter.Type);\n}\n```\n\n## Creating Expression Trees\n\nThe `System.Linq.Expression` class also contains many static methods to create expressions. These\nmethods create an expression node using the arguments supplied for its children. In this way,\nyou build an expression up from its leaf nodes. For example, this code builds an Add expression:\n\n```cs\n// Addition is an add expression for \"1 + 2\"\nvar one = Expression.Constant(1, typeof(int));\nvar two = Expression.Constant(2, typeof(int));\nvar addition = Expression.Add(one, two);\n```\n\nYou can see from this simple example that many types are involved in creating and working\nwith expression trees. That complexity is necessary to provide the capabilities of\nthe rich vocabulary provided by the C# language.\n\n## Navigating the APIs\nThere are Expression node types that map to almost all of the syntax elements of the\nC# language. Each type has specific methods for that type of language element. It's a lot\nto keep in your head at one time. Rather than try to memorize everything, here are the techniques\nI use to work with Expression trees:\n1. Look at the members of the `ExpressionType` enum to determine possible nodes you should be\nexamining. This really helps when you want to traverse and understand an expression tree.\n2. Look at the static members of the `Expression` class to build an expression. Those methods\ncan build any expression type from a set of its child nodes.\n3. Look at the `ExpressionVisitor` class to build a modified expression tree.\n\nYou'll find more as you look at each of those three areas. Invariably, you will find what you need when\nyou start with one of those three steps.\n \n [Next -- Executing Expression Trees](expression-trees-execution.md)\n \n"}