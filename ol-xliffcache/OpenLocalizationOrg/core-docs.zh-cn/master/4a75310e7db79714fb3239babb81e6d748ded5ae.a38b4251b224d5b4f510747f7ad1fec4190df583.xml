{"nodes":[{"pos":[11,29],"content":"Garbage Collection","needQuote":true,"nodes":[{"content":"Garbage Collection","pos":[0,18]}]},{"pos":[43,61],"content":"Garbage Collection","needQuote":true,"nodes":[{"content":"Garbage Collection","pos":[0,18]}]},{"pos":[72,87],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":"Garbage Collection","pos":[295,313]},{"content":"Garbage collection is one of most important features of the .NET managed code platform.","pos":[315,402]},{"content":"The garbage collector (GC) manages allocating and releasing memory for you.","pos":[403,478]},{"content":"You do not need to how to allocate and release memory or manage the lifetime of the objects that use that memory.","pos":[479,592]},{"content":"An allocation is made any time you <bpt id=\"p1\">_</bpt>new<ept id=\"p1\">_</ept> an object or a value type is boxed.","pos":[593,669],"source":" An allocation is made any time you _new_ an object or a value type is boxed."},{"content":"Allocations are typically very fast.","pos":[670,706]},{"content":"When there isn’t enough memory to allocate an object, the GC must collect and dispose of garbage memory to make memory available for new allocations.","pos":[707,856]},{"content":"This process is called “garbage collection”.","pos":[857,901]},{"content":"The garbage collector serves as an automatic memory manager.","pos":[903,963]},{"content":"It provides the following benefits:","pos":[964,999]},{"content":"Enables you to develop your application without having to free memory.","pos":[1005,1075]},{"content":"Allocates objects on the managed heap efficiently.","pos":[1080,1130]},{"content":"Reclaims objects that are no longer being used, clears their memory, and keeps the memory available for future allocations.","pos":[1135,1258]},{"content":"Managed objects automatically get clean content to start with, so their constructors do not have to initialize every data field.","pos":[1259,1387]},{"content":"Provides memory safety by making sure that an object cannot use the content of another object.","pos":[1392,1486]},{"content":"The .NET GC is generational and has 3 generations.","pos":[1488,1538]},{"content":"Each generation has its own heap that it uses for storage of allocated objects.","pos":[1539,1618]},{"content":"There is a basic principle that most objects are either short lived or long lived.","pos":[1619,1701]},{"content":"Generation 0 is where objects are first allocated.","pos":[1702,1752]},{"content":"Objects often don’t live past the first generation, since they are no longer in use (out of scope) by the time the next garbage collection occurs.","pos":[1753,1899]},{"content":"Generation 0 is quick to collect because its associated heap is small.","pos":[1900,1970]},{"content":"Generation 1 is really a second chance space.","pos":[1971,2016]},{"content":"Objects that are short lived but survive the generation 0 collection (often based on coincidental timing) go to generation 1<ph id=\"ph1\">\\.</ph> Generation 1 collections are also quick because its associated heap is also small.","pos":[2017,2226],"source":" Objects that are short lived but survive the generation 0 collection (often based on coincidental timing) go to generation 1\\. Generation 1 collections are also quick because its associated heap is also small."},{"content":"The first two heaps remain small because objects are either collected or are promoted to the next generation heap.","pos":[2227,2341]},{"content":"Generation 2 is where all long lived objects are.","pos":[2342,2391]},{"content":"The generation 2 heap can grow to be very large, since the objects it contains can survive a long time and there is no generation 3 heap to further promote objects.","pos":[2392,2556]},{"content":"The GC has has an additional heap for large objects called the Large Object Heap (LOH).","pos":[2558,2645]},{"content":"It is reserved for objects that are 85,000 bytes or greater.","pos":[2646,2706]},{"content":"A byte array (Byte[]) with 85k elements would be an example of a large object.","pos":[2707,2785]},{"content":"Large objects are not allocated to the generational heaps but are allocated directly to the LOH.","pos":[2786,2882]},{"content":"Generation 2 and LOH collections can take noticeable time for programs that have run for a long time or operate over large amounts of data.","pos":[2884,3023]},{"content":"Large server programs are known to have heaps in the 10s of GBs.","pos":[3024,3088]},{"content":"The GC employs a variety of techniques to reduce the amount of time that it blocks program execution.","pos":[3089,3190]},{"content":"The primary approach is to do as much garbage collection work as possible on a background thread in a way that does not interfere with program execution.","pos":[3191,3344]},{"content":"The GC also exposes a few ways for developers to influence its behavior, which can be quite useful to improve performance.","pos":[3345,3467]},{"pos":[3469,3573],"content":"For more information, see <bpt id=\"p1\">[</bpt>Garbage Collection<ept id=\"p1\">](http://msdn.microsoft.com/library/0xy59wtx.aspx)</ept> on MSDN.","source":"For more information, see [Garbage Collection](http://msdn.microsoft.com/library/0xy59wtx.aspx) on MSDN."}],"content":"---\ntitle: Garbage Collection\ndescription: Garbage Collection\nkeywords: .NET, .NET Core\nauthor: richlander\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: db39a0f5-e363-490f-a7e6-adb9a6ff2a8c\n---\n\n# Garbage Collection\n\nGarbage collection is one of most important features of the .NET managed code platform. The garbage collector (GC) manages allocating and releasing memory for you. You do not need to how to allocate and release memory or manage the lifetime of the objects that use that memory. An allocation is made any time you _new_ an object or a value type is boxed. Allocations are typically very fast. When there isn’t enough memory to allocate an object, the GC must collect and dispose of garbage memory to make memory available for new allocations. This process is called “garbage collection”.\n\nThe garbage collector serves as an automatic memory manager. It provides the following benefits:\n\n*   Enables you to develop your application without having to free memory.\n*   Allocates objects on the managed heap efficiently.\n*   Reclaims objects that are no longer being used, clears their memory, and keeps the memory available for future allocations. Managed objects automatically get clean content to start with, so their constructors do not have to initialize every data field.\n*   Provides memory safety by making sure that an object cannot use the content of another object.\n\nThe .NET GC is generational and has 3 generations. Each generation has its own heap that it uses for storage of allocated objects. There is a basic principle that most objects are either short lived or long lived. Generation 0 is where objects are first allocated. Objects often don’t live past the first generation, since they are no longer in use (out of scope) by the time the next garbage collection occurs. Generation 0 is quick to collect because its associated heap is small. Generation 1 is really a second chance space. Objects that are short lived but survive the generation 0 collection (often based on coincidental timing) go to generation 1\\. Generation 1 collections are also quick because its associated heap is also small. The first two heaps remain small because objects are either collected or are promoted to the next generation heap. Generation 2 is where all long lived objects are. The generation 2 heap can grow to be very large, since the objects it contains can survive a long time and there is no generation 3 heap to further promote objects.\n\nThe GC has has an additional heap for large objects called the Large Object Heap (LOH). It is reserved for objects that are 85,000 bytes or greater. A byte array (Byte[]) with 85k elements would be an example of a large object. Large objects are not allocated to the generational heaps but are allocated directly to the LOH.\n\nGeneration 2 and LOH collections can take noticeable time for programs that have run for a long time or operate over large amounts of data. Large server programs are known to have heaps in the 10s of GBs. The GC employs a variety of techniques to reduce the amount of time that it blocks program execution. The primary approach is to do as much garbage collection work as possible on a background thread in a way that does not interfere with program execution. The GC also exposes a few ways for developers to influence its behavior, which can be quite useful to improve performance.\n\nFor more information, see [Garbage Collection](http://msdn.microsoft.com/library/0xy59wtx.aspx) on MSDN.\n"}