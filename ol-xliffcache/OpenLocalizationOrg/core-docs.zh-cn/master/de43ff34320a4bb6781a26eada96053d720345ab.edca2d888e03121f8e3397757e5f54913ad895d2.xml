{"nodes":[{"pos":[11,51],"content":"Handling and throwing exceptions in .NET","needQuote":true,"nodes":[{"content":"Handling and throwing exceptions in .NET","pos":[0,40]}]},{"pos":[65,105],"content":"Understand how to use exceptions in .NET","needQuote":true,"nodes":[{"content":"Understand how to use exceptions in .NET","pos":[0,40]}]},{"pos":[116,131],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":"Handling and throwing exceptions in .NET","pos":[335,375]},{"content":"Applications must be able to handle errors that occur during execution in a consistent manner.","pos":[377,471]},{"content":".NET provides a model for notifying applications of errors in a uniform way: .NET operations indicate failure by throwing exceptions.","pos":[472,605]},{"content":"Exceptions","pos":[610,620]},{"content":"An exception is any error condition or unexpected behavior that is encountered by an executing program.","pos":[622,725]},{"content":"Exceptions can be thrown because of a fault in your code or in code that you call (such as a shared library), unavailable operating system resources, unexpected conditions that the runtime encounters (such as code that cannot be verified), and so on.","pos":[726,976]},{"content":"Your application can recover from some of these conditions, but not from others.","pos":[977,1057]},{"content":"Although you can recover from most application exceptions, you cannot recover from most runtime exceptions.","pos":[1058,1165]},{"content":"In .NET, an exception is an object that inherits from the <bpt id=\"p1\">[</bpt>System.Exception<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Exception)</ept> class.","pos":[1167,1311],"source":"In .NET, an exception is an object that inherits from the [System.Exception](https://docs.microsoft.com/dotnet/core/api/System.Exception) class."},{"content":"An exception is thrown from an area of code where a problem has occurred.","pos":[1312,1385]},{"content":"The exception is passed up the stack until the application handles it or the program terminates.","pos":[1386,1482]},{"content":"Exceptions vs. traditional error-handling methods","pos":[1487,1536]},{"content":"Traditionally, a language's error-handling model relied on either the language's unique way of detecting errors and locating handlers for them, or on the error-handling mechanism provided by the operating system.","pos":[1538,1750]},{"content":"The way .NET implements exception handling provides the following advantages:","pos":[1751,1828]},{"content":"Exception throwing and handling works the same for .NET programming languages.","pos":[1832,1910]},{"content":"Does not require any particular language syntax for handling exceptions, but allows each language to define its own syntax.","pos":[1914,2037]},{"content":"Exceptions can be thrown across process and even machine boundaries.","pos":[2041,2109]},{"content":"Exception-handling code can be added to an application to increase program reliability.","pos":[2113,2200]},{"content":"Exceptions offer advantages over other methods of error notification, such as return codes.","pos":[2202,2293]},{"content":"Failures do not go unnoticed because if an exception is thrown and you don't handle it, the runtime terminates your application.","pos":[2294,2422]},{"content":"Invalid values do not continue to propagate through the system as a result of code that fails to check for a failure return code.","pos":[2423,2552]},{"content":"Exception class and properties","pos":[2558,2588]},{"content":"The <bpt id=\"p1\">[</bpt>Exception<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Exception)</ept> class is the base class from which exceptions inherit.","pos":[2590,2721],"source":"The [Exception](https://docs.microsoft.com/dotnet/core/api/System.Exception) class is the base class from which exceptions inherit."},{"content":"For example, the <bpt id=\"p1\">[</bpt>InvalidCastException<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.InvalidCastException)</ept> class hierarchy is as follows:","pos":[2722,2864],"source":" For example, the [InvalidCastException](https://docs.microsoft.com/dotnet/core/api/System.InvalidCastException) class hierarchy is as follows:"},{"pos":[2942,3044],"content":"The <bpt id=\"p1\">**</bpt>Exception<ept id=\"p1\">**</ept> class has the following properties that help make understanding an exception easier.","source":"The **Exception** class has the following properties that help make understanding an exception easier."},{"content":"Property Name","pos":[3048,3061]},{"content":"Description","pos":[3064,3075]},{"content":"Data","pos":[3113,3117]},{"pos":[3204,3341],"content":"An <bpt id=\"p1\">[</bpt>IDictionary<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.IDictionary)</ept> that holds arbitrary data in key-value pairs.","source":"An [IDictionary](https://docs.microsoft.com/dotnet/core/api/System.Collections.IDictionary) that holds arbitrary data in key-value pairs."},{"content":"HelpLink","pos":[3347,3355]},{"content":"Can hold a URL (or URN) to a help file that provides extensive information about the cause of an exception.","pos":[3446,3553]},{"content":"InnerException","pos":[3559,3573]},{"content":"This property can be used to create and preserve a series of exceptions during exception handling.","pos":[3670,3768]},{"content":"You can use it to create a new exception that contains previously caught exceptions.","pos":[3769,3853]},{"content":"The original exception can be captured by the second exception in the <bpt id=\"p1\">**</bpt>InnerException<ept id=\"p1\">**</ept> property, allowing code that handles the second exception to examine the additional information.","pos":[3854,4039],"source":" The original exception can be captured by the second exception in the **InnerException** property, allowing code that handles the second exception to examine the additional information."},{"content":"For example, suppose you have a method that receives an argument that's improperly formatted.","pos":[4040,4133]},{"content":"The code tries to read the argument, but an exception is thrown.","pos":[4135,4199]},{"content":"The method catches the exception and throws a <bpt id=\"p1\">[</bpt>FormatException<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.FormatException)</ept>.","pos":[4200,4331],"source":" The method catches the exception and throws a [FormatException](https://docs.microsoft.com/dotnet/core/api/System.FormatException)."},{"content":"To improve the caller's ability to determine the reason an exception is thrown, it is sometimes desirable for a method to catch an exception thrown by a helper routine and then throw an exception more indicative of the error that has occurred.","pos":[4332,4575]},{"content":"A new and more meaningful exception can be created, where the inner exception reference can be set to the original exception.","pos":[4576,4701]},{"content":"This more meaningful exception can then be thrown to the caller.","pos":[4702,4766]},{"content":"Note that with this functionality, you can create a series of linked exceptions that ends with the exception that was thrown first.","pos":[4767,4898]},{"content":"Message","pos":[4904,4911]},{"content":"Provides details about the cause of an exception.","pos":[5001,5050]},{"content":"Source","pos":[5054,5060]},{"content":"Gets or sets the name of the application or the object that causes the error.","pos":[5149,5226]},{"content":"StackTrace","pos":[5232,5242]},{"content":"Contains a stack trace that can be used to determine where an error occurred.","pos":[5335,5412]},{"content":"The stack trace includes the source file name and program line number if debugging information is available.","pos":[5413,5521]},{"content":"Most of the classes that inherit from <bpt id=\"p1\">**</bpt>Exception<ept id=\"p1\">**</ept> do not implement additional members or provide additional functionality; they simply inherit from <bpt id=\"p2\">**</bpt>Exception<ept id=\"p2\">**</ept>.","pos":[5525,5689],"source":"Most of the classes that inherit from **Exception** do not implement additional members or provide additional functionality; they simply inherit from **Exception**."},{"content":"Therefore, the most important information for an exception can be found in the hierarchy of exception classes, the exception name, and the information contained in the exception.","pos":[5690,5868]},{"content":"It is recommended to throw and catch only objects that derive from <bpt id=\"p1\">**</bpt>Exception<ept id=\"p1\">**</ept>, but you can throw any object that derives from the <bpt id=\"p2\">[</bpt>Object<ept id=\"p2\">](https://docs.microsoft.com/dotnet/core/api/System.Object)</ept> class as an exception.","pos":[5870,6092],"source":"It is recommended to throw and catch only objects that derive from **Exception**, but you can throw any object that derives from the [Object](https://docs.microsoft.com/dotnet/core/api/System.Object) class as an exception."},{"content":"Note that not all languages support throwing and catching objects that do not derive from <bpt id=\"p1\">**</bpt>Exception<ept id=\"p1\">**</ept>.","pos":[6093,6197],"source":" Note that not all languages support throwing and catching objects that do not derive from **Exception**."},{"content":"Common Exceptions","pos":[6202,6219]},{"content":"The following table lists some common exceptions with examples of what can cause them.","pos":[6221,6307]},{"content":"Exception type","pos":[6311,6325]},{"content":"Base type","pos":[6328,6337]},{"content":"Description","pos":[6340,6351]},{"content":"Example","pos":[6354,6361]},{"content":"Exception","pos":[6422,6431]},{"content":"Object","pos":[6497,6503]},{"content":"Base class for all exceptions.","pos":[6565,6595]},{"content":"None (use a derived class of this exception).","pos":[6598,6643]},{"content":"IndexOutOfRangeException","pos":[6649,6673]},{"content":"Exception","pos":[6754,6763]},{"content":"Thrown by the runtime only when an array is indexed improperly.","pos":[6828,6891]},{"pos":[6894,6936],"content":"Indexing an array outside its valid range:"},{"content":"NullReferenceException","pos":[6962,6984]},{"content":"Exception","pos":[7063,7072]},{"content":"Thrown by the runtime only when a null object is referenced.","pos":[7137,7197]},{"content":"InvalidOperationException","pos":[7238,7263]},{"content":"Exception","pos":[7345,7354]},{"content":"Thrown by methods when in an invalid state.","pos":[7419,7462]},{"pos":[7465,7550],"content":"Calling <ph id=\"ph1\">`Enumerator.GetNext()`</ph> after removing an Item from the underlying collection.","source":"Calling `Enumerator.GetNext()` after removing an Item from the underlying collection."},{"content":"ArgumentException","pos":[7556,7573]},{"content":"Exception","pos":[7647,7656]},{"content":"Base class for all argument exceptions.","pos":[7721,7760]},{"content":"None (use a derived class of this exception).","pos":[7763,7808]},{"content":"ArgumentNullException","pos":[7814,7835]},{"content":"Exception","pos":[7913,7922]},{"content":"Thrown by methods that do not allow an argument to be null.","pos":[7987,8046]},{"content":"ArgumentOutOfRangeException","pos":[8098,8125]},{"content":"Exception","pos":[8209,8218]},{"content":"Thrown by methods that verify that arguments are in a given range.","pos":[8283,8349]},{"content":"How to use the try/catch block to catch exceptions","pos":[8393,8443]},{"content":"Place the sections of code that might throw exceptions in a <bpt id=\"p1\">**</bpt>try<ept id=\"p1\">**</ept> block and place code that handles exceptions in a <bpt id=\"p2\">**</bpt>catch<ept id=\"p2\">**</ept> block.","pos":[8445,8579],"source":"Place the sections of code that might throw exceptions in a **try** block and place code that handles exceptions in a **catch** block."},{"content":"The <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> block is a series of statements beginning with the keyword <bpt id=\"p2\">**</bpt>catch<ept id=\"p2\">**</ept>, followed by an exception type and an action to be taken.","pos":[8580,8720],"source":" The **catch** block is a series of statements beginning with the keyword **catch**, followed by an exception type and an action to be taken."},{"content":"The following code example uses a <bpt id=\"p1\">**</bpt>try<ept id=\"p1\">**</ept><ph id=\"ph1\">/</ph><bpt id=\"p2\">**</bpt>catch<ept id=\"p2\">**</ept> block to catch a possible exception.","pos":[8722,8810],"source":"The following code example uses a **try**/**catch** block to catch a possible exception."},{"content":"The <ph id=\"ph1\">`Main`</ph> method contains a <bpt id=\"p1\">**</bpt>try<ept id=\"p1\">**</ept> block with a <bpt id=\"p2\">[</bpt>StreamReader<ept id=\"p2\">](https://docs.microsoft.com/dotnet/core/api/System.IO.StreamReader)</ept> statement that opens a data file called <ph id=\"ph2\">`data.txt`</ph> and writes a string from the file.","pos":[8811,9028],"source":" The `Main` method contains a **try** block with a [StreamReader](https://docs.microsoft.com/dotnet/core/api/System.IO.StreamReader) statement that opens a data file called `data.txt` and writes a string from the file."},{"content":"Following the <bpt id=\"p1\">**</bpt>try<ept id=\"p1\">**</ept> block is a <bpt id=\"p2\">**</bpt>catch<ept id=\"p2\">**</ept> block that catches any exception that results from the <bpt id=\"p3\">**</bpt>try<ept id=\"p3\">**</ept> block.","pos":[9029,9141],"source":" Following the **try** block is a **catch** block that catches any exception that results from the **try** block."},{"content":"C","pos":[9143,9144]},{"content":"The common language runtime catches exceptions that are not caught by a catch block.","pos":[9567,9651]},{"content":"Depending on how the runtime is configured, a debug dialog box appears, or the program stops executing and a dialog box with exception information appears, or an error is printed out to STDERR.","pos":[9652,9845]},{"pos":[9849,10360],"content":"[!NOTE] \nAlmost any line of code can cause an exception, particularly exceptions that are thrown by the common language runtime itself, such as [OutOfMemoryException](https://docs.microsoft.com/dotnet/core/api/System.OutOfMemoryException). Most applications don't have to deal with these exceptions, but you should be aware of this possibility when writing libraries to be used by others. For suggestions on when to set code in a Try block, see [Best Practices for Exceptions](#best-practices-for-exceptions).","leadings":["","> "],"nodes":[{"content":"Almost any line of code can cause an exception, particularly exceptions that are thrown by the common language runtime itself, such as [OutOfMemoryException](https://docs.microsoft.com/dotnet/core/api/System.OutOfMemoryException). Most applications don't have to deal with these exceptions, but you should be aware of this possibility when writing libraries to be used by others. For suggestions on when to set code in a Try block, see [Best Practices for Exceptions](#best-practices-for-exceptions).","pos":[9,509],"nodes":[{"content":"Almost any line of code can cause an exception, particularly exceptions that are thrown by the common language runtime itself, such as <bpt id=\"p1\">[</bpt>OutOfMemoryException<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.OutOfMemoryException)</ept>.","pos":[0,230],"source":"Almost any line of code can cause an exception, particularly exceptions that are thrown by the common language runtime itself, such as [OutOfMemoryException](https://docs.microsoft.com/dotnet/core/api/System.OutOfMemoryException)."},{"content":"Most applications don't have to deal with these exceptions, but you should be aware of this possibility when writing libraries to be used by others.","pos":[231,379]},{"content":"For suggestions on when to set code in a Try block, see <bpt id=\"p1\">[</bpt>Best Practices for Exceptions<ept id=\"p1\">](#best-practices-for-exceptions)</ept>.","pos":[380,500],"source":" For suggestions on when to set code in a Try block, see [Best Practices for Exceptions](#best-practices-for-exceptions)."}]}]},{"content":"How to use specific exceptions in a Catch block","pos":[10366,10413]},{"content":"The preceding code example illustrates a basic <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> statement that catches any exception.","pos":[10415,10509],"source":"The preceding code example illustrates a basic **catch** statement that catches any exception."},{"content":"In general, though, it's good programming practice to catch a specific type of exception rather than use a basic <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> statement.","pos":[10510,10643],"source":" In general, though, it's good programming practice to catch a specific type of exception rather than use a basic **catch** statement."},{"content":"When an exception occurs, it is passed up the stack and each catch block is given the opportunity to handle it.","pos":[10645,10756]},{"content":"The order of catch statements is important.","pos":[10757,10800]},{"content":"Put catch blocks targeted to specific exceptions before a general exception catch block or the compiler might issue an error.","pos":[10801,10926]},{"content":"The proper catch block is determined by matching the type of the exception to the name of the exception specified in the catch block.","pos":[10927,11060]},{"content":"If there is no specific catch block, the exception is caught by a general catch block, if one exists.","pos":[11061,11162]},{"content":"The following code example uses a <bpt id=\"p1\">**</bpt>try<ept id=\"p1\">**</ept><ph id=\"ph1\">/</ph><bpt id=\"p2\">**</bpt>catch<ept id=\"p2\">**</ept> block to catch an <bpt id=\"p3\">[</bpt>InvalidCastException<ept id=\"p3\">](https://docs.microsoft.com/dotnet/core/api/System.InvalidCastException)</ept>.","pos":[11164,11329],"source":"The following code example uses a **try**/**catch** block to catch an [InvalidCastException](https://docs.microsoft.com/dotnet/core/api/System.InvalidCastException)."},{"content":"The sample creates a class called <ph id=\"ph1\">`Employee`</ph> with a single property, employee level (<ph id=\"ph2\">`Emlevel`</ph>).","pos":[11330,11426],"source":" The sample creates a class called `Employee` with a single property, employee level (`Emlevel`)."},{"content":"A method, <ph id=\"ph1\">`PromoteEmployee`</ph>, takes an object and increments the employee level.","pos":[11427,11506],"source":" A method, `PromoteEmployee`, takes an object and increments the employee level."},{"content":"An <bpt id=\"p1\">**</bpt>InvalidCastException<ept id=\"p1\">**</ept> occurs when a <bpt id=\"p2\">[</bpt>DateTime<ept id=\"p2\">](https://docs.microsoft.com/dotnet/core/api/System.DateTime)</ept> instance is passed to the <ph id=\"ph1\">`PromoteEmployee`</ph> method.","pos":[11507,11671],"source":" An **InvalidCastException** occurs when a [DateTime](https://docs.microsoft.com/dotnet/core/api/System.DateTime) instance is passed to the `PromoteEmployee` method."},{"content":"C","pos":[11673,11674]},{"content":"How to use finally blocks","pos":[12724,12749]},{"content":"When an exception occurs, execution stops and control is given to the appropriate exception handler.","pos":[12751,12851]},{"content":"This often means that lines of code you expect to be executed are bypassed.","pos":[12852,12927]},{"content":"Some resource cleanup, such as closing a file, needs to be done even if an exception is thrown.","pos":[12928,13023]},{"content":"To do this, you can use a <bpt id=\"p1\">**</bpt>finally<ept id=\"p1\">**</ept> block.","pos":[13024,13068],"source":" To do this, you can use a **finally** block."},{"content":"A <bpt id=\"p1\">**</bpt>finally<ept id=\"p1\">**</ept> block always executes, regardless of whether an exception is thrown.","pos":[13069,13151],"source":" A **finally** block always executes, regardless of whether an exception is thrown."},{"content":"The following code example uses a <bpt id=\"p1\">**</bpt>try<ept id=\"p1\">**</ept><ph id=\"ph1\">/</ph><bpt id=\"p2\">**</bpt>catch<ept id=\"p2\">**</ept> block to catch an <bpt id=\"p3\">[</bpt>ArgumentOutOfRangeException<ept id=\"p3\">](https://docs.microsoft.com/dotnet/core/api/System.ArgumentOutOfRangeException)</ept>.","pos":[13153,13332],"source":"The following code example uses a **try**/**catch** block to catch an [ArgumentOutOfRangeException](https://docs.microsoft.com/dotnet/core/api/System.ArgumentOutOfRangeException)."},{"content":"The <ph id=\"ph1\">`Main`</ph> method creates two arrays and attempts to copy one to the other.","pos":[13333,13408],"source":" The `Main` method creates two arrays and attempts to copy one to the other."},{"content":"The action generates an <bpt id=\"p1\">**</bpt>ArgumentOutOfRangeException<ept id=\"p1\">**</ept> and the error is written to the console.","pos":[13409,13505],"source":" The action generates an **ArgumentOutOfRangeException** and the error is written to the console."},{"content":"The <bpt id=\"p1\">**</bpt>finally<ept id=\"p1\">**</ept> block executes regardless of the outcome of the copy action.","pos":[13506,13582],"source":" The **finally** block executes regardless of the outcome of the copy action."},{"content":"C","pos":[13584,13585]},{"content":"How to explicitly throw exceptions","pos":[14050,14084]},{"content":"You can explicitly throw an exception using the <bpt id=\"p1\">**</bpt>throw<ept id=\"p1\">**</ept> statement.","pos":[14086,14154],"source":"You can explicitly throw an exception using the **throw** statement."},{"content":"You can also throw a caught exception again using the <bpt id=\"p1\">**</bpt>throw<ept id=\"p1\">**</ept> statement.","pos":[14155,14229],"source":" You can also throw a caught exception again using the **throw** statement."},{"content":"It is good coding practice to add information to an exception that is re-thrown to provide more information when debugging.","pos":[14230,14353]},{"content":"The following code example uses a <bpt id=\"p1\">**</bpt>try<ept id=\"p1\">**</ept><ph id=\"ph1\">/</ph><bpt id=\"p2\">**</bpt>catch<ept id=\"p2\">**</ept> block to catch a possible <bpt id=\"p3\">[</bpt>FileNotFoundException<ept id=\"p3\">](https://docs.microsoft.com/dotnet/core/api/System.IO.FileNotFoundException)</ept>.","pos":[14355,14533],"source":"The following code example uses a **try**/**catch** block to catch a possible [FileNotFoundException](https://docs.microsoft.com/dotnet/core/api/System.IO.FileNotFoundException)."},{"content":"Following the <bpt id=\"p1\">**</bpt>try<ept id=\"p1\">**</ept> block is a <bpt id=\"p2\">**</bpt>catch<ept id=\"p2\">**</ept> block that catches the <bpt id=\"p3\">**</bpt>FileNotFoundException<ept id=\"p3\">**</ept> and writes a message to the console if the data file is not found.","pos":[14534,14692],"source":" Following the **try** block is a **catch** block that catches the **FileNotFoundException** and writes a message to the console if the data file is not found."},{"content":"The next statement is the <bpt id=\"p1\">**</bpt>throw<ept id=\"p1\">**</ept> statement that throws a new <bpt id=\"p2\">**</bpt>FileNotFoundException<ept id=\"p2\">**</ept> and adds text information to the exception.","pos":[14693,14826],"source":" The next statement is the **throw** statement that throws a new **FileNotFoundException** and adds text information to the exception."},{"content":"C","pos":[14828,14829]},{"content":"How to create user-defined exceptions","pos":[15580,15617]},{"content":".NET provides a hierarchy of exception classes ultimately derived from the base class <bpt id=\"p1\">[</bpt>Exception<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Exception)</ept>.","pos":[15619,15778],"source":".NET provides a hierarchy of exception classes ultimately derived from the base class [Exception](https://docs.microsoft.com/dotnet/core/api/System.Exception)."},{"content":"However, if none of the predefined exceptions meets your needs, you can create your own exception classes by deriving from the <bpt id=\"p1\">**</bpt>Exception<ept id=\"p1\">**</ept> class.","pos":[15779,15926],"source":" However, if none of the predefined exceptions meets your needs, you can create your own exception classes by deriving from the **Exception** class."},{"content":"When creating your own exceptions, end the class name of the user-defined exception with the word \"Exception,\" and implement the three common constructors, as shown in the following example.","pos":[15928,16118]},{"content":"The example defines a new exception class named <ph id=\"ph1\">`EmployeeListNotFoundException`</ph>.","pos":[16119,16199],"source":" The example defines a new exception class named `EmployeeListNotFoundException`."},{"content":"The class is derived from <bpt id=\"p1\">**</bpt>Exception<ept id=\"p1\">**</ept> and includes three constructors.","pos":[16200,16272],"source":" The class is derived from **Exception** and includes three constructors."},{"content":"C","pos":[16274,16275]},{"pos":[16628,16922],"content":"[!NOTE]\nIn situations where you are using remoting, you must ensure that the metadata for any user-defined exceptions is available at the server (callee) and to the client (the proxy object or caller). For more information, see [Best practices for exceptions](#best-practices-for-exceptions).","leadings":["","> "],"nodes":[{"content":"In situations where you are using remoting, you must ensure that the metadata for any user-defined exceptions is available at the server (callee) and to the client (the proxy object or caller). For more information, see [Best practices for exceptions](#best-practices-for-exceptions).","pos":[8,292],"nodes":[{"content":"In situations where you are using remoting, you must ensure that the metadata for any user-defined exceptions is available at the server (callee) and to the client (the proxy object or caller).","pos":[0,193]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Best practices for exceptions<ept id=\"p1\">](#best-practices-for-exceptions)</ept>.","pos":[194,284],"source":" For more information, see [Best practices for exceptions](#best-practices-for-exceptions)."}]}]},{"content":"Best practices for exceptions","pos":[16927,16956]},{"content":"A well-designed app handles exceptions and errors to prevent app crashes.","pos":[16958,17031]},{"content":"This section describes best practices for handling and creating exceptions.","pos":[17032,17107]},{"content":"Use try/catch/finally blocks","pos":[17113,17141]},{"pos":[17143,17239],"content":"Use <bpt id=\"p1\">**</bpt>try<ept id=\"p1\">**</ept><ph id=\"ph1\">/</ph><bpt id=\"p2\">**</bpt>catch<ept id=\"p2\">**</ept><ph id=\"ph2\">/</ph><bpt id=\"p3\">**</bpt>finally<ept id=\"p3\">**</ept> blocks around code that can potentially generate an exception.","source":"Use **try**/**catch**/**finally** blocks around code that can potentially generate an exception."},{"pos":[17242,17332],"content":"In <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> blocks, always order exceptions from the most specific to the least specific.","source":"In **catch** blocks, always order exceptions from the most specific to the least specific."},{"pos":[17334,17412],"content":"Use a <bpt id=\"p1\">**</bpt>finally<ept id=\"p1\">**</ept> block to clean up resources, whether you can recover or not.","source":"Use a **finally** block to clean up resources, whether you can recover or not."},{"content":"Handle common conditions without throwing exceptions","pos":[17418,17470]},{"content":"For conditions that are likely to occur but might trigger an exception, consider handling them in a way that will avoid the exception.","pos":[17472,17606]},{"content":"For example, if you try to close a connection that is already closed, you'll get an <ph id=\"ph1\">`InvalidOperationException`</ph>.","pos":[17607,17719],"source":" For example, if you try to close a connection that is already closed, you'll get an `InvalidOperationException`."},{"content":"You can avoid that by using an <bpt id=\"p1\">**</bpt>if<ept id=\"p1\">**</ept> statement to check the connection state before trying to close it.","pos":[17720,17824],"source":" You can avoid that by using an **if** statement to check the connection state before trying to close it."},{"content":"C","pos":[17826,17827]},{"pos":[17902,18010],"content":"If you don't check connection state before closing, you can catch the <ph id=\"ph1\">`InvalidOperationException`</ph> exception.","source":"If you don't check connection state before closing, you can catch the `InvalidOperationException` exception."},{"content":"C","pos":[18012,18013]},{"content":"The method to choose depends on how often you expect the event to occur.","pos":[18172,18244]},{"content":"Use exception handling if the event doesn't occur very often, that is, if the event is truly exceptional and indicates an error (such as an unexpected end-of-file).","pos":[18248,18412]},{"content":"When you use exception handling, less code is executed in normal conditions.","pos":[18413,18489]},{"content":"Check for error conditions in code if the event happens routinely and could be considered part of normal execution.","pos":[18493,18608]},{"content":"When you check for common error conditions, less code is executed because you avoid exceptions.","pos":[18609,18704]},{"content":"Design classes so that exceptions can be avoided","pos":[18710,18758]},{"content":"A class can provide methods or properties that enable you to avoid making a call that would trigger an exception.","pos":[18760,18873]},{"content":"For example, a <bpt id=\"p1\">[</bpt>FileStream<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.IO.FileStream)</ept> class provides methods that help determine whether the end of the file has been reached.","pos":[18874,19055],"source":" For example, a [FileStream](https://docs.microsoft.com/dotnet/core/api/System.IO.FileStream) class provides methods that help determine whether the end of the file has been reached."},{"content":"These can be used to avoid the exception that is thrown if you read past the end of the file.","pos":[19056,19149]},{"content":"The following example shows how to read to the end of a file without triggering an exception.","pos":[19150,19243]},{"content":"C","pos":[19245,19246]},{"content":"Another way to avoid exceptions is to return null for extremely common error cases instead of throwing an exception.","pos":[19945,20061]},{"content":"An extremely common error case can be considered normal flow of control.","pos":[20062,20134]},{"content":"By returning null in these cases, you minimize the performance impact to an app.","pos":[20135,20215]},{"content":"Throw exceptions instead of returning an error code","pos":[20221,20272]},{"content":"Exceptions ensure that failures do not go unnoticed because calling code didn't check a return code.","pos":[20274,20374]},{"content":"Use the predefined .NET exception types","pos":[20381,20420]},{"content":"Introduce a new exception class only when a predefined one doesn't apply.","pos":[20422,20495]},{"content":"For example:","pos":[20496,20508]},{"pos":[20512,20721],"content":"Throw an <bpt id=\"p1\">[</bpt>InvalidOperationException<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.InvalidOperationException)</ept> exception if a property set or method call is not appropriate given the object's current state.","source":"Throw an [InvalidOperationException](https://docs.microsoft.com/dotnet/core/api/System.InvalidOperationException) exception if a property set or method call is not appropriate given the object's current state."},{"pos":[20725,21005],"content":"Throw an <bpt id=\"p1\">[</bpt>ArgumentException<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.ArgumentException)</ept> exception or one of the predefined classes that derive from <bpt id=\"p2\">[</bpt>ArgumentException<ept id=\"p2\">](https://docs.microsoft.com/dotnet/core/api/System.ArgumentException)</ept> if invalid parameters are passed.","source":"Throw an [ArgumentException](https://docs.microsoft.com/dotnet/core/api/System.ArgumentException) exception or one of the predefined classes that derive from [ArgumentException](https://docs.microsoft.com/dotnet/core/api/System.ArgumentException) if invalid parameters are passed."},{"content":"End exception class names with the word \"Exception\"","pos":[21011,21062]},{"content":"When a custom exception is necessary, name it appropriately and derive it from the <bpt id=\"p1\">[</bpt>Exception<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Exception)</ept> class.","pos":[21064,21226],"source":"When a custom exception is necessary, name it appropriately and derive it from the [Exception](https://docs.microsoft.com/dotnet/core/api/System.Exception) class."},{"content":"For example:","pos":[21227,21239]},{"content":"C","pos":[21241,21242]},{"content":"Include three constructors in custom exception classes","pos":[21310,21364]},{"content":"Use at least the three common constructors when creating your own exception classes: the default constructor, a constructor that takes a string message, and a constructor that takes a string message and an inner exception.","pos":[21366,21588]},{"pos":[21592,21717],"content":"<bpt id=\"p1\">[</bpt>Exception()<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Exception#System_Exception__ctor)</ept>, which uses default values.","source":"[Exception()](https://docs.microsoft.com/dotnet/core/api/System.Exception#System_Exception__ctor), which uses default values."},{"pos":[21721,21872],"content":"<bpt id=\"p1\">[</bpt>Exception(String)<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Exception#System_Exception__ctor_System_String_)</ept>, which accepts a string message.","source":"[Exception(String)](https://docs.microsoft.com/dotnet/core/api/System.Exception#System_Exception__ctor_System_String_), which accepts a string message."},{"pos":[21876,22078],"content":"<bpt id=\"p1\">[</bpt>Exception(String, Exception)<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Exception#System_Exception__ctor_System_String_System_Exception_)</ept>, which accepts a string message and an inner exception.","source":"[Exception(String, Exception)](https://docs.microsoft.com/dotnet/core/api/System.Exception#System_Exception__ctor_System_String_System_Exception_), which accepts a string message and an inner exception."},{"pos":[22080,22181],"content":"For an example, see <bpt id=\"p1\">[</bpt>How to: Create User-Defined Exceptions<ept id=\"p1\">](#how-to-create-user-defined-exceptions)</ept>.","source":"For an example, see [How to: Create User-Defined Exceptions](#how-to-create-user-defined-exceptions)."},{"content":"Ensure that exception data is available when code executes remotely","pos":[22187,22254]},{"content":"When you create user-defined exceptions, ensure that the metadata for the exceptions is available to code that is executing remotely.","pos":[22256,22389]},{"content":"For example, on .NET runtimes that implement App Domains, exceptions may occur across App domains.","pos":[22392,22490]},{"content":"Suppose App Domain A creates App Domain B, which executes code that throws an exception.","pos":[22491,22579]},{"content":"For App Domain A to properly catch and handle the exception, it must be able to find the assembly that contains the exception thrown by App Domain B. If App Domain B throws an exception that is contained in an assembly under its application base, but not under App Domain A's application base, App Domain A will not be able to find the exception, and the common language runtime will throw a <bpt id=\"p1\">[</bpt>FileNotFoundException<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.IO.FileNotFoundException)</ept> exception.","pos":[22580,23082],"source":" For App Domain A to properly catch and handle the exception, it must be able to find the assembly that contains the exception thrown by App Domain B. If App Domain B throws an exception that is contained in an assembly under its application base, but not under App Domain A's application base, App Domain A will not be able to find the exception, and the common language runtime will throw a [FileNotFoundException](https://docs.microsoft.com/dotnet/core/api/System.IO.FileNotFoundException) exception."},{"content":"To avoid this situation, you can deploy the assembly that contains the exception information in two ways:","pos":[23083,23188]},{"content":"Put the assembly into a common application base shared by both app domains.","pos":[23192,23267]},{"content":"or -","pos":[23276,23280]},{"content":"If the domains do not share a common application base, sign the assembly that contains the exception information with a strong name and deploy the assembly into the global assembly cache.","pos":[23284,23471]},{"content":"Include a localized description string in every exception","pos":[23477,23534]},{"content":"The error message that the user sees is derived from the description string of the exception that was thrown, and not from the name of the exception class.","pos":[23536,23691]},{"content":"Use grammatically correct error messages","pos":[23697,23737]},{"content":"Write clear sentences and include ending punctuation.","pos":[23739,23792]},{"content":"Each sentence in a description string of an exception should end in a period.","pos":[23793,23870]},{"content":"For example, \"The log table has overflowed.”","pos":[23871,23915]},{"content":"would be an appropriate description string.","pos":[23916,23959]},{"content":"In custom exceptions, provide additional properties as needed","pos":[23965,24026]},{"content":"Provide additional properties for an exception (in addition to the description string) only when there's a programmatic scenario where the additional information is useful.","pos":[24028,24200]},{"content":"For example, the <bpt id=\"p1\">[</bpt>FileNotFoundException<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.IO.FileNotFoundException)</ept> provides the <bpt id=\"p2\">[</bpt>FileName<ept id=\"p2\">](https://docs.microsoft.com/dotnet/core/api/System.IO.FileNotFoundException#System_IO_FileNotFoundException_FileName)</ept> property.","pos":[24201,24468],"source":" For example, the [FileNotFoundException](https://docs.microsoft.com/dotnet/core/api/System.IO.FileNotFoundException) provides the [FileName](https://docs.microsoft.com/dotnet/core/api/System.IO.FileNotFoundException#System_IO_FileNotFoundException_FileName) property."},{"content":"Place throw statements so that the stack trace will be helpful","pos":[24474,24536]},{"pos":[24538,24671],"content":"The stack trace begins at the statement where the exception is thrown and ends at the <bpt id=\"p1\">**</bpt>catch<ept id=\"p1\">**</ept> statement that catches the exception.","source":"The stack trace begins at the statement where the exception is thrown and ends at the **catch** statement that catches the exception."},{"content":"Use exception builder methods","pos":[24677,24706]},{"content":"It is common for a class to throw the same exception from different places in its implementation.","pos":[24708,24805]},{"content":"To avoid excessive code, use helper methods that create the exception and return it.","pos":[24806,24890]},{"content":"For example:","pos":[24891,24903]},{"content":"C","pos":[24905,24906]},{"content":"In some cases, it's more appropriate to use the exception's constructor to build the exception.","pos":[25445,25540]},{"content":"An example is a global exception class such as <bpt id=\"p1\">[</bpt>ArgumentException<ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.ArgumentException)</ept>,","pos":[25541,25677],"source":" An example is a global exception class such as [ArgumentException](https://docs.microsoft.com/dotnet/core/api/System.ArgumentException),"},{"content":"Clean up intermediate results when throwing an exception","pos":[25684,25740]},{"content":"Callers should be able to assume that there are no side effects when an exception is thrown from a method.","pos":[25742,25848]},{"content":"For example, if you have code that transfers money by withdrawing from one account and depositing in another account, and an exception is thrown while executing the deposit, you don't want the withdrawal to remain in effect.","pos":[25849,26073]},{"content":"C","pos":[26075,26076]},{"content":"One way to handle this situation is to catch any exceptions thrown by the deposit transaction and roll back the withdrawal.","pos":[26285,26408]},{"content":"C","pos":[26410,26411]},{"content":"This example illustrates the use of <bpt id=\"p1\">**</bpt>throw<ept id=\"p1\">**</ept> to re-throw the original exception, which can make it easier for callers to see the real cause of the problem without having to examine the <bpt id=\"p2\">[</bpt>InnerException<ept id=\"p2\">](https://docs.microsoft.com/dotnet/core/api/System.Exception#System_Exception_InnerException)</ept> property.","pos":[26691,26996],"source":"This example illustrates the use of **throw** to re-throw the original exception, which can make it easier for callers to see the real cause of the problem without having to examine the [InnerException](https://docs.microsoft.com/dotnet/core/api/System.Exception#System_Exception_InnerException) property."},{"content":"An alternative is to throw a new exception and include the original exception as the inner exception:","pos":[26997,27098]},{"content":"C","pos":[27100,27101]},{"content":"Next steps","pos":[27237,27247]},{"pos":[27249,27445],"content":"To learn more about how exceptions work in .NET, see <bpt id=\"p1\">[</bpt>What Every Dev needs to Know About Exceptions in the Runtime<ept id=\"p1\">](https://github.com/dotnet/coreclr/blob/master/Documentation/botr/exceptions.md)</ept>.","source":"To learn more about how exceptions work in .NET, see [What Every Dev needs to Know About Exceptions in the Runtime](https://github.com/dotnet/coreclr/blob/master/Documentation/botr/exceptions.md)."}],"content":"---\ntitle: Handling and throwing exceptions in .NET\ndescription: Understand how to use exceptions in .NET\nkeywords: .NET, .NET Core\nauthor: mairaw\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: bf116df6-0042-46bf-be13-b69864816210\n---\n\n# Handling and throwing exceptions in .NET\n\nApplications must be able to handle errors that occur during execution in a consistent manner. .NET provides a model for notifying applications of errors in a uniform way: .NET operations indicate failure by throwing exceptions.\n\n## Exceptions\n\nAn exception is any error condition or unexpected behavior that is encountered by an executing program. Exceptions can be thrown because of a fault in your code or in code that you call (such as a shared library), unavailable operating system resources, unexpected conditions that the runtime encounters (such as code that cannot be verified), and so on. Your application can recover from some of these conditions, but not from others. Although you can recover from most application exceptions, you cannot recover from most runtime exceptions.\n\nIn .NET, an exception is an object that inherits from the [System.Exception](https://docs.microsoft.com/dotnet/core/api/System.Exception) class. An exception is thrown from an area of code where a problem has occurred. The exception is passed up the stack until the application handles it or the program terminates.\n\n## Exceptions vs. traditional error-handling methods\n\nTraditionally, a language's error-handling model relied on either the language's unique way of detecting errors and locating handlers for them, or on the error-handling mechanism provided by the operating system. The way .NET implements exception handling provides the following advantages:\n\n- Exception throwing and handling works the same for .NET programming languages.\n\n- Does not require any particular language syntax for handling exceptions, but allows each language to define its own syntax.\n\n- Exceptions can be thrown across process and even machine boundaries.\n\n- Exception-handling code can be added to an application to increase program reliability.\n\nExceptions offer advantages over other methods of error notification, such as return codes. Failures do not go unnoticed because if an exception is thrown and you don't handle it, the runtime terminates your application. Invalid values do not continue to propagate through the system as a result of code that fails to check for a failure return code. \n\n## Exception class and properties\n\nThe [Exception](https://docs.microsoft.com/dotnet/core/api/System.Exception) class is the base class from which exceptions inherit. For example, the [InvalidCastException](https://docs.microsoft.com/dotnet/core/api/System.InvalidCastException) class hierarchy is as follows:\n\n```\nObject\n  Exception\n    SystemException\n       InvalidCastException\n```\n\nThe **Exception** class has the following properties that help make understanding an exception easier.\n\n| Property Name | Description |\n| ------------- | ----------- |\n| [Data](https://docs.microsoft.com/dotnet/core/api/System.Exception#System_Exception_Data) | An [IDictionary](https://docs.microsoft.com/dotnet/core/api/System.Collections.IDictionary) that holds arbitrary data in key-value pairs. |\n| [HelpLink](https://docs.microsoft.com/dotnet/core/api/System.Exception#System_Exception_HelpLink) | Can hold a URL (or URN) to a help file that provides extensive information about the cause of an exception. |\n| [InnerException](https://docs.microsoft.com/dotnet/core/api/System.Exception#System_Exception_InnerException) | This property can be used to create and preserve a series of exceptions during exception handling. You can use it to create a new exception that contains previously caught exceptions. The original exception can be captured by the second exception in the **InnerException** property, allowing code that handles the second exception to examine the additional information. For example, suppose you have a method that receives an argument that's improperly formatted.  The code tries to read the argument, but an exception is thrown. The method catches the exception and throws a [FormatException](https://docs.microsoft.com/dotnet/core/api/System.FormatException). To improve the caller's ability to determine the reason an exception is thrown, it is sometimes desirable for a method to catch an exception thrown by a helper routine and then throw an exception more indicative of the error that has occurred. A new and more meaningful exception can be created, where the inner exception reference can be set to the original exception. This more meaningful exception can then be thrown to the caller. Note that with this functionality, you can create a series of linked exceptions that ends with the exception that was thrown first. |\n| [Message](https://docs.microsoft.com/dotnet/core/api/System.Exception#System_Exception_Message) | Provides details about the cause of an exception.\n| [Source](https://docs.microsoft.com/dotnet/core/api/System.Exception#System_Exception_Source) | Gets or sets the name of the application or the object that causes the error. |\n| [StackTrace](https://docs.microsoft.com/dotnet/core/api/System.Exception#System_Exception_StackTrace) | Contains a stack trace that can be used to determine where an error occurred. The stack trace includes the source file name and program line number if debugging information is available. |\n\nMost of the classes that inherit from **Exception** do not implement additional members or provide additional functionality; they simply inherit from **Exception**. Therefore, the most important information for an exception can be found in the hierarchy of exception classes, the exception name, and the information contained in the exception.\n\nIt is recommended to throw and catch only objects that derive from **Exception**, but you can throw any object that derives from the [Object](https://docs.microsoft.com/dotnet/core/api/System.Object) class as an exception. Note that not all languages support throwing and catching objects that do not derive from **Exception**.\n\n## Common Exceptions\n\nThe following table lists some common exceptions with examples of what can cause them.\n\n| Exception type | Base type | Description | Example |\n| -------------- | --------- | ----------- | ------- |\n| [Exception](https://docs.microsoft.com/dotnet/core/api/System.Exception) | [Object](https://docs.microsoft.com/dotnet/core/api/System.Object) | Base class for all exceptions. | None (use a derived class of this exception). |\n| [IndexOutOfRangeException](https://docs.microsoft.com/dotnet/core/api/System.IndexOutOfRangeException) | [Exception](https://docs.microsoft.com/dotnet/core/api/System.Exception) | Thrown by the runtime only when an array is indexed improperly. | Indexing an array outside its valid range: `arr[arr.Length+1]` |\n| [NullReferenceException](https://docs.microsoft.com/dotnet/core/api/System.NullReferenceException) | [Exception](https://docs.microsoft.com/dotnet/core/api/System.Exception) | Thrown by the runtime only when a null object is referenced. | `object o = null; o.ToString();` |\n| [InvalidOperationException](https://docs.microsoft.com/dotnet/core/api/System.InvalidOperationException) | [Exception](https://docs.microsoft.com/dotnet/core/api/System.Exception) | Thrown by methods when in an invalid state. | Calling `Enumerator.GetNext()` after removing an Item from the underlying collection. |\n| [ArgumentException](https://docs.microsoft.com/dotnet/core/api/System.ArgumentException) | [Exception](https://docs.microsoft.com/dotnet/core/api/System.Exception) | Base class for all argument exceptions. | None (use a derived class of this exception). |\n| [ArgumentNullException](https://docs.microsoft.com/dotnet/core/api/System.ArgumentNullException) | [Exception](https://docs.microsoft.com/dotnet/core/api/System.Exception) | Thrown by methods that do not allow an argument to be null. | `String s = null; \"Calculate\".IndexOf (s);` |\n| [ArgumentOutOfRangeException](https://docs.microsoft.com/dotnet/core/api/System.ArgumentOutOfRangeException) | [Exception](https://docs.microsoft.com/dotnet/core/api/System.Exception) | Thrown by methods that verify that arguments are in a given range. | `String s = \"string\"; s.Chars[9];` |\n\n## How to use the try/catch block to catch exceptions\n\nPlace the sections of code that might throw exceptions in a **try** block and place code that handles exceptions in a **catch** block. The **catch** block is a series of statements beginning with the keyword **catch**, followed by an exception type and an action to be taken.\n\nThe following code example uses a **try**/**catch** block to catch a possible exception. The `Main` method contains a **try** block with a [StreamReader](https://docs.microsoft.com/dotnet/core/api/System.IO.StreamReader) statement that opens a data file called `data.txt` and writes a string from the file. Following the **try** block is a **catch** block that catches any exception that results from the **try** block.\n\nC#\n```\nusing System;\nusing System.IO;\n\npublic class ProcessFile\n{\n    public static void Main()\n    {\n        try\n        {\n            StreamReader sr = File.OpenText(\"data.txt\");\n            Console.WriteLine(\"The first line of this file is {0}\", sr.ReadLine());\n            sr.Dispose();\n        }\n        catch (Exception e)\n        {\n            Console.WriteLine(\"An error occurred: '{0}'\", e);\n        }\n    }\n}\n```\n\nThe common language runtime catches exceptions that are not caught by a catch block. Depending on how the runtime is configured, a debug dialog box appears, or the program stops executing and a dialog box with exception information appears, or an error is printed out to STDERR.\n\n> [!NOTE] \n> Almost any line of code can cause an exception, particularly exceptions that are thrown by the common language runtime itself, such as [OutOfMemoryException](https://docs.microsoft.com/dotnet/core/api/System.OutOfMemoryException). Most applications don't have to deal with these exceptions, but you should be aware of this possibility when writing libraries to be used by others. For suggestions on when to set code in a Try block, see [Best Practices for Exceptions](#best-practices-for-exceptions).\n \n## How to use specific exceptions in a Catch block\n\nThe preceding code example illustrates a basic **catch** statement that catches any exception. In general, though, it's good programming practice to catch a specific type of exception rather than use a basic **catch** statement.\n\nWhen an exception occurs, it is passed up the stack and each catch block is given the opportunity to handle it. The order of catch statements is important. Put catch blocks targeted to specific exceptions before a general exception catch block or the compiler might issue an error. The proper catch block is determined by matching the type of the exception to the name of the exception specified in the catch block. If there is no specific catch block, the exception is caught by a general catch block, if one exists.\n\nThe following code example uses a **try**/**catch** block to catch an [InvalidCastException](https://docs.microsoft.com/dotnet/core/api/System.InvalidCastException). The sample creates a class called `Employee` with a single property, employee level (`Emlevel`). A method, `PromoteEmployee`, takes an object and increments the employee level. An **InvalidCastException** occurs when a [DateTime](https://docs.microsoft.com/dotnet/core/api/System.DateTime) instance is passed to the `PromoteEmployee` method.\n\nC#\n```\nusing System;\n\npublic class Employee\n{\n    //Create employee level property.\n    public int Emlevel\n    {\n        get\n        {\n            return(emlevel);\n        }\n        set\n        {\n            emlevel = value;\n        }\n    }\n\n    private int emlevel = 0;\n}\n\npublic class Ex13\n{\n    public static void PromoteEmployee(Object emp)\n    {\n        //Cast object to Employee.\n        Employee e = (Employee) emp;\n        // Increment employee level.\n        e.Emlevel = e.Emlevel + 1;\n    }\n\n    public static void Main()\n    {\n        try\n        {\n            Object o = new Employee();\n            DateTime newyears = new DateTime(2001, 1, 1);\n            //Promote the new employee.\n            PromoteEmployee(o);\n            //Promote DateTime; results in InvalidCastException as newyears is not an employee instance.\n            PromoteEmployee(newyears);\n        }\n        catch (InvalidCastException e)\n        {\n            Console.WriteLine(\"Error passing data to PromoteEmployee method. \" + e.Message);\n        }\n    }\n}\n```\n\n## How to use finally blocks\n\nWhen an exception occurs, execution stops and control is given to the appropriate exception handler. This often means that lines of code you expect to be executed are bypassed. Some resource cleanup, such as closing a file, needs to be done even if an exception is thrown. To do this, you can use a **finally** block. A **finally** block always executes, regardless of whether an exception is thrown.\n\nThe following code example uses a **try**/**catch** block to catch an [ArgumentOutOfRangeException](https://docs.microsoft.com/dotnet/core/api/System.ArgumentOutOfRangeException). The `Main` method creates two arrays and attempts to copy one to the other. The action generates an **ArgumentOutOfRangeException** and the error is written to the console. The **finally** block executes regardless of the outcome of the copy action.\n\nC#\n```\nusing System;\n\nclass ArgumentOutOfRangeExample\n{\n    public static void Main()\n    {\n        int[] array1 = {0, 0};\n        int[] array2 = {0, 0};\n\n        try\n        {\n            Array.Copy(array1, array2, -1);\n        }\n        catch (ArgumentOutOfRangeException e)\n        {\n            Console.WriteLine(\"Error: {0}\", e);\n        }\n        finally\n        {\n            Console.WriteLine(\"This statement is always executed.\");\n        }\n    }\n}\n```\n\n## How to explicitly throw exceptions\n\nYou can explicitly throw an exception using the **throw** statement. You can also throw a caught exception again using the **throw** statement. It is good coding practice to add information to an exception that is re-thrown to provide more information when debugging.\n\nThe following code example uses a **try**/**catch** block to catch a possible [FileNotFoundException](https://docs.microsoft.com/dotnet/core/api/System.IO.FileNotFoundException). Following the **try** block is a **catch** block that catches the **FileNotFoundException** and writes a message to the console if the data file is not found. The next statement is the **throw** statement that throws a new **FileNotFoundException** and adds text information to the exception.\n\nC#\n```\nusing System;\nusing System.IO;\n\npublic class ProcessFile\n{\n   public static void Main()\n      {\n      FileStream fs = null;\n      try   \n      {\n         //Opens a text tile.\n         fs = new FileStream(@\"C:\\temp\\data.txt\", FileMode.Open);\n         StreamReader sr = new StreamReader(fs);\n         string line;\n\n         //A value is read from the file and output to the console.\n         line = sr.ReadLine();\n         Console.WriteLine(line);\n      }\n      catch(FileNotFoundException e)\n      {\n         Console.WriteLine(\"[Data File Missing] {0}\", e);\n         throw new FileNotFoundException(@\"[data.txt not in c:\\temp directory]\",e);\n      }\n      finally\n      {\n         if (fs != null)\n            fs.Dispose();\n      }\n   }\n}\n```\n\n## How to create user-defined exceptions\n\n.NET provides a hierarchy of exception classes ultimately derived from the base class [Exception](https://docs.microsoft.com/dotnet/core/api/System.Exception). However, if none of the predefined exceptions meets your needs, you can create your own exception classes by deriving from the **Exception** class.\n\nWhen creating your own exceptions, end the class name of the user-defined exception with the word \"Exception,\" and implement the three common constructors, as shown in the following example. The example defines a new exception class named `EmployeeListNotFoundException`. The class is derived from **Exception** and includes three constructors.\n\nC#\n```\nusing System;\n\npublic class EmployeeListNotFoundException: Exception\n{\n    public EmployeeListNotFoundException()\n    {\n    }\n\n    public EmployeeListNotFoundException(string message)\n        : base(message)\n    {\n    }\n\n    public EmployeeListNotFoundException(string message, Exception inner)\n        : base(message, inner)\n    {\n    }\n}\n```\n\n> [!NOTE]\n> In situations where you are using remoting, you must ensure that the metadata for any user-defined exceptions is available at the server (callee) and to the client (the proxy object or caller). For more information, see [Best practices for exceptions](#best-practices-for-exceptions).\n\n## Best practices for exceptions\n\nA well-designed app handles exceptions and errors to prevent app crashes. This section describes best practices for handling and creating exceptions.\n\n### Use try/catch/finally blocks\n\nUse **try**/**catch**/**finally** blocks around code that can potentially generate an exception. \n\nIn **catch** blocks, always order exceptions from the most specific to the least specific.\n\nUse a **finally** block to clean up resources, whether you can recover or not.\n\n### Handle common conditions without throwing exceptions\n\nFor conditions that are likely to occur but might trigger an exception, consider handling them in a way that will avoid the exception. For example, if you try to close a connection that is already closed, you'll get an `InvalidOperationException`. You can avoid that by using an **if** statement to check the connection state before trying to close it.\n\nC#\n```\nif (conn.State != ConnectionState.Closed)\n{\n    conn.Close();\n}\n```\n\nIf you don't check connection state before closing, you can catch the `InvalidOperationException` exception.\n\nC#\n```\ntry\n{\n    conn.Close();\n}\ncatch (InvalidOperationException ex)\n{\n    Console.WriteLine(ex.GetType().FullName);\n    Console.WriteLine(ex.Message);\n}\n```\n\nThe method to choose depends on how often you expect the event to occur.\n\n- Use exception handling if the event doesn't occur very often, that is, if the event is truly exceptional and indicates an error (such as an unexpected end-of-file). When you use exception handling, less code is executed in normal conditions.\n\n- Check for error conditions in code if the event happens routinely and could be considered part of normal execution. When you check for common error conditions, less code is executed because you avoid exceptions.\n\n### Design classes so that exceptions can be avoided\n\nA class can provide methods or properties that enable you to avoid making a call that would trigger an exception. For example, a [FileStream](https://docs.microsoft.com/dotnet/core/api/System.IO.FileStream) class provides methods that help determine whether the end of the file has been reached. These can be used to avoid the exception that is thrown if you read past the end of the file. The following example shows how to read to the end of a file without triggering an exception.\n\nC#\n```\nclass FileRead\n{\n    public void ReadAll(FileStream fileToRead)\n    {\n        // This if statement is optional\n        // as it is very unlikely that\n        // the stream would ever be null.\n        if (fileToRead == null)\n        {\n            throw new System.ArgumentNullException();\n        }\n\n        int b;\n\n        // Set the stream position to the beginning of the file.\n        fileToRead.Seek(0, SeekOrigin.Begin);\n\n        // Read each byte to the end of the file.\n        for (int i = 0; i < fileToRead.Length; i++)\n        {\n            b = fileToRead.ReadByte();\n            Console.Write(b.ToString());\n            // Or do something else with the byte.\n        }\n    }\n}\n```\n\nAnother way to avoid exceptions is to return null for extremely common error cases instead of throwing an exception. An extremely common error case can be considered normal flow of control. By returning null in these cases, you minimize the performance impact to an app.\n\n### Throw exceptions instead of returning an error code\n\nExceptions ensure that failures do not go unnoticed because calling code didn't check a return code. \n\n### Use the predefined .NET exception types\n\nIntroduce a new exception class only when a predefined one doesn't apply. For example:\n\n- Throw an [InvalidOperationException](https://docs.microsoft.com/dotnet/core/api/System.InvalidOperationException) exception if a property set or method call is not appropriate given the object's current state.\n\n- Throw an [ArgumentException](https://docs.microsoft.com/dotnet/core/api/System.ArgumentException) exception or one of the predefined classes that derive from [ArgumentException](https://docs.microsoft.com/dotnet/core/api/System.ArgumentException) if invalid parameters are passed.\n\n### End exception class names with the word \"Exception\"\n\nWhen a custom exception is necessary, name it appropriately and derive it from the [Exception](https://docs.microsoft.com/dotnet/core/api/System.Exception) class. For example:\n\nC#\n```\npublic class MyFileNotFoundException : Exception\n{\n}\n```\n\n### Include three constructors in custom exception classes\n\nUse at least the three common constructors when creating your own exception classes: the default constructor, a constructor that takes a string message, and a constructor that takes a string message and an inner exception.\n\n- [Exception()](https://docs.microsoft.com/dotnet/core/api/System.Exception#System_Exception__ctor), which uses default values.\n\n- [Exception(String)](https://docs.microsoft.com/dotnet/core/api/System.Exception#System_Exception__ctor_System_String_), which accepts a string message.\n\n- [Exception(String, Exception)](https://docs.microsoft.com/dotnet/core/api/System.Exception#System_Exception__ctor_System_String_System_Exception_), which accepts a string message and an inner exception.\n\nFor an example, see [How to: Create User-Defined Exceptions](#how-to-create-user-defined-exceptions).\n\n### Ensure that exception data is available when code executes remotely\n\nWhen you create user-defined exceptions, ensure that the metadata for the exceptions is available to code that is executing remotely. \n\nFor example, on .NET runtimes that implement App Domains, exceptions may occur across App domains. Suppose App Domain A creates App Domain B, which executes code that throws an exception. For App Domain A to properly catch and handle the exception, it must be able to find the assembly that contains the exception thrown by App Domain B. If App Domain B throws an exception that is contained in an assembly under its application base, but not under App Domain A's application base, App Domain A will not be able to find the exception, and the common language runtime will throw a [FileNotFoundException](https://docs.microsoft.com/dotnet/core/api/System.IO.FileNotFoundException) exception. To avoid this situation, you can deploy the assembly that contains the exception information in two ways:\n\n- Put the assembly into a common application base shared by both app domains.\n\n    \\- or -\n\n- If the domains do not share a common application base, sign the assembly that contains the exception information with a strong name and deploy the assembly into the global assembly cache.\n\n### Include a localized description string in every exception\n\nThe error message that the user sees is derived from the description string of the exception that was thrown, and not from the name of the exception class.\n\n### Use grammatically correct error messages\n\nWrite clear sentences and include ending punctuation. Each sentence in a description string of an exception should end in a period. For example, \"The log table has overflowed.” would be an appropriate description string.\n\n### In custom exceptions, provide additional properties as needed\n\nProvide additional properties for an exception (in addition to the description string) only when there's a programmatic scenario where the additional information is useful. For example, the [FileNotFoundException](https://docs.microsoft.com/dotnet/core/api/System.IO.FileNotFoundException) provides the [FileName](https://docs.microsoft.com/dotnet/core/api/System.IO.FileNotFoundException#System_IO_FileNotFoundException_FileName) property.\n\n### Place throw statements so that the stack trace will be helpful\n\nThe stack trace begins at the statement where the exception is thrown and ends at the **catch** statement that catches the exception.\n\n### Use exception builder methods\n\nIt is common for a class to throw the same exception from different places in its implementation. To avoid excessive code, use helper methods that create the exception and return it. For example:\n\nC#\n```\nclass FileReader\n{\n    private string fileName;\n\n    public FileReader(string path)\n    {\n        fileName = path;\n    }\n\n    public byte[] Read(int bytes)\n    {\n        byte[] results = FileUtils.ReadFromFile(fileName, bytes);\n        if (results == null)\n        {\n            throw NewFileIOException();\n        }\n        return results;\n    }\n\n    FileReaderException NewFileIOException()\n    {\n        string description = \"My NewFileIOException Description\";\n\n        return new FileReaderException(description);\n    }\n}\n\n```\n\nIn some cases, it's more appropriate to use the exception's constructor to build the exception. An example is a global exception class such as [ArgumentException](https://docs.microsoft.com/dotnet/core/api/System.ArgumentException), \n\n### Clean up intermediate results when throwing an exception\n\nCallers should be able to assume that there are no side effects when an exception is thrown from a method. For example, if you have code that transfers money by withdrawing from one account and depositing in another account, and an exception is thrown while executing the deposit, you don't want the withdrawal to remain in effect.\n\nC#\n```\npublic void TransferFunds(Account from, Account to, decimal amount)\n{\n    from.Withdrawal(amount);\n    // If the deposit fails, the withdrawal shouldn't remain in effect. \n    to.Deposit(amount);\n}\n```\n\nOne way to handle this situation is to catch any exceptions thrown by the deposit transaction and roll back the withdrawal.\n\nC#\n```\nprivate static void TransferFunds(Account from, Account to, decimal amount)\n{\n    string withdrawalTrxID = from.Withdrawal(amount);\n    try\n    {\n        to.Deposit(amount);\n    }\n    catch\n    {\n        from.RollbackTransaction(withdrawalTrxID);\n        throw\n    }\n}\n```\n\nThis example illustrates the use of **throw** to re-throw the original exception, which can make it easier for callers to see the real cause of the problem without having to examine the [InnerException](https://docs.microsoft.com/dotnet/core/api/System.Exception#System_Exception_InnerException) property. An alternative is to throw a new exception and include the original exception as the inner exception:\n\nC#\n```\ncatch (Exception ex)\n{\n    from.RollbackTransaction(withdrawalTrxID);\n    throw new Exception(\"Withdrawal failed\", ex);\n}\n```\n\n## Next steps\n\nTo learn more about how exceptions work in .NET, see [What Every Dev needs to Know About Exceptions in the Runtime](https://github.com/dotnet/coreclr/blob/master/Documentation/botr/exceptions.md).\n"}