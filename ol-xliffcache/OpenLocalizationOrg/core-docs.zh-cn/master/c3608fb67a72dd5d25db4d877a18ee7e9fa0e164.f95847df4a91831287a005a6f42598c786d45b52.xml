{"nodes":[{"pos":[11,46],"content":"Migrating from DNX to .NET Core CLI","needQuote":true,"nodes":[{"content":"Migrating from DNX to .NET Core CLI","pos":[0,35]}]},{"pos":[60,95],"content":"Migrating from DNX to .NET Core CLI","needQuote":true,"nodes":[{"content":"Migrating from DNX to .NET Core CLI","pos":[0,35]}]},{"pos":[106,121],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":"Migrating from DNX to .NET Core CLI","pos":[329,364]},{"content":"Overview","pos":[369,377]},{"content":"With RC1 release of .NET Core and ASP.NET Core 1.0, we introduced DNX tooling to the world.","pos":[378,469]},{"content":"With RC2 release of .NET Core and ASP.NET Core 1.0 we transitioned to the .NET Core CLI.","pos":[470,559],"source":" With RC2 release of .NET \nCore and ASP.NET Core 1.0 we transitioned to the .NET Core CLI."},{"content":"As a slight refresher, let's recap what DNX was about.","pos":[561,615]},{"content":"DNX was a runtime and a toolset used to build .NET Core and, more specifically, ASP.NET Core 1.0 applications.","pos":[616,727],"source":" DNX was a runtime and a toolset used to build .NET Core and, \nmore specifically, ASP.NET Core 1.0 applications."},{"content":"It consisted of 3 main pieces:","pos":[728,758]},{"content":"DNVM - an install script for obtaining DNX","pos":[763,805]},{"content":"DNX (Dotnet Execution Runtime) - the runtime that executes your code","pos":[809,877]},{"content":"DNU (Dotnet Developer Utility) - tooling for managing dependencies, building and publishing your applications","pos":[881,990]},{"content":"With the introduction of the CLI, all of the above are now part of a single toolset.","pos":[992,1076]},{"content":"However, since DNX was available in RC1 timeframe, you might have projects that were built using it that you would want to move off to the new CLI tooling.","pos":[1077,1233],"source":" However, since DNX was available in RC1 \ntimeframe, you might have projects that were built using it that you would want to move off to the new CLI tooling."},{"content":"This migration guide will cover the essentials on how to migrate projects off of DNX and onto .NET Core CLI.","pos":[1236,1344]},{"content":"If you are just starting a project on .NET Core from scratch, you can freely skip this document.","pos":[1345,1442],"source":" If you are just \nstarting a project on .NET Core from scratch, you can freely skip this document."},{"content":"Main changes in the tooling","pos":[1448,1475]},{"content":"There are some general changes in the tooling that should be outlined first.","pos":[1476,1552]},{"content":"No more DNVM","pos":[1559,1571]},{"content":"DNVM, short for <bpt id=\"p1\">*</bpt>DotNet Version Manager<ept id=\"p1\">*</ept> was a bash/PowerShell script used to install a DNX on your machine.","pos":[1572,1680],"source":"DNVM, short for *DotNet Version Manager* was a bash/PowerShell script used to install a DNX on your machine."},{"content":"It helped users get the DNX they need from the feed they specified (or default ones) as well as mark a certain DNX \"active\", which would put it on the $PATH for the given session.","pos":[1681,1861],"source":" It helped\nusers get the DNX they need from the feed they specified (or default ones) as well as mark a certain DNX \"active\", which \nwould put it on the $PATH for the given session."},{"content":"This would allow you to use the various tools.","pos":[1862,1908]},{"content":"DNVM was discontinued because its feature set was made redundant by changes coming in the .NET Core CLI tools.","pos":[1910,2020]},{"pos":[2022,2141],"content":"The CLI tools come packaged in two main ways, as was explained in the <bpt id=\"p1\">[</bpt>overview document<ept id=\"p1\">](tools/index.md#installation)</ept>:","source":"The CLI tools come packaged in two main ways, as was explained in the [overview document](tools/index.md#installation):"},{"content":"Native installers for a given platform","pos":[2146,2184]},{"content":"Install script for other situations (like CI servers)","pos":[2188,2241]},{"content":"Given this, the DNVM install features are not needed.","pos":[2243,2296]},{"content":"But what about the runtime selection features?","pos":[2297,2343]},{"content":"You reference a runtime in your <ph id=\"ph1\">`project.json`</ph> by adding a package of a certain version to your dependencies.","pos":[2346,2455],"source":"You reference a runtime in your `project.json` by adding a package of a certain version to your dependencies."},{"content":"With this change, your application will be able to use the new runtime bits.","pos":[2456,2533],"source":" With this change, \nyour application will be able to use the new runtime bits."},{"content":"Getting these bits to your machine is the same as with the CLI: you install the runtime via one of the native installers it supports or via its install script.","pos":[2534,2694],"source":" Getting these bits to your machine is the same as with the CLI: \nyou install the runtime via one of the native installers it supports or via its install script."},{"content":"Different commands","pos":[2701,2719]},{"content":"If you were using DNX, you used some commands from one of its three parts (DNX, DNU or DNVM).","pos":[2720,2813]},{"content":"With the CLI, some of these commands change, some are not available and some are the same but have slightly different semantics.","pos":[2814,2942],"source":" With the CLI, some of these\ncommands change, some are not available and some are the same but have slightly different semantics."},{"content":"The table below shows the mapping between the DNX/DNU commands and their CLI counterparts.","pos":[2945,3035]},{"content":"DNX command","pos":[3040,3051]},{"content":"CLI command","pos":[3076,3087]},{"content":"Description","pos":[3096,3107]},{"content":"dnx run","pos":[3388,3395]},{"content":"dotnet run","pos":[3424,3434]},{"content":"Run code from source.","pos":[3444,3465]},{"content":"dnu build","pos":[3562,3571]},{"content":"dotnet build","pos":[3598,3610]},{"content":"Build an IL binary of your code.","pos":[3618,3650]},{"content":"dnu pack","pos":[3736,3744]},{"content":"dotnet pack","pos":[3772,3783]},{"content":"Package up a NuGet package of your code.","pos":[3792,3832]},{"content":"dnx <ph id=\"ph1\">\\[</ph>command] (for example, \"dnx web\")","pos":[3910,3949],"source":"dnx \\[command] (for example, \"dnx web\")"},{"content":"N/A","pos":[3954,3957]},{"content":"In DNX world, run a command as defined in the project.json.","pos":[3974,4033]},{"content":"dnu install","pos":[4092,4103]},{"content":"N/A","pos":[4128,4131]},{"content":"In the DNX world, install a package as a dependency.","pos":[4148,4200]},{"content":"dnu restore","pos":[4266,4277]},{"content":"dotnet restore","pos":[4302,4316]},{"content":"Restore dependencies specified in your project.json.","pos":[4322,4374]},{"content":"dnu publish","pos":[4440,4451]},{"content":"dotnet publish","pos":[4476,4490]},{"content":"Publish your application for deployment in one of the three forms (portable, portable with native and standalone).","pos":[4496,4610]},{"content":"dnu wrap","pos":[4618,4626]},{"content":"N/A","pos":[4654,4657]},{"content":"In DNX world, wrap a project.json in csproj.","pos":[4674,4718]},{"content":"dnu commands","pos":[4792,4804]},{"content":"N/A","pos":[4828,4831]},{"content":"In DNX world, manage the globally installed commands.","pos":[4848,4901]},{"content":"(<ph id=\"ph1\">\\*</ph>) - these features are not supported in the CLI by design.","pos":[4965,5026],"source":"(\\*) - these features are not supported in the CLI by design."},{"content":"DNX features that are not supported","pos":[5032,5067]},{"content":"As the table above shows, there are features from the DNX world that we decided not to support in the CLI, at least for the time being.","pos":[5068,5204],"source":"As the table above shows, there are features from the DNX world that we decided not to support in the CLI, at least for \nthe time being."},{"content":"This section will go through the most important ones and outline the rationale behind not supporting them as well as workarounds if you do need them.","pos":[5205,5355],"source":" This section will go through the most important ones and outline the rationale behind not supporting \nthem as well as workarounds if you do need them."},{"content":"Global commands","pos":[5361,5376]},{"content":"DNU came with a concept called \"global commands\".","pos":[5377,5426]},{"content":"These were, essentially, console applications packaged up as NuGet packages with a shell script that would invoke the DNX you specified to run the application.","pos":[5427,5587],"source":" These were, essentially, console applications packaged up as NuGet \npackages with a shell script that would invoke the DNX you specified to run the application."},{"content":"The CLI does not support this concept.","pos":[5590,5628]},{"content":"It does, however, support the concept of adding per-project commands that can be invoked using the familiar <ph id=\"ph1\">`dotnet &lt;command&gt;`</ph> syntax.","pos":[5629,5764],"source":" It does, however, support the concept of adding per-project commands that can be \ninvoked using the familiar `dotnet <command>` syntax."},{"content":"More about this can be found in the <bpt id=\"p1\">[</bpt>extensibility overview<ept id=\"p1\">](tools/index.md#extensibility)</ept>.","pos":[5765,5857],"source":" More about this can be found in the \n[extensibility overview](tools/index.md#extensibility)."},{"content":"Installing dependencies","pos":[5864,5887]},{"content":"As of v1, the .NET Core CLI tools don't have an <ph id=\"ph1\">`install`</ph> command for installing dependencies.","pos":[5888,5982],"source":"As of v1, the .NET Core CLI tools don't have an `install` command for installing dependencies."},{"content":"In order to install a package from NuGet, you would need to add it as a dependency to your <ph id=\"ph1\">`project.json`</ph> file and then run <ph id=\"ph2\">`dotnet restore`</ph>.","pos":[5983,6125],"source":" In order to install a \npackage from NuGet, you would need to add it as a dependency to your `project.json` file and then run `dotnet restore`."},{"content":"Running your code","pos":[6132,6149]},{"content":"There are two main ways to run your code.","pos":[6150,6191]},{"content":"One is from source, with <ph id=\"ph1\">`dotnet run`</ph>.","pos":[6192,6230],"source":" One is from source, with `dotnet run`."},{"content":"Unlike <ph id=\"ph1\">`dnx run`</ph>, this will not do any in-memory compilation.","pos":[6231,6293],"source":" Unlike `dnx run`, this will not do any \nin-memory compilation."},{"content":"It will actually invoke <ph id=\"ph1\">`dotnet build`</ph> to build your code and then run the built binary.","pos":[6294,6382],"source":" It will actually invoke `dotnet build` to build your code and then run the built binary."},{"content":"Another way is using the <ph id=\"ph1\">`dotnet`</ph> itself to run your code.","pos":[6385,6443],"source":"Another way is using the `dotnet` itself to run your code."},{"content":"This is done by providing a path to your assembly: <ph id=\"ph1\">`dotnet path/to/an/assembly.dll`</ph>.","pos":[6444,6528],"source":" This is done by providing a path to your assembly:\n`dotnet path/to/an/assembly.dll`."},{"content":"Migrating your DNX project to .NET Core CLI","pos":[6534,6577]},{"content":"In addition to using new commands when working with your code, there are three major things left in migrating from DNX:","pos":[6578,6697]},{"pos":[6702,6770],"content":"Migrate the <ph id=\"ph1\">`global.json`</ph> file if you have it to be able to use CLI.","source":"Migrate the `global.json` file if you have it to be able to use CLI."},{"pos":[6774,6844],"content":"Migrating the project file (<ph id=\"ph1\">`project.json`</ph>) itself to the CLI tooling.","source":"Migrating the project file (`project.json`) itself to the CLI tooling."},{"content":"Migrating off of any DNX APIs to their BCL counterparts.","pos":[6848,6904]},{"content":"Changing the global.json file","pos":[6911,6940]},{"content":"The <ph id=\"ph1\">`global.json`</ph> file acts like a solution file for both the RC1 and RC2 (or later) projects.","pos":[6941,7035],"source":"The `global.json` file acts like a solution file for both the RC1 and RC2 (or later) projects."},{"content":"In order for the CLI tools (as well as Visual Studio) to differentiate between RC1 and later versions, they use the <ph id=\"ph1\">`\"sdk\": { \"version\" }`</ph> property to make the distinction which project is RC1 or later.","pos":[7036,7239],"source":" In order for the CLI tools (as well \nas Visual Studio) to differentiate between RC1 and later versions, they use the `\"sdk\": { \"version\" }` property to make the distinction\nwhich project is RC1 or later."},{"content":"If <ph id=\"ph1\">`global.json`</ph> doesn't have this node at all, it is assumed to be the latest.","pos":[7240,7319],"source":" If `global.json` doesn't have this node at all, it is assumed to be the latest."},{"pos":[7322,7498],"content":"In order to update the <ph id=\"ph1\">`global.json`</ph> file, either remove the property or set it to the exact version of the tools that you wish to use, in this case <bpt id=\"p1\">**</bpt>1.0.0-preview2-003121<ept id=\"p1\">**</ept>:","source":"In order to update the `global.json` file, either remove the property or set it to the exact version of the \ntools that you wish to use, in this case **1.0.0-preview2-003121**:"},{"content":"Migrating the project file","pos":[7583,7609]},{"content":"The CLI and DNX both use the same basic project system based on <ph id=\"ph1\">`project.json`</ph> file.","pos":[7610,7694],"source":"The CLI and DNX both use the same basic project system based on `project.json` file."},{"content":"The syntax and the semantics of the project file are pretty much the same, with small differences based on the scenarios.","pos":[7695,7817],"source":" The syntax and the semantics of the \nproject file are pretty much the same, with small differences based on the scenarios."},{"content":"There are also some changes to the schema which you can see in the <bpt id=\"p1\">[</bpt>schema file<ept id=\"p1\">](http://json.schemastore.org/project)</ept> or in a more friendly <bpt id=\"p2\">[</bpt>project.json reference<ept id=\"p2\">](tools/project-json.md)</ept>.","pos":[7818,8008],"source":" There are also some changes to \nthe schema which you can see in the [schema file](http://json.schemastore.org/project) or in a more friendly \n[project.json reference](tools/project-json.md)."},{"content":"If you are building a console application, you need to add the following snippet to your project file:","pos":[8011,8113]},{"content":"This instructs <ph id=\"ph1\">`dotnet build`</ph> to emit an entry point for your application, effectively making your code runnable.","pos":[8175,8288],"source":"This instructs `dotnet build` to emit an entry point for your application, effectively making your code runnable."},{"content":"If you are building a class library, simply omit the above section.","pos":[8289,8357],"source":" If \nyou are building a class library, simply omit the above section."},{"content":"Of course, once you add the above snippet to your <ph id=\"ph1\">`project.json`</ph> file, you need to add a static entry point.","pos":[8358,8467],"source":" Of course, once you add the above snippet to your \n`project.json` file, you need to add a static entry point."},{"content":"With the move off DNX, the DI services it provided are no longer available and thus this needs to be a basic .NET entry point: <ph id=\"ph1\">`static void Main()`</ph>.","pos":[8468,8617],"source":" With the move off DNX, the DI services it provided are no \nlonger available and thus this needs to be a basic .NET entry point: `static void Main()`."},{"content":"If you have a \"commands\" section in your <ph id=\"ph1\">`project.json`</ph>, you can remove it.","pos":[8619,8694],"source":"If you have a \"commands\" section in your `project.json`, you can remove it."},{"content":"Some of the commands that used to exist as DNU commands, such as Entity Framework CLI commands, are being ported to be per-project extensions to the CLI.","pos":[8695,8850],"source":" Some of the commands that used to exist as \nDNU commands, such as Entity Framework CLI commands, are being ported to be \nper-project extensions to the CLI."},{"content":"If you built your own commands that you are using in your projects, you need to replace them with CLI extensions.","pos":[8851,8965],"source":" If you built your own commands that you are using in your projects, you need to \nreplace them with CLI extensions."},{"content":"In this case, the <ph id=\"ph1\">`commands`</ph> node in <ph id=\"ph2\">`project.json`</ph> needs to be replaced by the <ph id=\"ph3\">`tools`</ph> node and it needs to list the tools dependencies as explained in the <bpt id=\"p1\">[</bpt>CLI extensibility section<ept id=\"p1\">](tools/index.md#extensibility)</ept>.","pos":[8966,9183],"source":" In this case, the `commands` node in `project.json` needs to be replaced by the \n`tools` node and it needs to list the tools dependencies as explained in the \n[CLI extensibility section](tools/index.md#extensibility)."},{"content":"After these things are done, you need to decide which type of portability you wish for you app.","pos":[9186,9281]},{"content":"With .NET Core, we have invested into providing a spectrum of portability options that you can choose from.","pos":[9282,9390],"source":" With .NET Core, we have \ninvested into providing a spectrum of portability options that you can choose from."},{"content":"For instance, you may want to have a fully <bpt id=\"p1\">*</bpt>portable<ept id=\"p1\">*</ept> application or you may want to have a <bpt id=\"p2\">*</bpt>self-contained<ept id=\"p2\">*</ept> application.","pos":[9391,9513],"source":" For instance, you may want to have \na fully *portable* application or you may want to have a *self-contained* application."},{"content":"The portable application option is more like .NET Framework applications work: it needs a shared component to execute it on the target machine (.NET Core).","pos":[9514,9671],"source":" The portable application option is more \nlike .NET Framework applications work: it needs a shared component to execute it on the target machine \n(.NET Core)."},{"content":"The self-contained application doesn't require .NET Core to be installed on the target, but you have to produce one application for each OS you wish to support.","pos":[9672,9833],"source":" The self-contained application doesn't require .NET Core to be installed on the target, but you have to \nproduce one application for each OS you wish to support."},{"content":"These portability types and more are discussed in the <bpt id=\"p1\"> [</bpt>application portability type<ept id=\"p1\">](app-types.md)</ept> document.","pos":[9834,9943],"source":" These portability types and more are discussed in the\n [application portability type](app-types.md) document."},{"content":"Once you make a call on what type of portability you want, you need to change your targeted framework(s).","pos":[9946,10051]},{"content":"If you were writing applications for .NET Core, you were most likely using <ph id=\"ph1\">`dnxcore50`</ph> as  your targeted framework.","pos":[10052,10168],"source":" If you were \nwriting applications for .NET Core, you were most likely using `dnxcore50` as  your targeted framework."},{"content":"With the CLI and the changes that the new <bpt id=\"p1\">[</bpt>.NET Standard Library<ept id=\"p1\">](https://github.com/dotnet/corefx/blob/master/Documentation/architecture/net-platform-standard.md)</ept> brought, the framework needs to be one of the following:","pos":[10169,10391],"source":" With the CLI \nand the changes that the new [.NET Standard Library](https://github.com/dotnet/corefx/blob/master/Documentation/architecture/net-platform-standard.md) \nbrought, the framework needs to be one of the following:"},{"pos":[10412,10496],"content":"- if you are writing applications on .NET Core (including ASP.NET Core applications)"},{"pos":[10517,10567],"content":"- if you are writing class libraries for .NET Core"},{"content":"If you are using other <ph id=\"ph1\">`dnx`</ph> targets, like <ph id=\"ph2\">`dnx451`</ph> you will need to change those as well.","pos":[10569,10659],"source":"If you are using other `dnx` targets, like `dnx451` you will need to change those as well."},{"content":"should be changed to <ph id=\"ph1\">`net451`</ph>.","pos":[10669,10699],"source":" should be changed to `net451`."},{"content":"Please refer to the <bpt id=\"p1\">[</bpt>.NET Standard Library document<ept id=\"p1\">](https://github.com/dotnet/corefx/blob/master/Documentation/architecture/net-platform-standard.md)</ept> for more information.","pos":[10700,10874],"source":" \nPlease refer to the [.NET Standard Library document](https://github.com/dotnet/corefx/blob/master/Documentation/architecture/net-platform-standard.md) \nfor more information."},{"content":"Your <ph id=\"ph1\">`project.json`</ph> is now mostly ready.","pos":[10877,10917],"source":"Your `project.json` is now mostly ready."},{"content":"You need to go through your dependencies list and update the dependencies to their newer versions, especially if you are using ASP.NET Core dependencies.","pos":[10918,11072],"source":" You need to go through your dependencies list and update the dependencies to \ntheir newer versions, especially if you are using ASP.NET Core dependencies."},{"content":"If you were using separate packages for BCL APIs, you can use the runtime package as explained in the <bpt id=\"p1\">[</bpt>application portability type<ept id=\"p1\">](app-types.md)</ept> document.","pos":[11073,11230],"source":" If you were using separate packages for BCL APIs, \nyou can use the runtime package as explained in the [application portability type](app-types.md) document."},{"content":"Once you are ready, you can try restoring with <ph id=\"ph1\">`dotnet restore`</ph>.","pos":[11233,11297],"source":"Once you are ready, you can try restoring with `dotnet restore`."},{"content":"Depending on the version of your dependencies, you may encounter errors if NuGet cannot resolve the dependencies for one of the targeted frameworks above.","pos":[11298,11454],"source":" Depending on the version of your dependencies, you \nmay encounter errors if NuGet cannot resolve the dependencies for one of the \ntargeted frameworks above."},{"content":"This is a \"point-in-time\" problem; as time progresses, more and more packages will include support for these frameworks.","pos":[11455,11576],"source":" This is a \"point-in-time\" problem; as time progresses, more and more packages will include \nsupport for these frameworks."},{"content":"For now, if you run into this, you can use the <ph id=\"ph1\">`imports`</ph> statement within the <ph id=\"ph2\">`framework`</ph> node to specify to NuGet that it can restore the packages targeting the framework within the \"imports\" statement.","pos":[11577,11781],"source":" For now, if you run into this, you can use the `imports` statement within the `framework` \nnode to specify to NuGet that it can restore the packages targeting the framework within the \"imports\" statement."},{"content":"The restoring errors you get in this case should provide enough information to tell you which frameworks you need to import.","pos":[11782,11908],"source":" \nThe restoring errors you get in this case should provide enough information to tell you which frameworks you need to \nimport."},{"content":"If you are slightly lost or new to this, in general, specifying <ph id=\"ph1\">`dnxcore50`</ph> and <ph id=\"ph2\">`portable-net45+win8`</ph> in the <ph id=\"ph3\">`imports`</ph> statement should do the trick.","pos":[11909,12059],"source":" If you are slightly lost or new to this, in general, specifying `dnxcore50` and `portable-net45+win8` in the \n`imports` statement should do the trick."},{"content":"The JSON snippet below shows how this looks like:","pos":[12060,12109]},{"content":"Running <ph id=\"ph1\">`dotnet build`</ph> will show any eventual build errors, though there shouldn't be too many of them.","pos":[12248,12351],"source":"Running `dotnet build` will show any eventual build errors, though there shouldn't be too many of them."},{"content":"After your code is building and running properly, you can test it out with the runner.","pos":[12352,12439],"source":" After your code is \nbuilding and running properly, you can test it out with the runner."},{"content":"Execute <ph id=\"ph1\">`dotnet &lt;path-to-your-assembly&gt;`</ph> and see it run.","pos":[12440,12496],"source":" Execute `dotnet <path-to-your-assembly>` and see it run."}],"content":"---\ntitle: Migrating from DNX to .NET Core CLI\ndescription: Migrating from DNX to .NET Core CLI\nkeywords: .NET, .NET Core\nauthor: blackdwarf\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: c0d70120-78c8-4d26-bb3c-801f42fc2366\n---\n\n# Migrating from DNX to .NET Core CLI\n\n## Overview\nWith RC1 release of .NET Core and ASP.NET Core 1.0, we introduced DNX tooling to the world. With RC2 release of .NET \nCore and ASP.NET Core 1.0 we transitioned to the .NET Core CLI.\n\nAs a slight refresher, let's recap what DNX was about. DNX was a runtime and a toolset used to build .NET Core and, \nmore specifically, ASP.NET Core 1.0 applications. It consisted of 3 main pieces:\n\n1. DNVM - an install script for obtaining DNX\n2. DNX (Dotnet Execution Runtime) - the runtime that executes your code\n3. DNU (Dotnet Developer Utility) - tooling for managing dependencies, building and publishing your applications\n\nWith the introduction of the CLI, all of the above are now part of a single toolset. However, since DNX was available in RC1 \ntimeframe, you might have projects that were built using it that you would want to move off to the new CLI tooling. \n\nThis migration guide will cover the essentials on how to migrate projects off of DNX and onto .NET Core CLI. If you are just \nstarting a project on .NET Core from scratch, you can freely skip this document. \n\n## Main changes in the tooling\nThere are some general changes in the tooling that should be outlined first. \n\n### No more DNVM\nDNVM, short for *DotNet Version Manager* was a bash/PowerShell script used to install a DNX on your machine. It helped\nusers get the DNX they need from the feed they specified (or default ones) as well as mark a certain DNX \"active\", which \nwould put it on the $PATH for the given session. This would allow you to use the various tools.\n\nDNVM was discontinued because its feature set was made redundant by changes coming in the .NET Core CLI tools.\n\nThe CLI tools come packaged in two main ways, as was explained in the [overview document](tools/index.md#installation):\n\n1. Native installers for a given platform\n2. Install script for other situations (like CI servers)\n\nGiven this, the DNVM install features are not needed. But what about the runtime selection features? \n\nYou reference a runtime in your `project.json` by adding a package of a certain version to your dependencies. With this change, \nyour application will be able to use the new runtime bits. Getting these bits to your machine is the same as with the CLI: \nyou install the runtime via one of the native installers it supports or via its install script. \n\n### Different commands\nIf you were using DNX, you used some commands from one of its three parts (DNX, DNU or DNVM). With the CLI, some of these\ncommands change, some are not available and some are the same but have slightly different semantics. \n\nThe table below shows the mapping between the DNX/DNU commands and their CLI counterparts.\n\n\n| DNX command                       | CLI command       | Description                                                                                                       |\n|--------------------------------   |----------------   |-----------------------------------------------------------------------------------------------------------------  |\n| dnx run                           | dotnet run        | Run code from source.                                                                                             |\n| dnu build                         | dotnet build      | Build an IL binary of your code.                                                                                  |\n| dnu pack                          | dotnet pack       | Package up a NuGet package of your code.                                                                          |\n| dnx \\[command] (for example, \"dnx web\")   | N/A\\*             | In DNX world, run a command as defined in the project.json.                                                       |\n| dnu install                       | N/A\\*             | In the DNX world, install a package as a dependency.                                                              |\n| dnu restore                       | dotnet restore    | Restore dependencies specified in your project.json.                                                              |\n| dnu publish                       | dotnet publish    | Publish your application for deployment in one of the three forms (portable, portable with native and standalone).    |\n| dnu wrap                          | N/A\\*             | In DNX world, wrap a project.json in csproj.                                                                      |\n| dnu commands                      | N/A\\*             | In DNX world, manage the globally installed commands.                                                             |\n\n(\\*) - these features are not supported in the CLI by design. \n\n## DNX features that are not supported\nAs the table above shows, there are features from the DNX world that we decided not to support in the CLI, at least for \nthe time being. This section will go through the most important ones and outline the rationale behind not supporting \nthem as well as workarounds if you do need them.\n\n### Global commands\nDNU came with a concept called \"global commands\". These were, essentially, console applications packaged up as NuGet \npackages with a shell script that would invoke the DNX you specified to run the application. \n\nThe CLI does not support this concept. It does, however, support the concept of adding per-project commands that can be \ninvoked using the familiar `dotnet <command>` syntax. More about this can be found in the \n[extensibility overview](tools/index.md#extensibility). \n\n### Installing dependencies\nAs of v1, the .NET Core CLI tools don't have an `install` command for installing dependencies. In order to install a \npackage from NuGet, you would need to add it as a dependency to your `project.json` file and then run `dotnet restore`. \n\n### Running your code\nThere are two main ways to run your code. One is from source, with `dotnet run`. Unlike `dnx run`, this will not do any \nin-memory compilation. It will actually invoke `dotnet build` to build your code and then run the built binary. \n\nAnother way is using the `dotnet` itself to run your code. This is done by providing a path to your assembly:\n`dotnet path/to/an/assembly.dll`. \n\n## Migrating your DNX project to .NET Core CLI\nIn addition to using new commands when working with your code, there are three major things left in migrating from DNX:\n\n1. Migrate the `global.json` file if you have it to be able to use CLI.\n2. Migrating the project file (`project.json`) itself to the CLI tooling.\n3. Migrating off of any DNX APIs to their BCL counterparts. \n\n### Changing the global.json file\nThe `global.json` file acts like a solution file for both the RC1 and RC2 (or later) projects. In order for the CLI tools (as well \nas Visual Studio) to differentiate between RC1 and later versions, they use the `\"sdk\": { \"version\" }` property to make the distinction\nwhich project is RC1 or later. If `global.json` doesn't have this node at all, it is assumed to be the latest. \n\nIn order to update the `global.json` file, either remove the property or set it to the exact version of the \ntools that you wish to use, in this case **1.0.0-preview2-003121**:\n\n```json\n{\n    \"sdk\": {\n        \"version\": \"1.0.0-preview2-003121\"\n    }\n}\n```\n\n### Migrating the project file\nThe CLI and DNX both use the same basic project system based on `project.json` file. The syntax and the semantics of the \nproject file are pretty much the same, with small differences based on the scenarios. There are also some changes to \nthe schema which you can see in the [schema file](http://json.schemastore.org/project) or in a more friendly \n[project.json reference](tools/project-json.md). \n\nIf you are building a console application, you need to add the following snippet to your project file:\n\n```json\n\"buildOptions\": {\n    \"emitEntryPoint\": true\n}\n```\n\nThis instructs `dotnet build` to emit an entry point for your application, effectively making your code runnable. If \nyou are building a class library, simply omit the above section. Of course, once you add the above snippet to your \n`project.json` file, you need to add a static entry point. With the move off DNX, the DI services it provided are no \nlonger available and thus this needs to be a basic .NET entry point: `static void Main()`.\n\nIf you have a \"commands\" section in your `project.json`, you can remove it. Some of the commands that used to exist as \nDNU commands, such as Entity Framework CLI commands, are being ported to be \nper-project extensions to the CLI. If you built your own commands that you are using in your projects, you need to \nreplace them with CLI extensions. In this case, the `commands` node in `project.json` needs to be replaced by the \n`tools` node and it needs to list the tools dependencies as explained in the \n[CLI extensibility section](tools/index.md#extensibility). \n\nAfter these things are done, you need to decide which type of portability you wish for you app. With .NET Core, we have \ninvested into providing a spectrum of portability options that you can choose from. For instance, you may want to have \na fully *portable* application or you may want to have a *self-contained* application. The portable application option is more \nlike .NET Framework applications work: it needs a shared component to execute it on the target machine \n(.NET Core). The self-contained application doesn't require .NET Core to be installed on the target, but you have to \nproduce one application for each OS you wish to support. These portability types and more are discussed in the\n [application portability type](app-types.md) document. \n\nOnce you make a call on what type of portability you want, you need to change your targeted framework(s). If you were \nwriting applications for .NET Core, you were most likely using `dnxcore50` as  your targeted framework. With the CLI \nand the changes that the new [.NET Standard Library](https://github.com/dotnet/corefx/blob/master/Documentation/architecture/net-platform-standard.md) \nbrought, the framework needs to be one of the following:\n\n1. `netcoreapp1.0` - if you are writing applications on .NET Core (including ASP.NET Core applications)\n2. `netstandard1.5` - if you are writing class libraries for .NET Core\n\nIf you are using other `dnx` targets, like `dnx451` you will need to change those as well. `dnx451` should be changed to `net451`. \nPlease refer to the [.NET Standard Library document](https://github.com/dotnet/corefx/blob/master/Documentation/architecture/net-platform-standard.md) \nfor more information. \n\nYour `project.json` is now mostly ready. You need to go through your dependencies list and update the dependencies to \ntheir newer versions, especially if you are using ASP.NET Core dependencies. If you were using separate packages for BCL APIs, \nyou can use the runtime package as explained in the [application portability type](app-types.md) document. \n\nOnce you are ready, you can try restoring with `dotnet restore`. Depending on the version of your dependencies, you \nmay encounter errors if NuGet cannot resolve the dependencies for one of the \ntargeted frameworks above. This is a \"point-in-time\" problem; as time progresses, more and more packages will include \nsupport for these frameworks. For now, if you run into this, you can use the `imports` statement within the `framework` \nnode to specify to NuGet that it can restore the packages targeting the framework within the \"imports\" statement. \nThe restoring errors you get in this case should provide enough information to tell you which frameworks you need to \nimport. If you are slightly lost or new to this, in general, specifying `dnxcore50` and `portable-net45+win8` in the \n`imports` statement should do the trick. The JSON snippet below shows how this looks like:\n\n```json\n    \"frameworks\": {\n        \"netcoreapp1.0\": { \n            \"imports\": [\"dnxcore50\", \"portable-net45+win8\"]\n        }\n    }\n```\n\nRunning `dotnet build` will show any eventual build errors, though there shouldn't be too many of them. After your code is \nbuilding and running properly, you can test it out with the runner. Execute `dotnet <path-to-your-assembly>` and see it run.\n\n\n"}