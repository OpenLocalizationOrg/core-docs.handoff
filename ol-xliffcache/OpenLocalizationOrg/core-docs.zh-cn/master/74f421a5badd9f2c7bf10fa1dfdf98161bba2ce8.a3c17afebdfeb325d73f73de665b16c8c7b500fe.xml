{"nodes":[{"pos":[11,47],"content":"When to Use a Thread-Safe Collection","needQuote":true,"nodes":[{"content":"When to Use a Thread-Safe Collection","pos":[0,36]}]},{"pos":[61,97],"content":"When to Use a Thread-Safe Collection","needQuote":true,"nodes":[{"content":"When to Use a Thread-Safe Collection","pos":[0,36]}]},{"pos":[108,123],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":"When to Use a Thread-Safe Collection","pos":[327,363]},{"content":"The <ph id=\"ph1\">`ConcurrentQueue`</ph>, <ph id=\"ph2\">`ConcurrentStack`</ph>, <ph id=\"ph3\">`ConcurrentDictionary`</ph>, <ph id=\"ph4\">`ConcurrentBag`</ph>, and <ph id=\"ph5\">`BlockingCollection`</ph> collection types are specially designed to support multi-threaded add and remove operations.","pos":[365,565],"source":"The `ConcurrentQueue`, `ConcurrentStack`, `ConcurrentDictionary`, `ConcurrentBag`, and `BlockingCollection` collection types are specially designed to support multi-threaded add and remove operations."},{"content":"To achieve thread-safety, these new types use various kinds of efficient locking and lock-free synchronization mechanisms.","pos":[566,688]},{"content":"Synchronization adds overhead to an operation.","pos":[689,735]},{"content":"The amount of overhead depends on the kind of synchronization that is used, the kind of operations that are performed, and other factors such as the number of threads that are trying to concurrently access the collection.","pos":[736,957]},{"content":"In some scenarios, synchronization overhead is negligible and enables the multi-threaded type to perform significantly faster and scale far better than its non-thread-safe equivalent when protected by an external lock.","pos":[959,1177]},{"content":"In other scenarios, the overhead can cause the thread-safe type to perform and scale about the same or even more slowly than the externally-locked, non-thread-safe version of the type.","pos":[1178,1362]},{"content":"The following sections provide general guidance about when to use a thread-safe collection versus its non-thread-safe equivalent that has a user-provided lock around its read and write operations.","pos":[1364,1560]},{"content":"Because performance may vary depending on many factors, the guidance is not specific and is not necessarily valid in all circumstances.","pos":[1561,1696]},{"content":"If performance is very important, then the best way to determine which collection type to use is to measure performance based on representative computer configurations and loads.","pos":[1697,1875]},{"content":"This document uses the following terms:","pos":[1876,1915]},{"pos":[1917,2021],"content":"<bpt id=\"p1\">*</bpt>Pure producer-consumer scenario:<ept id=\"p1\">*</ept> Any given thread is either adding or removing elements, but not both.","source":"*Pure producer-consumer scenario:* Any given thread is either adding or removing elements, but not both."},{"pos":[2023,2113],"content":"<bpt id=\"p1\">*</bpt>Mixed producer-consumer scenario:<ept id=\"p1\">*</ept> Any given thread is both adding and removing elements.","source":"*Mixed producer-consumer scenario:* Any given thread is both adding and removing elements."},{"pos":[2115,2203],"content":"<bpt id=\"p1\">*</bpt>Speedup:<ept id=\"p1\">*</ept> Faster algorithmic performance relative to another type in the same scenario.","source":"*Speedup:* Faster algorithmic performance relative to another type in the same scenario."},{"content":"<bpt id=\"p1\">*</bpt>Scalability:<ept id=\"p1\">*</ept> The increase in performance that is proportional to the number of cores on the computer.","pos":[2205,2308],"source":"*Scalability:* The increase in performance that is proportional to the number of cores on the computer."},{"content":"An algorithm that scales performs faster on eight cores than it does on two cores.","pos":[2309,2391]},{"content":"ConcurrentQueue<ph id=\"ph1\">&amp;lt;</ph>T<ph id=\"ph2\">&amp;gt;</ph> vs. Queue<ph id=\"ph3\">&amp;lt;</ph>T","pos":[2396,2435],"source":"ConcurrentQueue&lt;T&gt; vs. Queue&lt;T"},{"content":"In pure producer-consumer scenarios, where the processing time for each element is very small (a few instructions), then <bpt id=\"p1\">[</bpt>System.Collections.Concurrent.ConcurrentQueue<ph id=\"ph1\">&amp;lt;</ph>T<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1)</ept> can offer modest performance benefits over a <bpt id=\"p2\">[</bpt>System.Collections.Generic.Queue<ph id=\"ph3\">&amp;lt;</ph>T<ph id=\"ph4\">&amp;gt;</ph><ept id=\"p2\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Queue-1)</ept> that has an external lock.","pos":[2441,2905],"source":"In pure producer-consumer scenarios, where the processing time for each element is very small (a few instructions), then [System.Collections.Concurrent.ConcurrentQueue&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1) can offer modest performance benefits over a [System.Collections.Generic.Queue&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Queue-1) that has an external lock."},{"content":"In this scenario, <ph id=\"ph1\">`ConcurrentQueue&lt;T&gt;`</ph> performs best when one dedicated thread is queuing and one dedicated thread is de-queuing.","pos":[2906,3035],"source":" In this scenario, `ConcurrentQueue<T>` performs best when one dedicated thread is queuing and one dedicated thread is de-queuing."},{"content":"If you do not enforce this rule, then <ph id=\"ph1\">`Queue&lt;T&gt;`</ph> might even perform slightly faster than <ph id=\"ph2\">`ConcurrentQueue&lt;T&gt;`</ph> on computers that have multiple cores.","pos":[3036,3184],"source":" If you do not enforce this rule, then `Queue<T>` might even perform slightly faster than `ConcurrentQueue<T>` on computers that have multiple cores."},{"content":"When processing time is around 500 FLOPS (floating point operations) or more, then the two-thread rule does not apply to <ph id=\"ph1\">`ConcurrentQueue&lt;T&gt;`</ph>, which then has very good scalability.","pos":[3187,3367],"source":"When processing time is around 500 FLOPS (floating point operations) or more, then the two-thread rule does not apply to `ConcurrentQueue<T>`, which then has very good scalability."},{"content":"does not scale well in this scenario.","pos":[3379,3416]},{"content":"In mixed producer-consumer scenarios, when the processing time is very small, a <ph id=\"ph1\">`Queue&lt;T&gt;`</ph> that has an external lock scales better than <ph id=\"ph2\">`ConcurrentQueue&lt;T&gt;`</ph> does.","pos":[3418,3580],"source":"In mixed producer-consumer scenarios, when the processing time is very small, a `Queue<T>` that has an external lock scales better than `ConcurrentQueue<T>` does."},{"content":"However, when processing time is around 500 FLOPS or more, then the <ph id=\"ph1\">`ConcurrentQueue&lt;T&gt;`</ph> scales better.","pos":[3581,3684],"source":" However, when processing time is around 500 FLOPS or more, then the `ConcurrentQueue<T>` scales better."},{"content":"ConcurrentStack vs. Stack","pos":[3689,3714]},{"content":"In pure producer-consumer scenarios, when processing time is very small, then <bpt id=\"p1\">[</bpt>System.Collections.Concurrent.ConcurrentStack<ph id=\"ph1\">&amp;lt;</ph>T<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1)</ept> and <bpt id=\"p2\">[</bpt>System.Collections.Generic.Stack<ph id=\"ph3\">&amp;lt;</ph>T<ph id=\"ph4\">&amp;gt;</ph><ept id=\"p2\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Stack-1)</ept> that has an external lock will probably perform about the same with one dedicated pushing thread and one dedicated popping thread.","pos":[3716,4200],"source":"In pure producer-consumer scenarios, when processing time is very small, then [System.Collections.Concurrent.ConcurrentStack&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1) and [System.Collections.Generic.Stack&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Stack-1) that has an external lock will probably perform about the same with one dedicated pushing thread and one dedicated popping thread."},{"content":"However, as the number of threads increases, both types slow down because of increased contention, and <ph id=\"ph1\">`Stack&lt;T&gt;`</ph> might perform better than <ph id=\"ph2\">`ConcurrentStack&lt;T&gt;`</ph>.","pos":[4201,4362],"source":" However, as the number of threads increases, both types slow down because of increased contention, and `Stack<T>` might perform better than `ConcurrentStack<T>`."},{"content":"When processing time is around 500 FLOPS or more, then both types scale at about the same rate.","pos":[4363,4458]},{"pos":[4461,4565],"content":"In mixed producer-consumer scenarios, <ph id=\"ph1\">`ConcurrentStack&lt;T&gt;`</ph> is faster for both small and large workloads.","source":"In mixed producer-consumer scenarios, `ConcurrentStack<T>` is faster for both small and large workloads."},{"pos":[4567,4646],"content":"The use of the <ph id=\"ph1\">`PushRange`</ph> and <ph id=\"ph2\">`TryPopRange`</ph> may greatly speed up access times.","source":"The use of the `PushRange` and `TryPopRange` may greatly speed up access times."},{"content":"ConcurrentDictionary vs. Dictionary","pos":[4651,4686]},{"content":"In general, use a <bpt id=\"p1\">[</bpt>System.Collections.Concurrent.ConcurrentDictionary<ph id=\"ph1\">&amp;lt;</ph>TKey, TValue<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentDictionary-2)</ept> in any scenario where you are adding and updating keys or values concurrently from multiple threads.","pos":[4688,4976],"source":"In general, use a [System.Collections.Concurrent.ConcurrentDictionary&lt;TKey, TValue&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentDictionary-2) in any scenario where you are adding and updating keys or values concurrently from multiple threads."},{"content":"In scenarios that involve frequent updates and relatively few reads, the <ph id=\"ph1\">`ConcurrentDictionary&lt;TKey, TValue&gt;`</ph> generally offers modest benefits.","pos":[4977,5120],"source":" In scenarios that involve frequent updates and relatively few reads, the `ConcurrentDictionary<TKey, TValue>` generally offers modest benefits."},{"content":"In scenarios that involve many reads and many updates, the <ph id=\"ph1\">`ConcurrentDictionary&lt;TKey, TValue&gt;`</ph> generally is significantly faster on computers that have any number of cores.","pos":[5121,5294],"source":" In scenarios that involve many reads and many updates, the `ConcurrentDictionary<TKey, TValue>` generally is significantly faster on computers that have any number of cores."},{"content":"In scenarios that involve frequent updates, you can increase the degree of concurrency in the <ph id=\"ph1\">`ConcurrentDictionary&lt;TKey, TValue&gt;`</ph> and then measure to see whether performance increases on computers that have more cores.","pos":[5296,5515],"source":"In scenarios that involve frequent updates, you can increase the degree of concurrency in the `ConcurrentDictionary<TKey, TValue>` and then measure to see whether performance increases on computers that have more cores."},{"content":"If you change the concurrency level, avoid global operations as much as possible.","pos":[5516,5597]},{"pos":[5599,5890],"content":"If you are only reading key or values, the <bpt id=\"p1\">[</bpt>System.Collections.Generic.Dictionary<ph id=\"ph1\">&amp;lt;</ph>TKey, TValue<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Dictionary-2)</ept> is faster because no synchronization is required if the dictionary is not being modified by any threads.","source":"If you are only reading key or values, the [System.Collections.Generic.Dictionary&lt;TKey, TValue&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Dictionary-2) is faster because no synchronization is required if the dictionary is not being modified by any threads."},{"content":"ConcurrentBag","pos":[5895,5908]},{"pos":[5910,6169],"content":"In pure producer-consumer scenarios, <bpt id=\"p1\">[</bpt>System.Collections.Concurrent.ConcurrentBag<ph id=\"ph1\">&amp;lt;</ph>T<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1)</ept> will probably perform more slowly than the other concurrent collection types.","source":"In pure producer-consumer scenarios, [System.Collections.Concurrent.ConcurrentBag&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1) will probably perform more slowly than the other concurrent collection types."},{"pos":[6171,6348],"content":"In mixed producer-consumer scenarios, <ph id=\"ph1\">`ConcurrentBag&lt;T&gt;`</ph> is generally much faster and more scalable than any other concurrent collection type for both large and small workloads.","source":"In mixed producer-consumer scenarios, `ConcurrentBag<T>` is generally much faster and more scalable than any other concurrent collection type for both large and small workloads."},{"content":"BlockingCollection","pos":[6353,6371]},{"content":"When bounding and blocking semantics are required, <bpt id=\"p1\">[</bpt>System.Collections.Concurrent.BlockingCollection<ph id=\"ph1\">&amp;lt;</ph>T<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1)</ept> will probably perform faster than any custom implementation.","pos":[6373,6639],"source":"When bounding and blocking semantics are required, [System.Collections.Concurrent.BlockingCollection&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1) will probably perform faster than any custom implementation."},{"content":"It also supports rich cancellation, enumeration, and exception handling.","pos":[6640,6712]},{"content":"See Also","pos":[6717,6725]},{"content":"System.Collections.Concurrent","pos":[6728,6757]},{"content":"Thread-Safe Collections","pos":[6835,6858]}],"content":"---\ntitle: When to Use a Thread-Safe Collection\ndescription: When to Use a Thread-Safe Collection\nkeywords: .NET, .NET Core\nauthor: mairaw\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: a2a42d44-f6a5-4f16-9000-026221d66349\n---\n\n# When to Use a Thread-Safe Collection\n\nThe `ConcurrentQueue`, `ConcurrentStack`, `ConcurrentDictionary`, `ConcurrentBag`, and `BlockingCollection` collection types are specially designed to support multi-threaded add and remove operations. To achieve thread-safety, these new types use various kinds of efficient locking and lock-free synchronization mechanisms. Synchronization adds overhead to an operation. The amount of overhead depends on the kind of synchronization that is used, the kind of operations that are performed, and other factors such as the number of threads that are trying to concurrently access the collection.\n\nIn some scenarios, synchronization overhead is negligible and enables the multi-threaded type to perform significantly faster and scale far better than its non-thread-safe equivalent when protected by an external lock. In other scenarios, the overhead can cause the thread-safe type to perform and scale about the same or even more slowly than the externally-locked, non-thread-safe version of the type.\n\nThe following sections provide general guidance about when to use a thread-safe collection versus its non-thread-safe equivalent that has a user-provided lock around its read and write operations. Because performance may vary depending on many factors, the guidance is not specific and is not necessarily valid in all circumstances. If performance is very important, then the best way to determine which collection type to use is to measure performance based on representative computer configurations and loads. This document uses the following terms:\n\n*Pure producer-consumer scenario:* Any given thread is either adding or removing elements, but not both.\n\n*Mixed producer-consumer scenario:* Any given thread is both adding and removing elements.\n\n*Speedup:* Faster algorithmic performance relative to another type in the same scenario.\n\n*Scalability:* The increase in performance that is proportional to the number of cores on the computer. An algorithm that scales performs faster on eight cores than it does on two cores.\n\n## ConcurrentQueue&lt;T&gt; vs. Queue&lt;T&gt;\n\nIn pure producer-consumer scenarios, where the processing time for each element is very small (a few instructions), then [System.Collections.Concurrent.ConcurrentQueue&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1) can offer modest performance benefits over a [System.Collections.Generic.Queue&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Queue-1) that has an external lock. In this scenario, `ConcurrentQueue<T>` performs best when one dedicated thread is queuing and one dedicated thread is de-queuing. If you do not enforce this rule, then `Queue<T>` might even perform slightly faster than `ConcurrentQueue<T>` on computers that have multiple cores. \n\nWhen processing time is around 500 FLOPS (floating point operations) or more, then the two-thread rule does not apply to `ConcurrentQueue<T>`, which then has very good scalability. `Queue<T>` does not scale well in this scenario.\n\nIn mixed producer-consumer scenarios, when the processing time is very small, a `Queue<T>` that has an external lock scales better than `ConcurrentQueue<T>` does. However, when processing time is around 500 FLOPS or more, then the `ConcurrentQueue<T>` scales better.\n\n## ConcurrentStack vs. Stack\n\nIn pure producer-consumer scenarios, when processing time is very small, then [System.Collections.Concurrent.ConcurrentStack&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1) and [System.Collections.Generic.Stack&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Stack-1) that has an external lock will probably perform about the same with one dedicated pushing thread and one dedicated popping thread. However, as the number of threads increases, both types slow down because of increased contention, and `Stack<T>` might perform better than `ConcurrentStack<T>`. When processing time is around 500 FLOPS or more, then both types scale at about the same rate. \n\nIn mixed producer-consumer scenarios, `ConcurrentStack<T>` is faster for both small and large workloads.\n\nThe use of the `PushRange` and `TryPopRange` may greatly speed up access times.\n\n## ConcurrentDictionary vs. Dictionary\n\nIn general, use a [System.Collections.Concurrent.ConcurrentDictionary&lt;TKey, TValue&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentDictionary-2) in any scenario where you are adding and updating keys or values concurrently from multiple threads. In scenarios that involve frequent updates and relatively few reads, the `ConcurrentDictionary<TKey, TValue>` generally offers modest benefits. In scenarios that involve many reads and many updates, the `ConcurrentDictionary<TKey, TValue>` generally is significantly faster on computers that have any number of cores.\n\nIn scenarios that involve frequent updates, you can increase the degree of concurrency in the `ConcurrentDictionary<TKey, TValue>` and then measure to see whether performance increases on computers that have more cores. If you change the concurrency level, avoid global operations as much as possible.\n\nIf you are only reading key or values, the [System.Collections.Generic.Dictionary&lt;TKey, TValue&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Dictionary-2) is faster because no synchronization is required if the dictionary is not being modified by any threads.\n\n## ConcurrentBag\n\nIn pure producer-consumer scenarios, [System.Collections.Concurrent.ConcurrentBag&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1) will probably perform more slowly than the other concurrent collection types.\n\nIn mixed producer-consumer scenarios, `ConcurrentBag<T>` is generally much faster and more scalable than any other concurrent collection type for both large and small workloads.\n\n## BlockingCollection\n\nWhen bounding and blocking semantics are required, [System.Collections.Concurrent.BlockingCollection&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1) will probably perform faster than any custom implementation. It also supports rich cancellation, enumeration, and exception handling.\n\n## See Also\n\n[System.Collections.Concurrent](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)\n\n[Thread-Safe Collections](index.md)\n"}