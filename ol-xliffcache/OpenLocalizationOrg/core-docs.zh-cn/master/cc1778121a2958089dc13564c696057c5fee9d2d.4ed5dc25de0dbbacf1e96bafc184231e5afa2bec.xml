{"nodes":[{"pos":[11,43],"content":".NET Core Application Deployment","needQuote":true,"nodes":[{"content":".NET Core Application Deployment","pos":[0,32]}]},{"pos":[58,90],"content":".NET Core Application Deployment","needQuote":true,"nodes":[{"content":".NET Core Application Deployment","pos":[0,32]}]},{"pos":[102,139],"content":".NET, .NET Core, .NET Core deployment","needQuote":true,"nodes":[{"content":".NET, .NET Core, .NET Core deployment","pos":[0,37]}]},{"content":".NET Core Application Deployment","pos":[346,378]},{"content":"You can deploy your .NET Core app in either of two ways:","pos":[382,438]},{"content":"As a portable app.","pos":[442,460]},{"content":"A portable app relies on a shared system-wide version of .NET Core to be present on the target system.","pos":[461,563]},{"content":"Because .NET Core is already present, your app is portable between installations of .NET Core.","pos":[564,658]},{"content":"Your app contains only its own code and any third-party dependencies that are outside of the .NET Core libraries.","pos":[659,772]},{"content":"Portable applications are .dll files that can be launched by using the <bpt id=\"p1\">[</bpt>dotnet utility<ept id=\"p1\">](../tools/dotnet.md)</ept> from the command line.","pos":[773,903],"source":" Portable applications are .dll files that can be launched by using the [dotnet utility](../tools/dotnet.md) from the command line."},{"content":"For example, <ph id=\"ph1\">`dotnet app.dll`</ph> runs a portable application named <ph id=\"ph2\">`app`</ph>.","pos":[904,974],"source":" For example, `dotnet app.dll` runs a portable application named `app`."},{"content":"As a self-contained application.","pos":[978,1010]},{"content":"Unlike a portable app, a self-contained app does not rely on any shared components to be present on the target system.","pos":[1011,1129]},{"content":"All components, including both .NET Core libraries and the .NET Core runtime, are included with the application and are isolated from other .NET Core applications.","pos":[1130,1293]},{"content":"Self-contained applications include an executable (such as <ph id=\"ph1\">`app.exe`</ph> on Windows platforms for a self-contained application named <ph id=\"ph2\">`app`</ph>), which is  a renamed version of the platform-specific .NET Core host, and a .dll file (such as <ph id=\"ph3\">`app.dll`</ph>), which is the actual application.","pos":[1294,1569],"source":" Self-contained applications include an executable (such as `app.exe` on Windows platforms for a self-contained application named `app`), which is  a renamed version of the platform-specific .NET Core host, and a .dll file (such as `app.dll`), which is the actual application."},{"pos":[1571,1667],"content":"For more information on .NET Core application types, see <bpt id=\"p1\">[</bpt>.NET Core App Types<ept id=\"p1\">](../app-types.md)</ept>.","source":"For more information on .NET Core application types, see [.NET Core App Types](../app-types.md)."},{"content":"Portable applications","pos":[1672,1693]},{"content":"For a portable app, you deploy only your app and any third-party dependencies.","pos":[1698,1776]},{"content":"You do not have to deploy .NET Core, since your app will use the version of .NET Core that's present on the target system.","pos":[1777,1899]},{"content":"This is the default deployment model for .NET Core apps.","pos":[1900,1956]},{"content":"Why deploy a portable app?","pos":[1962,1988]},{"content":"Deploying a portable app has a number of advantages:","pos":[1994,2046]},{"content":"You do not have to define the target operating systems that your .NET Core app will run on in advance.","pos":[2050,2152]},{"content":"Because .NET Core uses a common PE file format for executables and libraries regardless of operating system, .NET Core can execute your app regardless of the underlying operating system.","pos":[2153,2339]},{"content":"For more information on the PE file format, see <bpt id=\"p1\">[</bpt>.NET Assembly File Format<ept id=\"p1\">](../../standard/assembly-format.md)</ept>.","pos":[2340,2451],"source":" For more information on the PE file format, see [.NET Assembly File Format](../../standard/assembly-format.md)."},{"content":"The size of your deployment package is small.","pos":[2455,2500]},{"content":"You only have to deploy your app and its dependencies, not .NET Core itself.","pos":[2501,2577]},{"content":"Multiple apps use the same .NET Core installation, which reduces both disk space and memory usage on host systems.","pos":[2581,2695]},{"content":"There are also a few disadvantages:","pos":[2697,2732]},{"content":"Your app can run only if the version of .NET Core that you target, or a later version, is already installed on the host system.","pos":[2736,2863]},{"content":"It is possible for the .NET Core runtime and libraries to change without your knowledge in future releases.","pos":[2867,2974]},{"content":"In rare cases, this may change the behavior of your app.","pos":[2975,3031]},{"content":"Deploying a simple portable app","pos":[3037,3068]},{"content":"Deploying a portable app with no third-party dependencies simply involves building, testing, and publishing the app.","pos":[3074,3190]},{"content":"A simple example written in C# illustrates the process.","pos":[3191,3246]},{"content":"The example uses the <bpt id=\"p1\">[</bpt>dotnet utility<ept id=\"p1\">](../tools/dotnet.md)</ept> from the command line; however, you can also use a development environment, such as Visual Studio or Visual Studio Code, to compile, test, and publish the example.","pos":[3247,3468],"source":" The example uses the [dotnet utility](../tools/dotnet.md) from the command line; however, you can also use a development environment, such as Visual Studio or Visual Studio Code, to compile, test, and publish the example."},{"pos":[3473,3614],"content":"Create a directory for your project, and from the command line, type <bpt id=\"p1\">[</bpt>dotnet new<ept id=\"p1\">](../tools/dotnet-new.md)</ept> to create a new C# console project.","source":"Create a directory for your project, and from the command line, type [dotnet new](../tools/dotnet-new.md) to create a new C# console project."},{"content":"Open the <ph id=\"ph1\">`Program.cs`</ph> file in an editor, and replace the auto-generated code with the following code.","pos":[3619,3720],"source":"Open the `Program.cs` file in an editor, and replace the auto-generated code with the following code."},{"content":"It prompts the user to enter text, and then displays the individual words entered by the user.","pos":[3721,3815]},{"content":"It uses the regular expression <ph id=\"ph1\">`\\w+`</ph> to separate the words in the input text.","pos":[3816,3893],"source":" It uses the regular expression `\\w+` to separate the words in the input text."},{"pos":[5065,5180],"content":"Run the <bpt id=\"p1\">[</bpt>dotnet restore<ept id=\"p1\">](../tools/dotnet-restore.md)</ept> command to restore the dependencies specified in your project.","source":"Run the [dotnet restore](../tools/dotnet-restore.md) command to restore the dependencies specified in your project."},{"pos":[5185,5280],"content":"Create a debug build of your app by using the <bpt id=\"p1\">[</bpt>dotnet build<ept id=\"p1\">](../tools/dotnet-build.md)</ept> command.","source":"Create a debug build of your app by using the [dotnet build](../tools/dotnet-build.md) command."},{"content":"After you've debugged and tested the program, you can create the files to be deployed with your app by using the <ph id=\"ph1\">`dotnet publish -f netcoreapp1.0 -c release`</ph> command.","pos":[5285,5451],"source":"After you've debugged and tested the program, you can create the files to be deployed with your app by using the `dotnet publish -f netcoreapp1.0 -c release` command."},{"content":"This creates a release (rather than a debug) version of your app.","pos":[5452,5517]},{"pos":[5522,5671],"content":"The resulting files are placed in a directory named <ph id=\"ph1\">`publish`</ph> that is in a subdirectory of your project's <ph id=\"ph2\">`.\\bin\\release\\netcoreapp1.0`</ph> subdirectory.","source":"The resulting files are placed in a directory named `publish` that is in a subdirectory of your project's `.\\bin\\release\\netcoreapp1.0` subdirectory."},{"content":"Along with your application's files, the publishing process emits a program database (.pdb) file that contains debugging information about your app.","pos":[5676,5824]},{"content":"The file is useful primarily for debugging exceptions; you can choose not to package it with your application's files.","pos":[5825,5943]},{"content":"The complete set of application  files can be deployed in any way you'd like.","pos":[5945,6022]},{"content":"For example, you can package them in a zip file, use a simple <ph id=\"ph1\">`copy`</ph> command, or deploy them with any installation package of your choice.","pos":[6023,6161],"source":" For example, you can package them in a zip file, use a simple `copy` command, or deploy them with any installation package of your choice."},{"content":"Before deploying your app, you can also use <ph id=\"ph1\">`crossgen`</ph> to convert it to native code.","pos":[6163,6247],"source":"Before deploying your app, you can also use `crossgen` to convert it to native code."},{"content":"However, its performance impact is smaller than for self-contained apps.","pos":[6248,6320]},{"content":"For more information, see the <bpt id=\"p1\">[</bpt>Native Image Generation<ept id=\"p1\">](#crossgen)</ept> section.","pos":[6321,6396],"source":" For more information, see the [Native Image Generation](#crossgen) section."},{"content":"In addition to the application binaries, the installer should also either bundle the shared framework installer or check for it as a prerequisite as part of the application installation.","pos":[6398,6584]},{"content":"Installation of the shared framework requires Administrator/root access since it is machine-wide.","pos":[6586,6683]},{"content":"Deploying a portable app with third-party dependencies","pos":[6689,6743]},{"pos":[6749,6896],"content":"Deploying a portable app with one or more third-party dependencies involves three additional steps before you can run the <ph id=\"ph1\">`dotnet restore`</ph> command:","source":"Deploying a portable app with one or more third-party dependencies involves three additional steps before you can run the `dotnet restore` command:"},{"content":"Add references to any third-party libraries to the <ph id=\"ph1\">`dependencies`</ph> section of your <ph id=\"ph2\">`project.json`</ph> file.","pos":[6901,7003],"source":"Add references to any third-party libraries to the `dependencies` section of your `project.json` file."},{"content":"The following  <ph id=\"ph1\">`dependencies`</ph> section uses Json.NET as a third-party library.","pos":[7004,7081],"source":" The following  `dependencies` section uses Json.NET as a third-party library."},{"content":"If you haven't already, download the NuGet package containing the third-party dependency.","pos":[7266,7355]},{"content":"To download the package, execute the <ph id=\"ph1\">`dotnet restore`</ph> command after adding the dependency.","pos":[7356,7446],"source":" To download the package, execute the `dotnet restore` command after adding the dependency."},{"content":"Because the dependency is resolved out of the local NuGet cache at publish time, it must be available on your system.","pos":[7447,7564]},{"content":"Note that a portable app with third-party dependencies will only be as portable as its third-party dependencies.","pos":[7566,7678]},{"content":"For example, if a third-party library only supports macOS, the app will not be portable to Windows systems.","pos":[7679,7786]},{"content":"When you deploy your application, any third-party dependencies used in your app are resolved from the local NuGet cache of the system on which your app is running.","pos":[7788,7951]},{"content":"In other words, the third-party library must be present on the target machine for your app to run successfully.","pos":[7952,8063]},{"content":"Self-contained applications","pos":[8068,8095]},{"content":"For a self-contained app, you deploy not only your app and any third-party dependencies, but the version of .NET Core that you build your app with.","pos":[8100,8247]},{"content":"Why deploy a self-contained app?","pos":[8253,8285]},{"content":"Deploying a self-contained app has two major advantages:","pos":[8291,8347]},{"content":"You have sole control of the version of .NET Core that is deployed with your app.","pos":[8351,8432]},{"content":".NET Core can be serviced only by you.","pos":[8433,8471]},{"content":"You can be assured that the target system can run your .NET Core app, since you're providing the version of .NET Core that it will run on.","pos":[8475,8613]},{"content":"It also has a number of disadvantages:","pos":[8615,8653]},{"content":"Because .NET Core is included in your deployment package, you must select the target platforms for which you build deployment packages in advance.","pos":[8657,8803]},{"content":"The size of your deployment package is relatively large, since you have to include .NET Core as well as your app and its third-party dependencies.","pos":[8807,8953]},{"content":"Deploying numerous self-contained .NET Core apps to a system can consume significant amounts of disk space, since each app duplicates .NET Core files.","pos":[8957,9107]},{"pos":[9139,9176],"content":"Deploying a simple self-contained app"},{"content":"Deploying a self-contained app with no third-party dependencies involves creating the project, modifying the project.json file, building, testing, and publishing the app.","pos":[9182,9352]},{"content":"A simple example written in C# illustrates the process.","pos":[9354,9409]},{"content":"The example uses the <ph id=\"ph1\">`dotnet`</ph> utility from the command line; however, you can also use a development environment, such as Visual Studio or Visual Studio Code, to compile, test, and publish the example.","pos":[9410,9611],"source":" The example uses the `dotnet` utility from the command line; however, you can also use a development environment, such as Visual Studio or Visual Studio Code, to compile, test, and publish the example."},{"pos":[9616,9733],"content":"Create a directory for your project, and from the command line, type <ph id=\"ph1\">`dotnet new`</ph> to create a new C# console project.","source":"Create a directory for your project, and from the command line, type `dotnet new` to create a new C# console project."},{"content":"Open the <ph id=\"ph1\">`Program.cs`</ph> file in an editor, and replace the auto-generated code with the following code.","pos":[9738,9839],"source":"Open the `Program.cs` file in an editor, and replace the auto-generated code with the following code."},{"content":"It prompts the user to enter text, and then displays the individual words entered by the user.","pos":[9840,9934]},{"content":"It uses the regular expression <ph id=\"ph1\">`\\w+`</ph> to separate the words in the input text.","pos":[9935,10012],"source":" It uses the regular expression `\\w+` to separate the words in the input text."},{"pos":[11170,11258],"content":"Open the <ph id=\"ph1\">`project.json`</ph> file and in the <ph id=\"ph2\">`frameworks`</ph> section, remove the following line:","source":"Open the `project.json` file and in the `frameworks` section, remove the following line:"},{"content":"The Framework section should appear as follows after you've modified it:","pos":[11301,11373]},{"pos":[11571,11743],"content":"Removing the <ph id=\"ph1\">`\"type\": \"platform\"`</ph> attribute indicates that the framework is provided as a set of components local to our app, rather than as a system-wide platform package.","source":"Removing the `\"type\": \"platform\"` attribute indicates that the framework is provided as a set of components local to our app, rather than as a system-wide platform package."},{"content":"Create a <ph id=\"ph1\">`runtimes`</ph> section in your <ph id=\"ph2\">`project.json`</ph> file that defines the platforms your app targets, and specify the runtime identifier of each platform that you target.","pos":[11748,11917],"source":"Create a `runtimes` section in your `project.json` file that defines the platforms your app targets, and specify the runtime identifier of each platform that you target."},{"content":"See <bpt id=\"p1\">[</bpt>Runtime IDentifier catalog<ept id=\"p1\">](../rid-catalog.md)</ept> for a list of runtime identifiers.","pos":[11918,12004],"source":" See [Runtime IDentifier catalog](../rid-catalog.md) for a list of runtime identifiers."},{"content":"For example, the following <ph id=\"ph1\">`runtimes`</ph> section indicates that the app runs on 64-bit Windows 10 operating systems and the 64-bit OS X Version 10.10 operating system.","pos":[12005,12169],"source":" For example, the following `runtimes` section indicates that the app runs on 64-bit Windows 10 operating systems and the 64-bit OS X Version 10.10 operating system."},{"content":"Note that you also need to add a comma to separate the <ph id=\"ph1\">`runtimes`</ph> section from the previous section.","pos":[12280,12380],"source":"Note that you also need to add a comma to separate the `runtimes` section from the previous section."},{"content":"A complete sample <ph id=\"ph1\">`project.json`</ph> file appears later in this section.","pos":[12381,12449],"source":"\nA complete sample `project.json` file appears later in this section."},{"pos":[12454,12541],"content":"Run the <ph id=\"ph1\">`dotnet restore`</ph> command to restore the dependencies specified in your project.","source":"Run the `dotnet restore` command to restore the dependencies specified in your project."},{"content":"Create debug builds of your app on each of the target platforms by using the <ph id=\"ph1\">`dotnet build`</ph> command.","pos":[12546,12646],"source":"Create debug builds of your app on each of the target platforms by using the `dotnet build` command."},{"content":"Unless you specify the runtime identifier you'd like to build, the <ph id=\"ph1\">`dotnet build`</ph> command creates a build only for the current system's runtime ID.","pos":[12647,12794],"source":" Unless you specify the runtime identifier you'd like to build, the `dotnet build` command creates a build only for the current system's runtime ID."},{"content":"You can build your app for both target platforms with the commands:","pos":[12795,12862]},{"pos":[12951,13091],"content":"The debug builds of your app for each platform will be found in the project's <ph id=\"ph1\">`.\\bin\\Debug\\netcoreapp1.0\\&lt;runtime_identifier&gt;`</ph> subdirectory.","source":"The debug builds of your app for each platform will be found in the project's `.\\bin\\Debug\\netcoreapp1.0\\<runtime_identifier>` subdirectory."},{"pos":[13096,13305],"content":"After you've debugged and tested the program, you can create the files to be deployed with your app for each platform that it targets by using the <ph id=\"ph1\">`dotnet publish`</ph> command for both target platforms as follows:","source":"After you've debugged and tested the program, you can create the files to be deployed with your app for each platform that it targets by using the `dotnet publish` command for both target platforms as follows:"},{"content":"This creates a release (rather than a debug) version of your app for each target platform.","pos":[13416,13506]},{"content":"The resulting files are placed in a subdirectory named <ph id=\"ph1\">`publish`</ph> that is in a subdirectory of your project's <ph id=\"ph2\">`.\\bin\\release\\netcoreapp1.0\\&lt;runtime_identifier&gt;`</ph> subdirectory.","pos":[13507,13680],"source":" The resulting files are placed in a subdirectory named `publish` that is in a subdirectory of your project's `.\\bin\\release\\netcoreapp1.0\\<runtime_identifier>` subdirectory."},{"content":"Note that each subdirectory contains the complete set of files (both your app files and all .NET Core files) needed to launch your app.","pos":[13681,13816]},{"content":"Along with your application's files, the publishing process emits a program database (.pdb) file that contains debugging information about your app.","pos":[13821,13969]},{"content":"The file is useful primarily for debugging exceptions; you can choose not to package it with your application's files.","pos":[13970,14088]},{"content":"The published files can be deployed in any way you'd like.","pos":[14090,14148]},{"content":"For example, you can package them in a zip file, use a simple <ph id=\"ph1\">`copy`</ph> command, or deploy them with any installation package of your choice.","pos":[14149,14287],"source":" For example, you can package them in a zip file, use a simple `copy` command, or deploy them with any installation package of your choice."},{"content":"Before packaging and deploying your app, you can also use <ph id=\"ph1\">`crossgen`</ph> to convert it to native code.","pos":[14288,14386],"source":" Before packaging and deploying your app, you can also use `crossgen` to convert it to native code."},{"content":"For more information, see the <bpt id=\"p1\">[</bpt>Native Image Generation<ept id=\"p1\">](#crossgen)</ept> section.","pos":[14387,14462],"source":" For more information, see the [Native Image Generation](#crossgen) section."},{"pos":[14464,14531],"content":"The following is the complete <ph id=\"ph1\">`project.json`</ph> file for this project.","source":"The following is the complete `project.json` file for this project."},{"content":"Deploying a self-contained app with third-party dependencies","pos":[14904,14964]},{"pos":[14970,15123],"content":"Deploying a self-contained app with one or more third-party dependencies involves three additional steps before you can run the <ph id=\"ph1\">`dotnet restore`</ph> command:","source":"Deploying a self-contained app with one or more third-party dependencies involves three additional steps before you can run the `dotnet restore` command:"},{"content":"Add references to any third-party libraries to the <ph id=\"ph1\">`dependencies`</ph> section of your <ph id=\"ph2\">`project.json`</ph> file.","pos":[15128,15230],"source":"Add references to any third-party libraries to the `dependencies` section of your `project.json` file."},{"content":"The following  <ph id=\"ph1\">`dependencies`</ph> section uses Json.NET as a third-party library.","pos":[15231,15308],"source":" The following  `dependencies` section uses Json.NET as a third-party library."},{"pos":[15436,15575],"content":"Modify the <ph id=\"ph1\">`frameworks`</ph> section as follows to ensure that the <ph id=\"ph2\">`dotnet`</ph> utility will not consider .NET Core and Json.NET to be incompatible:","source":"Modify the `frameworks` section as follows to ensure that the `dotnet` utility will not consider .NET Core and Json.NET to be incompatible:"},{"content":"If you haven't already, download the NuGet package containing the third-party dependency to your system.","pos":[15685,15789]},{"content":"To make the dependency available to your app, execute the <ph id=\"ph1\">`dotnet restore`</ph> command after adding the dependency.","pos":[15790,15901],"source":" To make the dependency available to your app, execute the `dotnet restore` command after adding the dependency."},{"content":"Because the dependency is resolved out of the local NuGet cache at publish time, it must be available on your system.","pos":[15902,16019]},{"content":"The following is the complete project.json file for this project:","pos":[16021,16086]},{"content":"When you deploy your application, any third-party dependencies used in your app are also contained with your application files.","pos":[16450,16577]},{"content":"Third-party libraries do not already have to be present on the system on which the app is running.","pos":[16578,16676]},{"content":"Note that you can only deploy a self-contained app with a third-party library to platforms supported by that library.","pos":[16678,16795]},{"content":"Deploying a self-contained app with a smaller footprint","pos":[16801,16856]},{"content":"If the availability of adequate storage space on target systems is likely to be an issue, you can reduce the overall footprint of your app by excluding some system components.","pos":[16862,17037]},{"content":"To do this, you explicitly define the .NET Core components that your app includes in your project.json file.","pos":[17038,17146]},{"content":"To create a self-contained app with a smaller footprint, start by following the first two steps for creating a self-contained app.","pos":[17148,17278]},{"content":"Once you've run the <ph id=\"ph1\">`dotnet new`</ph> command and added the C# source code to your app, do the following:","pos":[17279,17379],"source":" Once you've run the `dotnet new` command and added the C# source code to your app, do the following:"},{"pos":[17384,17469],"content":"Open the <ph id=\"ph1\">`project.json`</ph> file and replace the <ph id=\"ph2\">`frameworks`</ph> section with the following:","source":"Open the `project.json` file and replace the `frameworks` section with the following:"},{"content":"This does two things:","pos":[17545,17566]},{"pos":[17978,18032],"content":"Replace the <ph id=\"ph1\">`dependencies`</ph> section with the following:","source":"Replace the `dependencies` section with the following:"},{"content":"This defines the system components used by our app.","pos":[18229,18280]},{"content":"The system components packaged with our app include the .NET Standard Library, the .NET Core runtime, and the .NET Core host.","pos":[18281,18406]},{"content":"This produces a self-contained app with a smaller footprint.","pos":[18407,18467]},{"content":"As you did in the <bpt id=\"p1\">[</bpt>Deploying a Simple Self-Contained App<ept id=\"p1\">](#simpleSelf)</ept> example, create a <ph id=\"ph1\">`runtimes`</ph> section in your <ph id=\"ph2\">`project.json`</ph> file that defines the platforms your app targets and specify the runtime identifier of each platform that you target.","pos":[18472,18720],"source":"As you did in the [Deploying a Simple Self-Contained App](#simpleSelf) example, create a `runtimes` section in your `project.json` file that defines the platforms your app targets and specify the runtime identifier of each platform that you target."},{"content":"See <bpt id=\"p1\">[</bpt>Runtime IDentifier catalog<ept id=\"p1\">](../rid-catalog.md)</ept> for a list of runtime identifiers.","pos":[18721,18807],"source":" See [Runtime IDentifier catalog](../rid-catalog.md) for a list of runtime identifiers."},{"content":"For example, the following <ph id=\"ph1\">`runtimes`</ph> section indicates that the app runs on 64-bit Windows 10 operating systems and the 64-bit OS X Version 10.10 operating system.","pos":[18808,18972],"source":" For example, the following `runtimes` section indicates that the app runs on 64-bit Windows 10 operating systems and the 64-bit OS X Version 10.10 operating system."},{"content":"Note that you also need to add a comma to separate the <ph id=\"ph1\">`runtimes`</ph> section from the previous section.","pos":[19083,19183],"source":"Note that you also need to add a comma to separate the `runtimes` section from the previous section."},{"content":"A complete sample <ph id=\"ph1\">`project.json`</ph> file appears later in this section.","pos":[19184,19252],"source":"\nA complete sample `project.json` file appears later in this section."},{"pos":[19257,19344],"content":"Run the <ph id=\"ph1\">`dotnet restore`</ph> command to restore the dependencies specified in your project.","source":"Run the `dotnet restore` command to restore the dependencies specified in your project."},{"content":"Create debug builds of your app on each of the target platforms by using the <ph id=\"ph1\">`dotnet build`</ph> command.","pos":[19349,19449],"source":"Create debug builds of your app on each of the target platforms by using the `dotnet build` command."},{"content":"Unless you specify the runtime identifier you'd like to build, the <ph id=\"ph1\">`dotnet build`</ph> command creates a build only for the current system's runtime ID.","pos":[19450,19597],"source":" Unless you specify the runtime identifier you'd like to build, the `dotnet build` command creates a build only for the current system's runtime ID."},{"content":"You can build your app for both target platforms with the commands:","pos":[19598,19665]},{"pos":[19758,19967],"content":"After you've debugged and tested the program, you can create the files to be deployed with your app for each platform that it targets by using the <ph id=\"ph1\">`dotnet publish`</ph> command for both target platforms as follows:","source":"After you've debugged and tested the program, you can create the files to be deployed with your app for each platform that it targets by using the `dotnet publish` command for both target platforms as follows:"},{"content":"This creates a release (rather than a debug) version of your app for each target platform.","pos":[20078,20168]},{"content":"The resulting files are placed in a subdirectory named <ph id=\"ph1\">`publish`</ph> that is in a subdirectory of your project's <ph id=\"ph2\">`.\\bin\\release\\netstandard1.6\\&lt;runtime_identifier&gt;`</ph> subdirectory.","pos":[20169,20343],"source":" The resulting files are placed in a subdirectory named `publish` that is in a subdirectory of your project's `.\\bin\\release\\netstandard1.6\\<runtime_identifier>` subdirectory."},{"content":"Note that each subdirectory contains the complete set of files (both your app files and all .NET Core files) needed to launch your app.","pos":[20344,20479]},{"content":"Along with your application's files, the publishing process emits a program database (.pdb) file that contains debugging information about your app.","pos":[20484,20632]},{"content":"The file is useful primarily for debugging exceptions; you can choose not to package it with your application's files.","pos":[20633,20751]},{"content":"The published files can be deployed in any way you'd like.","pos":[20753,20811]},{"content":"For example, you can package them in a zip file, use a simple <ph id=\"ph1\">`copy`</ph> command, or deploy them with any installation package of your choice.","pos":[20812,20950],"source":" For example, you can package them in a zip file, use a simple `copy` command, or deploy them with any installation package of your choice."},{"content":"Before packaging and deploying your app, you can also use <ph id=\"ph1\">`crossgen`</ph> to convert it to native code.","pos":[20951,21049],"source":" Before packaging and deploying your app, you can also use `crossgen` to convert it to native code."},{"content":"For more information, see the <bpt id=\"p1\">[</bpt>Native Image Generation<ept id=\"p1\">](#crossgen)</ept> section.","pos":[21050,21125],"source":" For more information, see the [Native Image Generation](#crossgen) section."},{"pos":[21127,21194],"content":"The following is the complete <ph id=\"ph1\">`project.json`</ph> file for this project.","source":"The following is the complete `project.json` file for this project."},{"pos":[21678,21701],"content":"Native image Generation"},{"content":"NET Core uses a just in time (JIT) compiler that stores application code in an intermediate format and compiles it to native code at runtime.","pos":[21706,21847]},{"content":"To increase startup performance, the shared framework is pre-compiled using a tool called <ph id=\"ph1\">`crossgen`</ph>.","pos":[21849,21950],"source":"  To increase startup performance, the shared framework is pre-compiled using a tool called `crossgen`."},{"content":"To improve performance of your application, you can use the same tool on your application's binaries.","pos":[21952,22053]},{"content":"Its performance impact is more noticeable when deploying a self-contained application, since the entire framework is part of the application.","pos":[22055,22196]},{"content":"Crossgen must be run on a machine of the same platform type that you are targeting, but need not be done on the same machine, unlike ngen for the desktop framework.","pos":[22197,22361]},{"content":"If you are producing a platform-specific installer for your application, we recomend that you crossgen as part of the installer build process.","pos":[22363,22505]}],"content":"---\ntitle: .NET Core Application Deployment \ndescription: .NET Core Application Deployment \nkeywords: .NET, .NET Core, .NET Core deployment\nauthor: rpetrusha\nmanager: wpickett\nms.date: 07/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: da7a31a0-8072-4f23-82aa-8a19184cb701\n---\n\n# .NET Core Application Deployment #\n\nYou can deploy your .NET Core app in either of two ways:\n\n- As a portable app. A portable app relies on a shared system-wide version of .NET Core to be present on the target system. Because .NET Core is already present, your app is portable between installations of .NET Core. Your app contains only its own code and any third-party dependencies that are outside of the .NET Core libraries. Portable applications are .dll files that can be launched by using the [dotnet utility](../tools/dotnet.md) from the command line. For example, `dotnet app.dll` runs a portable application named `app`.\n\n- As a self-contained application. Unlike a portable app, a self-contained app does not rely on any shared components to be present on the target system. All components, including both .NET Core libraries and the .NET Core runtime, are included with the application and are isolated from other .NET Core applications. Self-contained applications include an executable (such as `app.exe` on Windows platforms for a self-contained application named `app`), which is  a renamed version of the platform-specific .NET Core host, and a .dll file (such as `app.dll`), which is the actual application.\n\nFor more information on .NET Core application types, see [.NET Core App Types](../app-types.md).\n\n## Portable applications ##\n\nFor a portable app, you deploy only your app and any third-party dependencies. You do not have to deploy .NET Core, since your app will use the version of .NET Core that's present on the target system. This is the default deployment model for .NET Core apps.\n\n### Why deploy a portable app? ###\n\nDeploying a portable app has a number of advantages:\n\n- You do not have to define the target operating systems that your .NET Core app will run on in advance. Because .NET Core uses a common PE file format for executables and libraries regardless of operating system, .NET Core can execute your app regardless of the underlying operating system. For more information on the PE file format, see [.NET Assembly File Format](../../standard/assembly-format.md).\n\n- The size of your deployment package is small. You only have to deploy your app and its dependencies, not .NET Core itself.\n\n- Multiple apps use the same .NET Core installation, which reduces both disk space and memory usage on host systems.\n\nThere are also a few disadvantages:\n\n- Your app can run only if the version of .NET Core that you target, or a later version, is already installed on the host system.\n\n- It is possible for the .NET Core runtime and libraries to change without your knowledge in future releases. In rare cases, this may change the behavior of your app.\n\n### Deploying a simple portable app ###\n\nDeploying a portable app with no third-party dependencies simply involves building, testing, and publishing the app. A simple example written in C# illustrates the process. The example uses the [dotnet utility](../tools/dotnet.md) from the command line; however, you can also use a development environment, such as Visual Studio or Visual Studio Code, to compile, test, and publish the example.\n\n1. Create a directory for your project, and from the command line, type [dotnet new](../tools/dotnet-new.md) to create a new C# console project.\n\n2. Open the `Program.cs` file in an editor, and replace the auto-generated code with the following code. It prompts the user to enter text, and then displays the individual words entered by the user. It uses the regular expression `\\w+` to separate the words in the input text.\n\n    ```cs\n    using System;\n    using System.Text.RegularExpressions;\n\n    namespace Applications.ConsoleApps\n    {\n        public class ConsoleParser\n        {\n            public static void Main()\n            {\n                 Console.WriteLine(\"Enter any text, followed by <Enter>:\\n\");\n                 String s = Console.ReadLine();\n                 ShowWords(s);\n                 Console.Write(\"\\nPress any key to continue... \");\n                 Console.ReadKey();\n          }\n\n          private static void ShowWords(String s)\n          {\n              String pattern = @\"\\w+\";\n              var matches = Regex.Matches(s, pattern);\n              if (matches.Count == 0)\n                  Console.WriteLine(\"\\nNo words were identified in your input.\");\n              else\n              {\n                  Console.WriteLine(\"\\nThere are {0} words in your string:\", matches.Count);\n                  for (int ctr = 0; ctr < matches.Count; ctr++)\n                      Console.WriteLine(\"   #{0,2}: '{1}' at position {2}\", ctr,\n                                        matches[ctr].Value, matches[ctr].Index);\n              }\n          }\n      }\n    }\n    ```\n\n3. Run the [dotnet restore](../tools/dotnet-restore.md) command to restore the dependencies specified in your project.\n\n4. Create a debug build of your app by using the [dotnet build](../tools/dotnet-build.md) command.\n\n5. After you've debugged and tested the program, you can create the files to be deployed with your app by using the `dotnet publish -f netcoreapp1.0 -c release` command. This creates a release (rather than a debug) version of your app.\n\n   The resulting files are placed in a directory named `publish` that is in a subdirectory of your project's `.\\bin\\release\\netcoreapp1.0` subdirectory.\n\n6. Along with your application's files, the publishing process emits a program database (.pdb) file that contains debugging information about your app. The file is useful primarily for debugging exceptions; you can choose not to package it with your application's files.\n\nThe complete set of application  files can be deployed in any way you'd like. For example, you can package them in a zip file, use a simple `copy` command, or deploy them with any installation package of your choice.\n\nBefore deploying your app, you can also use `crossgen` to convert it to native code. However, its performance impact is smaller than for self-contained apps. For more information, see the [Native Image Generation](#crossgen) section.\n\nIn addition to the application binaries, the installer should also either bundle the shared framework installer or check for it as a prerequisite as part of the application installation.  Installation of the shared framework requires Administrator/root access since it is machine-wide.\n\n### Deploying a portable app with third-party dependencies ###\n\nDeploying a portable app with one or more third-party dependencies involves three additional steps before you can run the `dotnet restore` command:\n\n1. Add references to any third-party libraries to the `dependencies` section of your `project.json` file. The following  `dependencies` section uses Json.NET as a third-party library.\n\n    ```json\n    \"dependencies\": {\n      \"Microsoft.NETCore.App\": {\n        \"type\": \"platform\",\n        \"version\": \"1.0.0\"\n      },\n      \"Newtonsoft.Json\": \"9.0.1\"\n    },\n    ```\n\n2. If you haven't already, download the NuGet package containing the third-party dependency. To download the package, execute the `dotnet restore` command after adding the dependency. Because the dependency is resolved out of the local NuGet cache at publish time, it must be available on your system.\n\nNote that a portable app with third-party dependencies will only be as portable as its third-party dependencies. For example, if a third-party library only supports macOS, the app will not be portable to Windows systems.\n\nWhen you deploy your application, any third-party dependencies used in your app are resolved from the local NuGet cache of the system on which your app is running. In other words, the third-party library must be present on the target machine for your app to run successfully.\n\n## Self-contained applications ##\n\nFor a self-contained app, you deploy not only your app and any third-party dependencies, but the version of .NET Core that you build your app with.\n\n### Why deploy a self-contained app? ###\n\nDeploying a self-contained app has two major advantages:\n\n- You have sole control of the version of .NET Core that is deployed with your app. .NET Core can be serviced only by you.\n\n- You can be assured that the target system can run your .NET Core app, since you're providing the version of .NET Core that it will run on.\n\nIt also has a number of disadvantages:\n\n- Because .NET Core is included in your deployment package, you must select the target platforms for which you build deployment packages in advance.\n\n- The size of your deployment package is relatively large, since you have to include .NET Core as well as your app and its third-party dependencies.\n\n- Deploying numerous self-contained .NET Core apps to a system can consume significant amounts of disk space, since each app duplicates .NET Core files.\n\n### <a name=\"simpleSelf\"></a> Deploying a simple self-contained app ###\n\nDeploying a self-contained app with no third-party dependencies involves creating the project, modifying the project.json file, building, testing, and publishing the app.  A simple example written in C# illustrates the process. The example uses the `dotnet` utility from the command line; however, you can also use a development environment, such as Visual Studio or Visual Studio Code, to compile, test, and publish the example.\n\n1. Create a directory for your project, and from the command line, type `dotnet new` to create a new C# console project.\n\n2. Open the `Program.cs` file in an editor, and replace the auto-generated code with the following code. It prompts the user to enter text, and then displays the individual words entered by the user. It uses the regular expression `\\w+` to separate the words in the input text.\n\n    ```cs\n    using System;\n    using System.Text.RegularExpressions;\n\n    namespace Applications.ConsoleApps\n    {\n        public class ConsoleParser\n        {\n            public static void Main()\n            {\n                 Console.WriteLine(\"Enter any text, followed by <Enter>:\\n\");\n                 String s = Console.ReadLine();\n                 ShowWords(s);\n                 Console.Write(\"\\nPress any key to continue... \");\n                 Console.ReadKey();\n          }\n\n          private static void ShowWords(String s)\n          {\n              String pattern = @\"\\w+\";\n              var matches = Regex.Matches(s, pattern);\n              if (matches.Count == 0)\n                  Console.WriteLine(\"\\nNo words were identified in your input.\");\n              else {\n                  Console.WriteLine(\"\\nThere are {0} words in your string:\", matches.Count);\n                  for (int ctr = 0; ctr < matches.Count; ctr++)\n                      Console.WriteLine(\"   #{0,2}: '{1}' at position {2}\", ctr,\n                                        matches[ctr].Value, matches[ctr].Index);\n              }\n          }\n      }\n    }\n    ```\n\n3. Open the `project.json` file and in the `frameworks` section, remove the following line:\n\n   ```json\n   \"type\": \"platform\",\n   ```\nThe Framework section should appear as follows after you've modified it:\n\n    ```json\n    \"frameworks\": {\n      \"netcoreapp1.0\": {\n        \"dependencies\": {\n          \"Microsoft.NETCore.App\": {\n             \"version\": \"1.0.0\"\n          }\n        }\n      }\n    }\n    ```\nRemoving the `\"type\": \"platform\"` attribute indicates that the framework is provided as a set of components local to our app, rather than as a system-wide platform package.\n\n4. Create a `runtimes` section in your `project.json` file that defines the platforms your app targets, and specify the runtime identifier of each platform that you target. See [Runtime IDentifier catalog](../rid-catalog.md) for a list of runtime identifiers. For example, the following `runtimes` section indicates that the app runs on 64-bit Windows 10 operating systems and the 64-bit OS X Version 10.10 operating system.\n\n    ```json\n        \"runtimes\": {\n          \"win10-x64\": {},\n          \"osx.10.10-x64\": {}\n        }\n    ```\nNote that you also need to add a comma to separate the `runtimes` section from the previous section.\nA complete sample `project.json` file appears later in this section.\n\n6. Run the `dotnet restore` command to restore the dependencies specified in your project.\n\n7. Create debug builds of your app on each of the target platforms by using the `dotnet build` command. Unless you specify the runtime identifier you'd like to build, the `dotnet build` command creates a build only for the current system's runtime ID. You can build your app for both target platforms with the commands:\n\n    ```console\n    dotnet build -r win10-x64\n    dotnet build -r osx.10.10-x64\n    ```\nThe debug builds of your app for each platform will be found in the project's `.\\bin\\Debug\\netcoreapp1.0\\<runtime_identifier>` subdirectory.\n\n8. After you've debugged and tested the program, you can create the files to be deployed with your app for each platform that it targets by using the `dotnet publish` command for both target platforms as follows:\n\n   ```console\n   dotnet publish -c release -r win10-x64\n   dotnet publish -c release -r osx.10.10-x64\n   ```\nThis creates a release (rather than a debug) version of your app for each target platform. The resulting files are placed in a subdirectory named `publish` that is in a subdirectory of your project's `.\\bin\\release\\netcoreapp1.0\\<runtime_identifier>` subdirectory. Note that each subdirectory contains the complete set of files (both your app files and all .NET Core files) needed to launch your app.\n\n9. Along with your application's files, the publishing process emits a program database (.pdb) file that contains debugging information about your app. The file is useful primarily for debugging exceptions; you can choose not to package it with your application's files.\n\nThe published files can be deployed in any way you'd like. For example, you can package them in a zip file, use a simple `copy` command, or deploy them with any installation package of your choice. Before packaging and deploying your app, you can also use `crossgen` to convert it to native code. For more information, see the [Native Image Generation](#crossgen) section.\n\nThe following is the complete `project.json` file for this project.\n\n```json\n{\n  \"version\": \"1.0.0-*\",\n  \"buildOptions\": {\n    \"debugType\": \"portable\",\n    \"emitEntryPoint\": true\n  },\n  \"dependencies\": {},\n  \"frameworks\": {\n    \"netcoreapp1.0\": {\n      \"dependencies\": {\n        \"Microsoft.NETCore.App\": {\n          \"version\": \"1.0.0\"\n        }\n      }\n    }\n  },\n  \"runtimes\": {\n    \"win10-x64\": {},\n    \"osx.10.10-x64\": {}\n  }\n}\n```\n\n### Deploying a self-contained app with third-party dependencies ###\n\nDeploying a self-contained app with one or more third-party dependencies involves three additional steps before you can run the `dotnet restore` command:\n\n1. Add references to any third-party libraries to the `dependencies` section of your `project.json` file. The following  `dependencies` section uses Json.NET as a third-party library.\n\n    ```json\n    \"dependencies\": {\n      \"Microsoft.NETCore.App\": \"1.0.0\",\n      \"Newtonsoft.Json\": \"8.0.3\"\n    },\n    ```\n\n2. Modify the `frameworks` section as follows to ensure that the `dotnet` utility will not consider .NET Core and Json.NET to be incompatible:\n\n   ```json\n   \"frameworks\": {\n     \"netcoreapp1.0\": {\n       \"imports\": \"dnxcore50\"\n     }\n   },\n   ```\n\n3. If you haven't already, download the NuGet package containing the third-party dependency to your system. To make the dependency available to your app, execute the `dotnet restore` command after adding the dependency. Because the dependency is resolved out of the local NuGet cache at publish time, it must be available on your system.\n\nThe following is the complete project.json file for this project:\n\n```json\n{\n  \"version\": \"1.0.0-*\",\n  \"buildOptions\": {\n    \"debugType\": \"portable\",\n    \"emitEntryPoint\": true\n  },\n  \"dependencies\": {\n    \"Microsoft.NETCore.App\": \"1.0.0\",\n    \"Newtonsoft.Json\": \"8.0.3\"\n  },\n  \"frameworks\": {\n    \"netcoreapp1.0\": {\n      \"imports\": \"dnxcore50\"\n    }\n  },\n  \"runtimes\": {\n    \"win10-x64\": {},\n    \"osx.10.10-x64\": {}\n  }\n}\n```\n\nWhen you deploy your application, any third-party dependencies used in your app are also contained with your application files. Third-party libraries do not already have to be present on the system on which the app is running.\n\nNote that you can only deploy a self-contained app with a third-party library to platforms supported by that library.\n\n### Deploying a self-contained app with a smaller footprint ###\n\nIf the availability of adequate storage space on target systems is likely to be an issue, you can reduce the overall footprint of your app by excluding some system components. To do this, you explicitly define the .NET Core components that your app includes in your project.json file.\n\nTo create a self-contained app with a smaller footprint, start by following the first two steps for creating a self-contained app. Once you've run the `dotnet new` command and added the C# source code to your app, do the following:\n\n1. Open the `project.json` file and replace the `frameworks` section with the following:\n\n    ```json\n    \"frameworks\": {\n      \"netstandard1.6\": { }\n    }\n    ```\nThis does two things:\n\n    * It indicates that, instead of using the entire `netcoreapp1.0` framework, which includes .NET Core CLR, the .NET Core Library, and a number of other system components, our app uses only the .NET Standard Library.\n\n    * By removing the `\"type\": \"platform\"` attribute, it indicates that the framework is provided as a set of components local to our app, rather than as a system-wide platform package.\n\n2. Replace the `dependencies` section with the following:\n\n    ```json\n    \"dependencies\": {\n      \"NETStandard.Library\": \"1.6.0\",\n      \"Microsoft.NETCore.Runtime.CoreCLR\": \"1.0.2\",\n      \"Microsoft.NETCore.DotNetHostPolicy\":  \"1.0.1\"\n    },\n    ```\n   This defines the system components used by our app. The system components packaged with our app include the .NET Standard Library, the .NET Core runtime, and the .NET Core host. This produces a self-contained app with a smaller footprint.\n\n3. As you did in the [Deploying a Simple Self-Contained App](#simpleSelf) example, create a `runtimes` section in your `project.json` file that defines the platforms your app targets and specify the runtime identifier of each platform that you target. See [Runtime IDentifier catalog](../rid-catalog.md) for a list of runtime identifiers. For example, the following `runtimes` section indicates that the app runs on 64-bit Windows 10 operating systems and the 64-bit OS X Version 10.10 operating system.\n\n    ```json\n        \"runtimes\": {\n          \"win10-x64\": {},\n          \"osx.10.10-x64\": {}\n        }\n    ```\nNote that you also need to add a comma to separate the `runtimes` section from the previous section.\nA complete sample `project.json` file appears later in this section.\n\n4. Run the `dotnet restore` command to restore the dependencies specified in your project.\n\n5. Create debug builds of your app on each of the target platforms by using the `dotnet build` command. Unless you specify the runtime identifier you'd like to build, the `dotnet build` command creates a build only for the current system's runtime ID. You can build your app for both target platforms with the commands:\n\n    ```console\n    dotnet build -r win10-x64\n    dotnet build -r osx.10.10-x64\n    ```\n\n6. After you've debugged and tested the program, you can create the files to be deployed with your app for each platform that it targets by using the `dotnet publish` command for both target platforms as follows:\n\n   ```console\n   dotnet publish -c release -r win10-x64\n   dotnet publish -c release -r osx.10.10-x64\n   ```\nThis creates a release (rather than a debug) version of your app for each target platform. The resulting files are placed in a subdirectory named `publish` that is in a subdirectory of your project's `.\\bin\\release\\netstandard1.6\\<runtime_identifier>` subdirectory. Note that each subdirectory contains the complete set of files (both your app files and all .NET Core files) needed to launch your app.\n\n7. Along with your application's files, the publishing process emits a program database (.pdb) file that contains debugging information about your app. The file is useful primarily for debugging exceptions; you can choose not to package it with your application's files.\n\nThe published files can be deployed in any way you'd like. For example, you can package them in a zip file, use a simple `copy` command, or deploy them with any installation package of your choice. Before packaging and deploying your app, you can also use `crossgen` to convert it to native code. For more information, see the [Native Image Generation](#crossgen) section.\n\nThe following is the complete `project.json` file for this project.\n\n```json\n   {\n     \"version\": \"1.0.0-*\",\n     \"buildOptions\": {\n       \"debugType\": \"portable\",\n       \"emitEntryPoint\": true\n     },\n     \"dependencies\": {\n       \"NETStandard.Library\": \"1.6.0\",\n       \"Microsoft.NETCore.Runtime.CoreCLR\": \"1.0.2\",\n       \"Microsoft.NETCore.DotNetHostPolicy\":  \"1.0.1\"\n     },\n     \"frameworks\": {\n       \"netstandard1.6\": { }\n     },\n     \"runtimes\": {\n       \"win10-x64\": {},\n       \"osx.10.10-x64\": {}\n     }\n   }\n```\n\n## <a name=\"crossgen\"></a> Native image Generation ##\n\nNET Core uses a just in time (JIT) compiler that stores application code in an intermediate format and compiles it to native code at runtime.  To increase startup performance, the shared framework is pre-compiled using a tool called `crossgen`.  To improve performance of your application, you can use the same tool on your application's binaries.  Its performance impact is more noticeable when deploying a self-contained application, since the entire framework is part of the application. Crossgen must be run on a machine of the same platform type that you are targeting, but need not be done on the same machine, unlike ngen for the desktop framework.  If you are producing a platform-specific installer for your application, we recomend that you crossgen as part of the installer build process.\n"}