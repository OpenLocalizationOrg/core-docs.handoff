{"nodes":[{"pos":[11,22],"content":".NET Primer","needQuote":true,"nodes":[{"content":".NET Primer","pos":[0,11]}]},{"pos":[36,47],"content":".NET Primer","needQuote":true,"nodes":[{"content":".NET Primer","pos":[0,11]}]},{"pos":[58,73],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":".NET Primer","pos":[281,292]},{"content":"Check out the <bpt id=\"p1\">[</bpt>\"Getting Started with .NET Core\" tutorials<ept id=\"p1\">](../core/getting-started.md)</ept> to learn how to create a simple .NET Core application.","pos":[296,437],"source":"Check out the [\"Getting Started with .NET Core\" tutorials](../core/getting-started.md) to learn how to create a simple .NET Core application."},{"content":"It only takes a few minutes to get your first app up and running.","pos":[438,503]},{"content":".NET is a general purpose development platform.","pos":[505,552]},{"content":"It can be used for any kind of app type or workload where general purpose solutions are used.","pos":[553,646]},{"content":"It has several key features that are attractive to many developers, including automatic memory management and modern programming languages, that make it easier to efficiently build high-quality applications.","pos":[647,854]},{"content":".NET enables a high-level programming environment with many convenience features, while providing low-level access to native memory and APIs.","pos":[855,996]},{"content":"Multiple implementations of .NET are available, based on open <bpt id=\"p1\">[</bpt>.NET Standards<ept id=\"p1\">](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/dotnet-standards.md)</ept> that specify the fundamentals of the platform.","pos":[998,1217],"source":"Multiple implementations of .NET are available, based on open [.NET Standards](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/dotnet-standards.md) that specify the fundamentals of the platform."},{"content":"They are separately optimized for different application types (e.g. desktop, mobile, gaming, cloud) and support many chips (e.g. x86/x64, ARM) and operating systems (e.g. Windows, Linux, iOS, Android, macOS).","pos":[1218,1426]},{"content":"Open source is also an important part of the .NET ecosystem, with multiple .NET implementations and many libraries available under OSI-approved licenses.","pos":[1427,1580]},{"pos":[1582,1789],"content":"You can take a look at the <bpt id=\"p1\">[</bpt>Overview of .NET implementations<ept id=\"p1\">](../about/products.md)</ept> document to figure out all of the different editions of the .NET Framework that are available, both Microsoft's and others.","source":"You can take a look at the [Overview of .NET implementations](../about/products.md) document to figure out all of the different editions of the .NET Framework that are available, both Microsoft's and others."},{"content":"This Primer will help you understand some of the key concepts in the .NET Platform and point you to more resources for each given topic.","pos":[1791,1928],"source":"This Primer will help you understand some of the key concepts in the .NET Platform and point you to more resources \nfor each given topic."},{"content":"By the end of it, you should have enough information to be able to recognize significant terms and concepts in the .NET Platform and to know how to further your knowledge about them.","pos":[1929,2112],"source":" By the end of it, you should have enough information to be able to recognize significant terms and \nconcepts in the .NET Platform and to know how to further your knowledge about them."},{"content":"Key .NET Concepts","pos":[2118,2135]},{"content":"There is a certain number of concepts that are very important to understand if you are new to the .NET Platform.","pos":[2137,2249]},{"content":"These concepts are the cornerstone of the entire platform, and understanding them at the outset is important for general understanding of how .NET works.","pos":[2250,2403]},{"pos":[2405,2473],"content":"Most of these concepts are defined in the <bpt id=\"p1\">**</bpt>What is .NET?<ept id=\"p1\">**</ept> article.","source":"Most of these concepts are defined in the **What is .NET?** article."},{"content":"A stroll through .NET","pos":[2480,2501]},{"content":"As any mature and advanced application development framework, .NET has many powerful features that make the developer's job easier and aim to make writing code more powerful and expressive.","pos":[2503,2692]},{"content":"This section will outline the basics of the most salient features and provide pointers to more detailed discussions where needed.","pos":[2693,2822]},{"content":"After finishing this stroll, you should have enough information to be able to read the samples on our GitHub repos as well as other code and understand what is going on.","pos":[2823,2992]},{"content":"Programming languages","pos":[2999,3020]},{"content":"Automatic memory management","pos":[3051,3078]},{"content":"Type safety","pos":[3115,3126]},{"content":"Delegates and lambdas","pos":[3147,3168]},{"content":"Generic Types (Generics)","pos":[3199,3223]},{"content":"Language Integrated Query (LINQ)","pos":[3255,3287]},{"content":"Async Programming","pos":[3327,3344]},{"content":"Native interoperability","pos":[3371,3394]},{"content":"Unsafe Code","pos":[3427,3438]},{"content":"Programming languages","pos":[3459,3480]},{"content":"As a developer, you can choose any programming language that supports .NET to create your application.","pos":[3482,3584]},{"content":"Because .NET provides language independence and interoperability, you can interact with other .NET applications and components regardless of the language with which they were developed.","pos":[3585,3770]},{"pos":[3772,3955],"content":"Languages that allow you to develop applications for the .NET Platform adhere to the <bpt id=\"p1\">[</bpt>Common Language Infrastructure (CLI) specification<ept id=\"p1\">](https://www.visualstudio.com/en-us/mt639507)</ept>.","source":"Languages that allow you to develop applications for the .NET Platform adhere to the [Common Language Infrastructure (CLI) specification](https://www.visualstudio.com/en-us/mt639507)."},{"content":"Microsoft languages that .NET supports include C#, F#, and Visual Basic.","pos":[3957,4029]},{"content":"C# is simple, powerful, type-safe, and object-oriented while retaining the expressiveness and elegance of C-style languages.","pos":[4034,4158]},{"content":"Anyone familiar with C and similar languages will find few problems in adapting to C#.","pos":[4159,4245]},{"content":"F# is a cross-platform, functional-first programming language that also supports traditional object-oriented and imperative programming.","pos":[4249,4385]},{"content":"Visual Basic is an easy language to learn that you can use to build a variety of applications that run on .NET.","pos":[4389,4500]},{"content":"Note","pos":[4506,4510]},{"content":"In the current release of .NET Core, only C# is fully supported.","pos":[4518,4582]},{"content":"Automatic memory management","pos":[4592,4619]},{"content":"Garbage collection is the most well-known of .NET features.","pos":[4621,4680]},{"content":"Developers do not need to actively manage memory, although there are mechanisms to provide more information to the garbage collector (GC).","pos":[4681,4819]},{"content":"C# includes the <ph id=\"ph1\">`new`</ph> keyword to allocate memory in terms of a particular type, and the <ph id=\"ph2\">`using`</ph> keyword to provide scope for the usage of the object.","pos":[4820,4969],"source":" C# includes the `new` keyword to allocate memory in terms of a particular type, and the `using` keyword to provide scope for the usage of the object."},{"content":"The GC operates on a lazy approach to memory management, preferring application throughput to the immediate collection of memory.","pos":[4970,5099]},{"content":"The following two lines both allocate memory:","pos":[5101,5146]},{"content":"There is no analogous keyword to de-allocate memory, as de-allocation happens automatically when the garbage collector reclaims the memory through its scheduled running.","pos":[5216,5385]},{"content":"Method variables normally go out of scope once a method completes, at which point they can be collected.","pos":[5387,5491]},{"content":"However, you can indicate to the GC that a particular object is out of scope sooner than method exit using the <ph id=\"ph1\">`using`</ph> statement.","pos":[5492,5621],"source":" However, you can indicate to the GC that a particular object is out of scope sooner than method exit using the `using` statement."},{"pos":[5720,5866],"content":"Once the <ph id=\"ph1\">`using`</ph> block completes, the GC will know that the <ph id=\"ph2\">`stream`</ph> object in the example above is free to be collected and its memory reclaimed.","source":"Once the `using` block completes, the GC will know that the `stream` object in the example above is free to be collected and its memory reclaimed."},{"content":"One of the less obvious but quite far-reaching features that a garbage collector enables is memory safety.","pos":[5868,5974]},{"content":"The invariant of memory safety is very simple: a program is memory safe if it accesses only memory that has been allocated (and not freed).","pos":[5975,6114]},{"content":"Dangling pointers are always bugs, and tracking them down is often quite difficult.","pos":[6115,6198]},{"content":"The .NET runtime provides additional services, to complete the promise of memory safety, not naturally offered by a GC.","pos":[6200,6319]},{"content":"It ensures that programs do not index off the end of an array or accessing a phantom field off the end of an object.","pos":[6320,6436]},{"content":"The following example will throw an exception as a result of memory safety.","pos":[6438,6513]},{"content":"Type Safety","pos":[6622,6633]},{"content":"Objects are allocated in terms of types.","pos":[6635,6675]},{"content":"The only operations allowed for a given object, and the memory it consumes, are those of its type.","pos":[6676,6774]},{"content":"A <ph id=\"ph1\">`Dog`</ph> type may have <ph id=\"ph2\">`Jump`</ph> and <ph id=\"ph3\">`WagTail`</ph> methods, but not likely a <ph id=\"ph4\">`SumTotal`</ph> method.","pos":[6775,6862],"source":" A `Dog` type may have `Jump` and `WagTail` methods, but not likely a `SumTotal` method."},{"content":"A program can only call the declared methods of a given type.","pos":[6863,6924]},{"content":"All other calls will result either in a compile-time error or a run-time exception (in case of using dynamic features or <ph id=\"ph1\">`object`</ph>).","pos":[6925,7056],"source":" All other calls will result either in a compile-time error or a run-time exception (in case of using dynamic features or `object`)."},{"content":".NET languages are object-oriented, with hierarchies of base and derived classes.","pos":[7058,7139]},{"content":"The .NET runtime will only allow object casts and calls that align with the object hierarchy.","pos":[7140,7233]},{"content":"Remember that every type defined in any .NET language derives from the base <ph id=\"ph1\">`object`</ph> type.","pos":[7234,7324],"source":" Remember that every type defined in any .NET language derives from the base `object` type."},{"content":"Type safety is also used to help enforce encapsulation by guaranteeing the fidelity of the accessor keywords.","pos":[7711,7820]},{"content":"Accessor keywords are artifacts which control access to members of a given type by other code.","pos":[7821,7915]},{"content":"These are usually used for various kinds of data within a type that are used to manage its behavior.","pos":[7916,8016]},{"content":"Some .NET languages support <bpt id=\"p1\">**</bpt>type inference<ept id=\"p1\">**</ept>.","pos":[8105,8152],"source":"Some .NET languages support **type inference**."},{"content":"Type inference means that the compiler will deduce the type of the expression on the left-hand side from the expression on the right-hand side.","pos":[8153,8296]},{"content":"This doesn't mean that the type safety is broken or avoided.","pos":[8297,8357]},{"content":"The resulting type <bpt id=\"p1\">**</bpt>has<ept id=\"p1\">**</ept> a strong type with everything that implies.","pos":[8358,8428],"source":" The resulting type **has** a strong type with everything that implies."},{"content":"Let's rewrite the first two lines of the previous example to introduce type inference.","pos":[8429,8515]},{"content":"You will note that the rest of the example is completely the same.","pos":[8516,8582]},{"content":"Delegates and Lambdas","pos":[8941,8962]},{"content":"Delegates are like C++ function pointers, with a big difference that they are type safe.","pos":[8964,9052]},{"content":"They are a kind of disconnected method within the CLR type system.","pos":[9053,9119]},{"content":"Regular methods are attached to a class and only directly callable through static or instance calling conventions.","pos":[9120,9234]},{"content":"Delegates are used in various APIs and places in the .NET world, especially through lambda expressions, which are a cornerstone of LINQ.","pos":[9236,9372]},{"pos":[9374,9455],"content":"Read more about it in the <bpt id=\"p1\">[</bpt>Delegates and lambdas<ept id=\"p1\">](delegates-lambdas.md)</ept> document.","source":"Read more about it in the [Delegates and lambdas](delegates-lambdas.md) document."},{"content":"Generic Types (Generics)","pos":[9461,9485]},{"content":"Generic types, also commonly called \"generics\" are a feature that was added in .NET Framework 2.0.","pos":[9487,9585]},{"content":"In short, generics allow the programmer to introduce a \"type parameter\" when designing their classes, that will allow the client code (the users of the type) to specify the exact type to use in place of the type parameter.","pos":[9586,9808]},{"content":"Generics were added in order to help programmers implement generic data structures.","pos":[9810,9893]},{"content":"Before their arrival, in order for a, say, <bpt id=\"p1\">_</bpt>List<ept id=\"p1\">_</ept> type to be generic, it would have to work with elements that were of type <bpt id=\"p2\">_</bpt>object<ept id=\"p2\">_</ept>.","pos":[9894,10027],"source":" Before their arrival, in order for a, say, _List_ type to be generic, it would have to work with elements that were of type _object_."},{"content":"This would have various performance as well as semantic problems, not to mention possible subtle runtime errors.","pos":[10028,10140]},{"content":"The most notorious of the latter is when a data structure contains, for instance, both integers and strings, and an <bpt id=\"p1\">_</bpt>InvalidCastException<ept id=\"p1\">_</ept> is thrown on working with the list's members.","pos":[10141,10325],"source":" The most notorious of the latter is when a data structure contains, for instance, both integers and strings, and an _InvalidCastException_ is thrown on working with the list's members."},{"pos":[10327,10411],"content":"The below sample shows a basic program running using an instance of <bpt id=\"p1\">_</bpt>List<ph id=\"ph1\">&lt;T&gt;</ph><ept id=\"p1\">_</ept> types.","source":"The below sample shows a basic program running using an instance of _List<T>_ types."},{"pos":[11019,11103],"content":"Read more about it in the <bpt id=\"p1\">[</bpt>Generic Types (Generics) Overview<ept id=\"p1\">](generics.md)</ept> document.","source":"Read more about it in the [Generic Types (Generics) Overview](generics.md) document."},{"content":"Async Programming","pos":[11109,11126]},{"content":"Async programming is a first-class concept within .NET, with async support in the runtime, the framework libraries, and .NET language constructs.","pos":[11128,11273]},{"content":"Internally, they are based off of objects (such as <ph id=\"ph1\">`Task`</ph>) which take advantage of the operating system to perform I/O-bound jobs as efficiently as possible.","pos":[11274,11431],"source":" Internally, they are based off of objects (such as `Task`) which take advantage of the operating system to perform I/O-bound jobs as efficiently as possible."},{"pos":[11433,11522],"content":"To learn more about async programming in .NET, start with the <bpt id=\"p1\">[</bpt>Async Overview<ept id=\"p1\">](async.md)</ept>.","source":"To learn more about async programming in .NET, start with the [Async Overview](async.md)."},{"content":"Language Integrated Query (LINQ)","pos":[11528,11560]},{"content":"LINQ is a powerful set of features for C# and VB that allow you to write simple, declarative code for operating on data.","pos":[11562,11682]},{"content":"The data can be in many forms (such as in-memory objects, in a SQL database, or an XML document), but the LINQ code you write typically won't look different for each data source!","pos":[11683,11861]},{"pos":[11863,11959],"content":"To learn more and see some samples, check out <bpt id=\"p1\">[</bpt>LINQ (Language Integrated Query)<ept id=\"p1\">](using-linq.md)</ept>.","source":"To learn more and see some samples, check out [LINQ (Language Integrated Query)](using-linq.md)."},{"content":"Native Interoperability","pos":[11965,11988]},{"content":"Every operating system in current use provides a lot of platform support for various programming tasks.","pos":[11990,12093]},{"content":".NET provides several ways to tap into those APIs.","pos":[12094,12144]},{"content":"Collectively, this support is called \"native interoperability\" and in this section we will take a look at how to access native APIs from managed, .NET code.","pos":[12145,12301]},{"content":"The main way to do native interoperability is via \"platform invoke\" or P/Invoke for short.","pos":[12303,12393]},{"content":"This support in .NET Core is available across Linux and Windows platforms.","pos":[12394,12468]},{"content":"Another, Windows-only way of doing native interoperability is known as \"COM interop\" which is used to work with <bpt id=\"p1\">[</bpt>COM components<ept id=\"p1\">](https://msdn.microsoft.com/library/bwa2bx93.aspx)</ept> in managed code.","pos":[12469,12664],"source":" Another, Windows-only way of doing native interoperability is known as \"COM interop\" which is used to work with [COM components](https://msdn.microsoft.com/library/bwa2bx93.aspx) in managed code."},{"content":"It is built on top of P/Invoke infrastructure, but it works in subtly different ways.","pos":[12665,12750]},{"content":"Most of Mono's (and thus Xamarin's) interoperability support for Java and Objective-C are built similarly, that is, they use the same principles.","pos":[12752,12897]},{"pos":[12899,12979],"content":"Read more about it in the <bpt id=\"p1\">[</bpt>Native interoperability<ept id=\"p1\">](native-interop.md)</ept> document.","source":"Read more about it in the [Native interoperability](native-interop.md) document."},{"content":"Unsafe Code","pos":[12985,12996]},{"content":"The CLR enables the ability to access native memory and do pointer arithmetic via <ph id=\"ph1\">`unsafe`</ph> code.","pos":[12998,13094],"source":"The CLR enables the ability to access native memory and do pointer arithmetic via `unsafe` code."},{"content":"These operations are needed for certain algorithms and system interoperability.","pos":[13095,13174]},{"content":"Although powerful, use of unsafe code is discouraged unless it is necessary to interop with system APIs or implement the most efficient algorithm.","pos":[13175,13321]},{"content":"Unsafe code may not execute the same way in different environments, and also loses the benefits of a garbage collector and type safety.","pos":[13322,13457]},{"content":"It's recommended to confine and centralize unsafe code as much as possible, and test that code thoroughly.","pos":[13458,13564]},{"pos":[13566,13837],"content":"The <ph id=\"ph1\">`ToString()`</ph> method from the <bpt id=\"p1\">[</bpt>StringBuilder class<ept id=\"p1\">](https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Text/StringBuilder.cs#L327)</ept> illustrates how using <ph id=\"ph2\">`unsafe`</ph> code can efficiently implement an algorithm by moving around chunks of memory directly:","source":"The `ToString()` method from the [StringBuilder class](https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Text/StringBuilder.cs#L327) illustrates how using `unsafe` code can efficiently implement an algorithm by moving around chunks of memory directly:"},{"content":"Notes","pos":[15525,15530]},{"content":"The term \".NET runtime\" is used throughout the document to accommodate for the multiple implementations of .NET, such as CLR, Mono, IL2CPP and others.","pos":[15532,15682]},{"content":"The more specific names are only used if needed.","pos":[15683,15731]},{"content":"This document is not intended to be historical in nature, but describe the .NET platform as it is now.","pos":[15733,15835]},{"content":"It isn't important whether a .NET feature has always been available or was only recently introduced, only that it is important enough to highlight and discuss.","pos":[15836,15995]}],"content":"---\ntitle: .NET Primer\ndescription: .NET Primer\nkeywords: .NET, .NET Core\nauthor: richlander\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: bbfe6465-329d-4982-869d-472e7ef85d93\n---\n\n# .NET Primer\n\n> Check out the [\"Getting Started with .NET Core\" tutorials](../core/getting-started.md) to learn how to create a simple .NET Core application. It only takes a few minutes to get your first app up and running.\n\n.NET is a general purpose development platform. It can be used for any kind of app type or workload where general purpose solutions are used. It has several key features that are attractive to many developers, including automatic memory management and modern programming languages, that make it easier to efficiently build high-quality applications. .NET enables a high-level programming environment with many convenience features, while providing low-level access to native memory and APIs.\n\nMultiple implementations of .NET are available, based on open [.NET Standards](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/dotnet-standards.md) that specify the fundamentals of the platform. They are separately optimized for different application types (e.g. desktop, mobile, gaming, cloud) and support many chips (e.g. x86/x64, ARM) and operating systems (e.g. Windows, Linux, iOS, Android, macOS). Open source is also an important part of the .NET ecosystem, with multiple .NET implementations and many libraries available under OSI-approved licenses.\n\nYou can take a look at the [Overview of .NET implementations](../about/products.md) document to figure out all of the different editions of the .NET Framework that are available, both Microsoft's and others.\n\nThis Primer will help you understand some of the key concepts in the .NET Platform and point you to more resources \nfor each given topic. By the end of it, you should have enough information to be able to recognize significant terms and \nconcepts in the .NET Platform and to know how to further your knowledge about them. \n\n## Key .NET Concepts\n\nThere is a certain number of concepts that are very important to understand if you are new to the .NET Platform. These concepts are the cornerstone of the entire platform, and understanding them at the outset is important for general understanding of how .NET works.\n\nMost of these concepts are defined in the **What is .NET?** article. \n\n\n## A stroll through .NET\n\nAs any mature and advanced application development framework, .NET has many powerful features that make the developer's job easier and aim to make writing code more powerful and expressive. This section will outline the basics of the most salient features and provide pointers to more detailed discussions where needed. After finishing this stroll, you should have enough information to be able to read the samples on our GitHub repos as well as other code and understand what is going on.\n\n*   [Programming languages](#programming-languages)\n*   [Automatic memory management](#automatic-memory-management)\n*   [Type safety](#type-safety)\n*   [Delegates and lambdas](#delegates-and-lambdas)\n*   [Generic Types (Generics)](#generic-types-generics)\n*   [Language Integrated Query (LINQ)](#language-integrated-query-linq)\n*   [Async Programming](#async-programming)\n*   [Native interoperability](#native-interoperability)\n*   [Unsafe Code](#unsafe-code)\n\n### Programming languages\n\nAs a developer, you can choose any programming language that supports .NET to create your application. Because .NET provides language independence and interoperability, you can interact with other .NET applications and components regardless of the language with which they were developed.\n\nLanguages that allow you to develop applications for the .NET Platform adhere to the [Common Language Infrastructure (CLI) specification](https://www.visualstudio.com/en-us/mt639507).\n\nMicrosoft languages that .NET supports include C#, F#, and Visual Basic. \n\n* C# is simple, powerful, type-safe, and object-oriented while retaining the expressiveness and elegance of C-style languages. Anyone familiar with C and similar languages will find few problems in adapting to C#.\n\n* F# is a cross-platform, functional-first programming language that also supports traditional object-oriented and imperative programming.\n\n* Visual Basic is an easy language to learn that you can use to build a variety of applications that run on .NET.\n\n> **Note**\n> \n> In the current release of .NET Core, only C# is fully supported.\n>  \n\n### Automatic memory management\n\nGarbage collection is the most well-known of .NET features. Developers do not need to actively manage memory, although there are mechanisms to provide more information to the garbage collector (GC). C# includes the `new` keyword to allocate memory in terms of a particular type, and the `using` keyword to provide scope for the usage of the object. The GC operates on a lazy approach to memory management, preferring application throughput to the immediate collection of memory.\n\nThe following two lines both allocate memory:\n\n```cs\nvar title = \".NET Primer\";\nvar list = new List<string>;\n\n```\n\nThere is no analogous keyword to de-allocate memory, as de-allocation happens automatically when the garbage collector reclaims the memory through its scheduled running.\n\nMethod variables normally go out of scope once a method completes, at which point they can be collected. However, you can indicate to the GC that a particular object is out of scope sooner than method exit using the `using` statement.\n\n```cs\nusing(FileStream stream = GetFileStream(context))\n{\n    //operations on the stream\n}\n\n```\n\nOnce the `using` block completes, the GC will know that the `stream` object in the example above is free to be collected and its memory reclaimed.\n\nOne of the less obvious but quite far-reaching features that a garbage collector enables is memory safety. The invariant of memory safety is very simple: a program is memory safe if it accesses only memory that has been allocated (and not freed). Dangling pointers are always bugs, and tracking them down is often quite difficult.\n\nThe .NET runtime provides additional services, to complete the promise of memory safety, not naturally offered by a GC. It ensures that programs do not index off the end of an array or accessing a phantom field off the end of an object.\n\nThe following example will throw an exception as a result of memory safety.\n\n```cs\nint[] numbers = new int[42];\nint number = numbers[42]; // will throw (indexes are 0-based)\n\n```\n\n### Type Safety\n\nObjects are allocated in terms of types. The only operations allowed for a given object, and the memory it consumes, are those of its type. A `Dog` type may have `Jump` and `WagTail` methods, but not likely a `SumTotal` method. A program can only call the declared methods of a given type. All other calls will result either in a compile-time error or a run-time exception (in case of using dynamic features or `object`).\n\n.NET languages are object-oriented, with hierarchies of base and derived classes. The .NET runtime will only allow object casts and calls that align with the object hierarchy. Remember that every type defined in any .NET language derives from the base `object` type.\n\n```cs\nDog dog = Dog.AdoptDog(); // Returns a Dog type\nPet pet = (Pet)dog; // Dog derives from Pet\npet.ActCute();\nCar car = (Car)dog; // will throw - no relationship between Car and Dog\nobject temp = (object)dog; // legal - a Dog is an object\ncar = (Car)temp; // will throw - the runtime isn't fooled\ncar.Accelerate() // the dog won't like this, nor will the program get this far\n\n```\n\nType safety is also used to help enforce encapsulation by guaranteeing the fidelity of the accessor keywords. Accessor keywords are artifacts which control access to members of a given type by other code. These are usually used for various kinds of data within a type that are used to manage its behavior.\n\n```cs\nDog dog = Dog._nextDogToBeAdopted; // will throw - this is a private field\n\n```\n\nSome .NET languages support **type inference**. Type inference means that the compiler will deduce the type of the expression on the left-hand side from the expression on the right-hand side. This doesn't mean that the type safety is broken or avoided. The resulting type **has** a strong type with everything that implies. Let's rewrite the first two lines of the previous example to introduce type inference. You will note that the rest of the example is completely the same.\n\n```cs\n  var dog = Dog.AdoptDog();\n  var pet = (Pet)dog;\n  pet.ActCute();\n  Car car = (Car)dog; // will throw - no relationship between Car and Dog\n  object temp = (object)dog; // legal - a Dog is an object\n  car = (Car)temp; // will throw - the runtime isn't fooled\n  car.Accelerate() // the dog won't like this, nor will the program get this far\n\n```\n\n### Delegates and Lambdas\n\nDelegates are like C++ function pointers, with a big difference that they are type safe. They are a kind of disconnected method within the CLR type system. Regular methods are attached to a class and only directly callable through static or instance calling conventions.\n\nDelegates are used in various APIs and places in the .NET world, especially through lambda expressions, which are a cornerstone of LINQ.\n\nRead more about it in the [Delegates and lambdas](delegates-lambdas.md) document.\n\n### Generic Types (Generics)\n\nGeneric types, also commonly called \"generics\" are a feature that was added in .NET Framework 2.0. In short, generics allow the programmer to introduce a \"type parameter\" when designing their classes, that will allow the client code (the users of the type) to specify the exact type to use in place of the type parameter.\n\nGenerics were added in order to help programmers implement generic data structures. Before their arrival, in order for a, say, _List_ type to be generic, it would have to work with elements that were of type _object_. This would have various performance as well as semantic problems, not to mention possible subtle runtime errors. The most notorious of the latter is when a data structure contains, for instance, both integers and strings, and an _InvalidCastException_ is thrown on working with the list's members.\n\nThe below sample shows a basic program running using an instance of _List<T>_ types.\n\n```cs\nusing System;\nusing System.Collections.Generic;\n\nnamespace GenericsSampleShort {\n    public static void Main(string[] args){\n        // List<string> is the client way of specifying the actual type for the type parameter T\n        List<string> listOfStrings = new List<string> { \"First\", \"Second\", \"Third\" };\n\n        // listOfStrings can accept only strings, both on read and write.\n        listOfStrings.Add(\"Fourth\");\n\n        // Below will throw a compile-time error, since the type parameter\n        // specifies this list as containing only strings.\n        listOfStrings.Add(1);\n\n    }\n}\n\n```\n\nRead more about it in the [Generic Types (Generics) Overview](generics.md) document.\n\n### Async Programming\n\nAsync programming is a first-class concept within .NET, with async support in the runtime, the framework libraries, and .NET language constructs. Internally, they are based off of objects (such as `Task`) which take advantage of the operating system to perform I/O-bound jobs as efficiently as possible.\n\nTo learn more about async programming in .NET, start with the [Async Overview](async.md).\n\n### Language Integrated Query (LINQ)\n\nLINQ is a powerful set of features for C# and VB that allow you to write simple, declarative code for operating on data. The data can be in many forms (such as in-memory objects, in a SQL database, or an XML document), but the LINQ code you write typically won't look different for each data source!\n\nTo learn more and see some samples, check out [LINQ (Language Integrated Query)](using-linq.md).\n\n### Native Interoperability\n\nEvery operating system in current use provides a lot of platform support for various programming tasks. .NET provides several ways to tap into those APIs. Collectively, this support is called \"native interoperability\" and in this section we will take a look at how to access native APIs from managed, .NET code.\n\nThe main way to do native interoperability is via \"platform invoke\" or P/Invoke for short. This support in .NET Core is available across Linux and Windows platforms. Another, Windows-only way of doing native interoperability is known as \"COM interop\" which is used to work with [COM components](https://msdn.microsoft.com/library/bwa2bx93.aspx) in managed code. It is built on top of P/Invoke infrastructure, but it works in subtly different ways.\n\nMost of Mono's (and thus Xamarin's) interoperability support for Java and Objective-C are built similarly, that is, they use the same principles.\n\nRead more about it in the [Native interoperability](native-interop.md) document.\n\n### Unsafe Code\n\nThe CLR enables the ability to access native memory and do pointer arithmetic via `unsafe` code. These operations are needed for certain algorithms and system interoperability. Although powerful, use of unsafe code is discouraged unless it is necessary to interop with system APIs or implement the most efficient algorithm. Unsafe code may not execute the same way in different environments, and also loses the benefits of a garbage collector and type safety. It's recommended to confine and centralize unsafe code as much as possible, and test that code thoroughly.\n\nThe `ToString()` method from the [StringBuilder class](https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Text/StringBuilder.cs#L327) illustrates how using `unsafe` code can efficiently implement an algorithm by moving around chunks of memory directly:\n\n```cs\npublic override String ToString() {\n          Contract.Ensures(Contract.Result<String>() != null);\n\n          VerifyClassInvariant();\n\n          if (Length == 0)\n              return String.Empty;\n\n          string ret = string.FastAllocateString(Length);\n          StringBuilder chunk = this;\n          unsafe {\n              fixed (char* destinationPtr = ret)\n              {\n                  do\n                  {\n                      if (chunk.m_ChunkLength > 0)\n                      {\n                          // Copy these into local variables so that they are stable even in the presence of ----s (hackers might do this)\n                          char[] sourceArray = chunk.m_ChunkChars;\n                          int chunkOffset = chunk.m_ChunkOffset;\n                          int chunkLength = chunk.m_ChunkLength;\n\n                          // Check that we will not overrun our boundaries.\n                          if ((uint)(chunkLength + chunkOffset) <= ret.Length && (uint)chunkLength <= (uint)sourceArray.Length)\n                          {\n                              fixed (char* sourcePtr = sourceArray)\n                                  string.wstrcpy(destinationPtr + chunkOffset, sourcePtr, chunkLength);\n                          }\n                          else\n                          {\n                              throw new ArgumentOutOfRangeException(\"chunkLength\", Environment.GetResourceString(\"ArgumentOutOfRange_Index\"));\n                          }\n                      }\n                      chunk = chunk.m_ChunkPrevious;\n                  } while (chunk != null);\n              }\n          }\n          return ret;\n      }\n\n```\n\n## Notes\n\nThe term \".NET runtime\" is used throughout the document to accommodate for the multiple implementations of .NET, such as CLR, Mono, IL2CPP and others. The more specific names are only used if needed.\n\nThis document is not intended to be historical in nature, but describe the .NET platform as it is now. It isn't important whether a .NET feature has always been available or was only recently introduced, only that it is important enough to highlight and discuss.\n"}