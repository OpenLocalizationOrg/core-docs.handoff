{"nodes":[{"pos":[11,37],"content":"Expression Trees Explained","needQuote":true,"nodes":[{"content":"Expression Trees Explained","pos":[0,26]}]},{"pos":[51,77],"content":"Expression Trees Explained","needQuote":true,"nodes":[{"content":"Expression Trees Explained","pos":[0,26]}]},{"pos":[88,103],"content":".NET, .NET Core","needQuote":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"content":"Expression Trees Explained","pos":[311,337]},{"content":"Previous -- Overview","pos":[340,360]},{"content":"An Expression Tree is a data structure that defines code.","pos":[384,441]},{"content":"They are based on the same structures that a compiler uses to analyze code and generate the compiled output.","pos":[442,550],"source":" They are based on the same structures\nthat a compiler uses to analyze code and generate the compiled output."},{"content":"As you read through this tutorial, you will notice quite a bit of similarity between Expression Trees and the types used in the Roslyn APIs to build <bpt id=\"p1\">[</bpt>Analyzers and CodeFixes<ept id=\"p1\">](https://github.com/dotnet/roslyn-analyzers)</ept>.","pos":[551,770],"source":" As you read through this\ntutorial, you will notice quite a bit of similarity between Expression Trees and the types used\nin the Roslyn APIs to build [Analyzers and CodeFixes](https://github.com/dotnet/roslyn-analyzers)."},{"content":"(Analyzers and CodeFixes are NuGet packages that perform static analysis on code and can suggest potential fixes for a developer.) The concepts are similar, and the end result is a data structure that allows examination of the source ode in a meaningful way.","pos":[771,1029],"source":"\n(Analyzers and CodeFixes are NuGet packages that perform static analysis on code and can suggest\npotential fixes for a developer.)\nThe concepts are similar, and the end result\nis a data structure that allows examination of the source ode in a meaningful way."},{"content":"However, Expression Trees are based on a totally different set of classes and APIs than the Roslyn APIs.","pos":[1030,1134],"source":" However, Expression\nTrees are based on a totally different set of classes and APIs than the Roslyn APIs."},{"content":"Let's look at a simple example.","pos":[1140,1171]},{"content":"Here's a line of code:","pos":[1172,1194],"source":"\nHere's a line of code:"},{"content":"If you were to analyze this as an expression tree, the tree contains several nodes.","pos":[1222,1305]},{"content":"The outermost node is a variable declaration statement with assignment (<ph id=\"ph1\">`var sum = 1 + 2;`</ph>) That outermost node contains several child nodes: a variable declaration, an assignment operator, and an expression representing the right hand side of the equals sign.","pos":[1306,1566],"source":"\nThe outermost node is a variable declaration statement with assignment (`var sum = 1 + 2;`)\nThat outermost node contains several child nodes: a variable declaration, an assignment operator, and an\nexpression representing the right hand side of the equals sign."},{"content":"That expression is further subdivided into expressions that represent the addition operation, and left and right operands of the addition.","pos":[1567,1705],"source":" That expression is further subdivided into\nexpressions that represent the addition operation, and left and right operands of the addition."},{"content":"Let's drill down a bit more into the expressions that make up the right side of the equals sign.","pos":[1707,1803]},{"content":"The expression is <ph id=\"ph1\">`1 + 2`</ph>.","pos":[1804,1830],"source":"\nThe expression is `1 + 2`."},{"content":"That's a binary expression.","pos":[1831,1858]},{"content":"More specifically, it's a binary addition expression.","pos":[1859,1912],"source":" More specifically, it's a binary addition\nexpression."},{"content":"A binary addition expression has two children, representing the left and right nodes of the addition expression.","pos":[1913,2025],"source":" A binary addition expression has two children, representing the left and right nodes\nof the addition expression."},{"content":"Here, both nodes are constant expressions: The left operand is the value <ph id=\"ph1\">`1`</ph>, and the right operand is the value <ph id=\"ph2\">`2`</ph>.","pos":[2026,2143],"source":" Here, both nodes are constant expressions: The left operand is the\nvalue `1`, and the right operand is the value `2`."},{"pos":[2145,2301],"content":"Visually, the entire statement is a tree: You could start at the root node, and travel to each node in the tree to see the code that makes up the statement:","source":"Visually, the entire statement is a tree: You could start at the root node, and travel to\neach node in the tree to see the code that makes up the statement:"},{"pos":[2305,2372],"content":"Variable declaration statement with assignment (<ph id=\"ph1\">`var sum = 1 + 2;`</ph>)","source":"Variable declaration statement with assignment (`var sum = 1 + 2;`)"},{"pos":[2379,2425],"content":"Implicit variable type declaration (<ph id=\"ph1\">`var sum`</ph>)","source":"Implicit variable type declaration (`var sum`)"},{"pos":[2436,2464],"content":"Implicit var keyword (<ph id=\"ph1\">`var`</ph>)","source":"Implicit var keyword (`var`)"},{"pos":[2475,2508],"content":"Variable name declaration (<ph id=\"ph1\">`sum`</ph>)","source":"Variable name declaration (`sum`)"},{"pos":[2515,2540],"content":"Assignment operator (<ph id=\"ph1\">`=`</ph>)","source":"Assignment operator (`=`)"},{"pos":[2547,2583],"content":"Binary addition expression (<ph id=\"ph1\">`1 + 2`</ph>)","source":"Binary addition expression (`1 + 2`)"},{"pos":[2594,2612],"content":"Left operand (<ph id=\"ph1\">`1`</ph>)","source":"Left operand (`1`)"},{"pos":[2623,2646],"content":"Addition operator (<ph id=\"ph1\">`+`</ph>)","source":"Addition operator (`+`)"},{"pos":[2657,2676],"content":"Right operand (<ph id=\"ph1\">`2`</ph>)","source":"Right operand (`2`)"},{"content":"This may look complicated, but it is very powerful.","pos":[2678,2729]},{"content":"Following the same process, you can decompose much more complicated expressions.","pos":[2730,2810],"source":" Following the same process, you can decompose\nmuch more complicated expressions."},{"content":"Consider this expression:","pos":[2811,2836]},{"content":"The expression above is also a variable declaration with an assignment.","pos":[3067,3138]},{"content":"In this instance, the right hand side of the assignment is a much more complicated tree.","pos":[3139,3227],"source":"\nIn this instance, the right hand side of the assignment is a much more complicated tree."},{"content":"I'm not going to decompose this expression, but consider what the different nodes might be.","pos":[3228,3319],"source":"\nI'm not going to decompose this expression, but consider what the different nodes might\nbe."},{"content":"There are method calls using the current object as a receiver, one that has an explicit <ph id=\"ph1\">`this`</ph> receiver, one that does not.","pos":[3320,3443],"source":" There are method calls using the current object as a receiver, one that has an explicit `this`\nreceiver, one that does not."},{"content":"There are method calls using other receiver objects, there are constant arguments of different types.","pos":[3444,3545],"source":" There are method calls using other receiver objects,\nthere are constant arguments of different types."},{"content":"And finally, there is a binary addition operator.","pos":[3546,3595],"source":" And finally, there is a binary\naddition operator."},{"content":"Depending on the return type of <ph id=\"ph1\">`SecretSauceFunction()`</ph> or <ph id=\"ph2\">`MoreSecretSauce()`</ph>, that binary addition operator may be a method call to an overridden addition operator, resolving to a static method call to the binary addition operator defined for a class.","pos":[3596,3850],"source":" Depending on the return type of `SecretSauceFunction()` or\n`MoreSecretSauce()`, that binary addition operator may be a method call to an\noverridden addition operator, resolving to a static method call to the binary \naddition operator defined for a class."},{"content":"Despite this perceived complexity, the expression above creates a tree structure that can be navigated as easily as the first sample.","pos":[3852,3985],"source":"Despite this perceived complexity, the expression above creates a tree structure\nthat can be navigated as easily as the first sample."},{"content":"You can keep traversing child nodes to find leaf nodes in the expression.","pos":[3986,4059],"source":" You can keep traversing\nchild nodes to find leaf nodes in the expression."},{"content":"Parent nodes will have references to their children, and each node has a property that describes what kind of node it is.","pos":[4060,4181],"source":" Parent nodes will have\nreferences to their children, and each node has a property that describes\nwhat kind of node it is."},{"content":"The structure of an expression tree is very consistent.","pos":[4183,4238]},{"content":"Once you've learned the basics, you can understand even the most complex code when it is represented as an expression tree.","pos":[4239,4362],"source":" Once you've learned\nthe basics, you can understand even the most complex code when it is represented\nas an expression tree."},{"content":"The elegance in the data structure explains how the C# compiler can analyze the most complex C# programs and create proper output from that complicated source code.","pos":[4363,4527],"source":" The elegance in\nthe data structure explains how the C# compiler can analyze the most complex\nC# programs and create proper output from that complicated source code."},{"content":"Once you become familiar with the structure of expression trees, you will find that knowledge you've gained quickly enables you to work with many more and more advanced scenarios.","pos":[4529,4708],"source":"Once you become familiar with the structure of expression trees, you will\nfind that knowledge you've gained quickly enables you to work with many\nmore and more advanced scenarios."},{"content":"There is incredible power to expression trees.","pos":[4709,4755],"source":" There is incredible power to expression\ntrees."},{"content":"In addition to translating algorithms to execute in other environments, expression trees can be used to make it easier to write algorithms that inspect code before executing it.","pos":[4757,4934],"source":"In addition to translating algorithms to execute in other environments,\nexpression trees can be used to make it easier to write algorithms that inspect\ncode before executing it."},{"content":"You can write a method whose arguments are expressions and then examine those expressions before executing the code.","pos":[4935,5051],"source":" You can write a method whose arguments are expressions\nand then examine those expressions before executing the code."},{"content":"The Expression Tree is a full representation of the code: you can see values of any sub-expression.","pos":[5052,5151],"source":" The Expression Tree\nis a full representation of the code: you can see values of any sub-expression."},{"content":"You can see method and property names.","pos":[5152,5190],"source":"\nYou can see method and property names."},{"content":"You can see the value of any constant expressions.","pos":[5191,5241]},{"content":"You can also convert an expression tree into an executable delegate, and execute the code.","pos":[5242,5332],"source":"\nYou can also convert an expression tree into an executable delegate, and execute the\ncode."},{"content":"The APIs for Expression Trees enable you to create trees that represent almost any valid code construct.","pos":[5334,5438],"source":"The APIs for Expression Trees enable you to create trees that represent almost any\nvalid code construct."},{"content":"However, to keep things as simple as possible, some C# idioms cannot be created in an expression tree.","pos":[5439,5541],"source":" However, to keep things as simple as possible, some C# idioms\ncannot be created in an expression tree."},{"content":"One example is asynchronous expressions (using the <ph id=\"ph1\">`async`</ph> and <ph id=\"ph2\">`await`</ph> keywords).","pos":[5542,5623],"source":" One example is asynchronous expressions (using\nthe `async` and `await` keywords)."},{"content":"If your needs require asynchronous algorithms, you would need to manipulate the <ph id=\"ph1\">`Task`</ph> objects directly, rather than rely on the compiler support.","pos":[5624,5770],"source":" If your needs require asynchronous algorithms, you would need\nto manipulate the `Task` objects directly, rather than rely on the compiler support."},{"content":"Another is in creating loops.","pos":[5771,5800],"source":" Another\nis in creating loops."},{"content":"Typically, you create these by using <ph id=\"ph1\">`for`</ph>, <ph id=\"ph2\">`foreach`</ph>, <ph id=\"ph3\">`while`</ph> or <ph id=\"ph4\">`do`</ph> loops.","pos":[5801,5878],"source":" Typically, you create these by using `for`, `foreach`, `while` or `do`\nloops."},{"content":"As you'll see <bpt id=\"p1\">[</bpt>later in this series<ept id=\"p1\">](expression-trees-building.md)</ept>, the APIs for expression trees support a single loop expression, with <ph id=\"ph1\">`break`</ph> and <ph id=\"ph2\">`continue`</ph> expressions that control repeating the loop.","pos":[5879,6083],"source":" As you'll see [later in this series](expression-trees-building.md), the APIs for\nexpression trees support a single loop expression, with `break` and `continue` expressions that\ncontrol repeating the loop."},{"content":"The one thing you can't do is modify an expression tree.","pos":[6085,6141]},{"content":"Expression Trees are immutable data structures.","pos":[6143,6190],"source":"  Expression Trees are immutable\ndata structures."},{"content":"If you want to mutate (change) an expression tree, you must create a new tree that is a copy of the original, but with your desired changes.","pos":[6191,6331],"source":" If you want to mutate (change) an expression tree, you must create a new tree\nthat is a copy of the original, but with your desired changes."},{"content":"Next -- Framework Types Supporting Expression Trees","pos":[6335,6386]}],"content":"---\ntitle: Expression Trees Explained\ndescription: Expression Trees Explained\nkeywords: .NET, .NET Core\nauthor: BillWagner\nmanager: wpickett\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: bbcdd339-86eb-4ae5-9911-4c214a39a92d\n---\n\n# Expression Trees Explained\n\n[Previous -- Overview](expression-trees.md)\n\nAn Expression Tree is a data structure that defines code. They are based on the same structures\nthat a compiler uses to analyze code and generate the compiled output. As you read through this\ntutorial, you will notice quite a bit of similarity between Expression Trees and the types used\nin the Roslyn APIs to build [Analyzers and CodeFixes](https://github.com/dotnet/roslyn-analyzers).\n(Analyzers and CodeFixes are NuGet packages that perform static analysis on code and can suggest\npotential fixes for a developer.)\nThe concepts are similar, and the end result\nis a data structure that allows examination of the source ode in a meaningful way. However, Expression\nTrees are based on a totally different set of classes and APIs than the Roslyn APIs.\n    \nLet's look at a simple example.\nHere's a line of code:\n```cs\nvar sum = 1 + 2;\n```\nIf you were to analyze this as an expression tree, the tree contains several nodes.\nThe outermost node is a variable declaration statement with assignment (`var sum = 1 + 2;`)\nThat outermost node contains several child nodes: a variable declaration, an assignment operator, and an\nexpression representing the right hand side of the equals sign. That expression is further subdivided into\nexpressions that represent the addition operation, and left and right operands of the addition.\n\nLet's drill down a bit more into the expressions that make up the right side of the equals sign.\nThe expression is `1 + 2`. That's a binary expression. More specifically, it's a binary addition\nexpression. A binary addition expression has two children, representing the left and right nodes\nof the addition expression. Here, both nodes are constant expressions: The left operand is the\nvalue `1`, and the right operand is the value `2`.\n\nVisually, the entire statement is a tree: You could start at the root node, and travel to\neach node in the tree to see the code that makes up the statement:\n\n- Variable declaration statement with assignment (`var sum = 1 + 2;`)\n    * Implicit variable type declaration (`var sum`)\n        - Implicit var keyword (`var`)\n        - Variable name declaration (`sum`)\n    * Assignment operator (`=`)\n    * Binary addition expression (`1 + 2`)\n        - Left operand (`1`)\n        - Addition operator (`+`)\n        - Right operand (`2`)\n\nThis may look complicated, but it is very powerful. Following the same process, you can decompose\nmuch more complicated expressions. Consider this expression:\n```cs\nvar finalAnswer = this.SecretSauceFuncion(\n    currentState.createInterimResult(), currentState.createSecondValue(1, 2),\n    decisionServer.considerFinalOptions(\"hello\")) +\n    MoreSecretSauce('A', DateTime.Now, true);\n```\n\nThe expression above is also a variable declaration with an assignment.\nIn this instance, the right hand side of the assignment is a much more complicated tree.\nI'm not going to decompose this expression, but consider what the different nodes might\nbe. There are method calls using the current object as a receiver, one that has an explicit `this`\nreceiver, one that does not. There are method calls using other receiver objects,\nthere are constant arguments of different types. And finally, there is a binary\naddition operator. Depending on the return type of `SecretSauceFunction()` or\n`MoreSecretSauce()`, that binary addition operator may be a method call to an\noverridden addition operator, resolving to a static method call to the binary \naddition operator defined for a class.\n\nDespite this perceived complexity, the expression above creates a tree structure\nthat can be navigated as easily as the first sample. You can keep traversing\nchild nodes to find leaf nodes in the expression. Parent nodes will have\nreferences to their children, and each node has a property that describes\nwhat kind of node it is.\n\nThe structure of an expression tree is very consistent. Once you've learned\nthe basics, you can understand even the most complex code when it is represented\nas an expression tree. The elegance in\nthe data structure explains how the C# compiler can analyze the most complex\nC# programs and create proper output from that complicated source code.\n\nOnce you become familiar with the structure of expression trees, you will\nfind that knowledge you've gained quickly enables you to work with many\nmore and more advanced scenarios. There is incredible power to expression\ntrees.\n\nIn addition to translating algorithms to execute in other environments,\nexpression trees can be used to make it easier to write algorithms that inspect\ncode before executing it. You can write a method whose arguments are expressions\nand then examine those expressions before executing the code. The Expression Tree\nis a full representation of the code: you can see values of any sub-expression.\nYou can see method and property names. You can see the value of any constant expressions.\nYou can also convert an expression tree into an executable delegate, and execute the\ncode.\n\nThe APIs for Expression Trees enable you to create trees that represent almost any\nvalid code construct. However, to keep things as simple as possible, some C# idioms\ncannot be created in an expression tree. One example is asynchronous expressions (using\nthe `async` and `await` keywords). If your needs require asynchronous algorithms, you would need\nto manipulate the `Task` objects directly, rather than rely on the compiler support. Another\nis in creating loops. Typically, you create these by using `for`, `foreach`, `while` or `do`\nloops. As you'll see [later in this series](expression-trees-building.md), the APIs for\nexpression trees support a single loop expression, with `break` and `continue` expressions that\ncontrol repeating the loop.\n\nThe one thing you can't do is modify an expression tree.  Expression Trees are immutable\ndata structures. If you want to mutate (change) an expression tree, you must create a new tree\nthat is a copy of the original, but with your desired changes. \n\n[Next -- Framework Types Supporting Expression Trees](expression-classes.md)\n"}