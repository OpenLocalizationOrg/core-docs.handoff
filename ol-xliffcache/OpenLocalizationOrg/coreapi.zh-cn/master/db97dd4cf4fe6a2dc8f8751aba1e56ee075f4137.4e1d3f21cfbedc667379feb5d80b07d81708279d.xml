{"nodes":[{"pos":[945,974],"content":"OrderablePartitioner<TSource>","needQuote":true,"nodes":[{"content":"OrderablePartitioner&lt;TSource&gt;","pos":[0,29],"source":"OrderablePartitioner<TSource>"}]},{"content":"\\n&lt;p&gt;Type of the elements in the collection.&lt;/p&gt;\\n","pos":[2012,2062],"source":"\\n<p>Type of the elements in the collection.</p>\\n"},{"pos":[3248,3295],"content":"OrderablePartitioner(Boolean, Boolean, Boolean)","needQuote":true,"nodes":[{"content":"OrderablePartitioner(Boolean, Boolean, Boolean)","pos":[0,47]}]},{"content":"\\n&lt;p&gt;Indicates whether the elements in each partition are yielded in the order of increasing keys.&lt;/p&gt;\\n","pos":[4474,4578],"source":"\\n<p>Indicates whether the elements in each partition are yielded in the order of increasing keys.</p>\\n"},{"content":"\\n&lt;p&gt;Indicates whether elements in an earlier partition always come before elements in a later partition.","pos":[4665,4770],"source":"\\n<p>Indicates whether elements in an earlier partition always come before elements in a later partition."},{"content":"If true, each element in partition 0 has a smaller order key than any element in partition 1, each element in partition 1 has a smaller order key than any element in partition 2, and so on.&lt;/p&gt;\\n","pos":[4771,4966],"source":" If true, each element in partition 0 has a smaller order key than any element in partition 1, each element in partition 1 has a smaller order key than any element in partition 2, and so on.</p>\\n"},{"content":"\\n&lt;p&gt;Indicates whether keys are normalized.","pos":[5040,5083],"source":"\\n<p>Indicates whether keys are normalized."},{"content":"If true, all order keys are distinct integers in the range [0 ..","pos":[5084,5148]},{"content":"numberOfElements-1].","pos":[5149,5169]},{"content":"If false, order keys must still be distinct, but only their relative order is considered, not their absolute values.&lt;/p&gt;\\n","pos":[5170,5292],"source":" If false, order keys must still be distinct, but only their relative order is considered, not their absolute values.</p>\\n"},{"pos":[5976,5990],"content":"KeysNormalized","needQuote":true,"nodes":[{"content":"KeysNormalized","pos":[0,14]}]},{"content":"\\n&lt;p&gt;true if the keys are normalized; otherwise false.&lt;/p&gt;\\n","pos":[6753,6813],"source":"\\n<p>true if the keys are normalized; otherwise false.</p>\\n"},{"pos":[7431,7458],"content":"KeysOrderedAcrossPartitions","needQuote":true,"nodes":[{"content":"KeysOrderedAcrossPartitions","pos":[0,27]}]},{"content":"\\n&lt;p&gt;true if the elements in an earlier partition always come before elements in a later partition; otherwise false.&lt;/p&gt;\\n","pos":[8329,8451],"source":"\\n<p>true if the elements in an earlier partition always come before elements in a later partition; otherwise false.</p>\\n"},{"pos":[9105,9131],"content":"KeysOrderedInEachPartition","needQuote":true,"nodes":[{"content":"KeysOrderedInEachPartition","pos":[0,26]}]},{"content":"\\n&lt;p&gt;true if the elements in each partition are yielded in the order of increasing keys; otherwise false.&lt;/p&gt;\\n","pos":[9987,10098],"source":"\\n<p>true if the elements in each partition are yielded in the order of increasing keys; otherwise false.</p>\\n"},{"pos":[10731,10753],"content":"GetDynamicPartitions()","needQuote":true,"nodes":[{"content":"GetDynamicPartitions()","pos":[0,22]}]},{"content":"\\n&lt;p&gt;An object that can create partitions over the underlying data source.&lt;/p&gt;\\n","pos":[11652,11732],"source":"\\n<p>An object that can create partitions over the underlying data source.</p>\\n"},{"content":"\\n&lt;p&gt;Dynamic partitioning is not supported by the base class.","pos":[11939,12000],"source":"\\n<p>Dynamic partitioning is not supported by the base class."},{"content":"It must be implemented in derived classes.&lt;/p&gt;\\n","pos":[12001,12049],"source":" It must be implemented in derived classes.</p>\\n"},{"pos":[12703,12734],"content":"GetOrderableDynamicPartitions()","needQuote":true,"nodes":[{"content":"GetOrderableDynamicPartitions()","pos":[0,31]}]},{"content":"\\n&lt;p&gt;An object that can create partitions over the underlying data source.&lt;/p&gt;\\n","pos":[13767,13847],"source":"\\n<p>An object that can create partitions over the underlying data source.</p>\\n"},{"content":"\\n&lt;p&gt;Dynamic partitioning is not supported by this partitioner.&lt;/p&gt;\\n","pos":[13966,14035],"source":"\\n<p>Dynamic partitioning is not supported by this partitioner.</p>\\n"},{"pos":[14738,14767],"content":"GetOrderablePartitions(Int32)","needQuote":true,"nodes":[{"content":"GetOrderablePartitions(Int32)","pos":[0,29]}]},{"content":"\\n&lt;p&gt;The number of partitions to create.&lt;/p&gt;\\n","pos":[15773,15819],"source":"\\n<p>The number of partitions to create.</p>\\n"},{"content":"\\n&lt;p&gt;A list containing &lt;em&gt;partitionCount&lt;/em&gt; enumerators.&lt;/p&gt;\\n","pos":[16003,16068],"source":"\\n<p>A list containing <em>partitionCount</em> enumerators.</p>\\n"},{"pos":[16747,16767],"content":"GetPartitions(Int32)","needQuote":true,"nodes":[{"content":"GetPartitions(Int32)","pos":[0,20]}]},{"content":"\\n&lt;p&gt;The number of partitions to create.&lt;/p&gt;\\n","pos":[17685,17731],"source":"\\n<p>The number of partitions to create.</p>\\n"},{"content":"\\n&lt;p&gt;A list containing &lt;em&gt;partitionCount&lt;/em&gt; enumerators.&lt;/p&gt;\\n","pos":[17861,17926],"source":"\\n<p>A list containing <em>partitionCount</em> enumerators.</p>\\n"},{"pos":[18431,18460],"content":"System.Collections.Concurrent","needQuote":true,"nodes":[{"content":"System.Collections.Concurrent","pos":[0,29]}]},{"pos":[18660,18666],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"pos":[18911,18931],"content":"Partitioner<TSource>","needQuote":true,"nodes":[{"content":"Partitioner&lt;TSource&gt;","pos":[0,20],"source":"Partitioner<TSource>"}]},{"pos":[19177,19188],"content":"Partitioner","needQuote":true,"nodes":[{"content":"Partitioner","pos":[0,11]}]},{"pos":[19255,19256],"content":"<","needQuote":true,"nodes":[]},{"pos":[19283,19290],"content":"TSource","needQuote":true,"nodes":[{"content":"TSource","pos":[0,7]}]},{"pos":[19419,19430],"content":"Partitioner","needQuote":true,"nodes":[{"content":"Partitioner","pos":[0,11]}]},{"content":"(Of","pos":[19498,19501]},{"pos":[19535,19542],"content":"TSource","needQuote":true,"nodes":[{"content":"TSource","pos":[0,7]}]},{"pos":[19575,19576],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[19976,20001],"content":"SupportsDynamicPartitions","needQuote":true,"nodes":[{"content":"SupportsDynamicPartitions","pos":[0,25]}]},{"pos":[20486,20496],"content":"ToString()","needQuote":true,"nodes":[{"content":"ToString()","pos":[0,10]}]},{"pos":[20591,20599],"content":"ToString","needQuote":true,"nodes":[{"content":"ToString","pos":[0,8]}]},{"pos":[20668,20669],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[20696,20697],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[20767,20775],"content":"ToString","needQuote":true,"nodes":[{"content":"ToString","pos":[0,8]}]},{"pos":[20844,20845],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[20872,20873],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[21056,21070],"content":"Equals(Object)","needQuote":true,"nodes":[{"content":"Equals(Object)","pos":[0,14]}]},{"pos":[21189,21195],"content":"Equals","needQuote":true,"nodes":[{"content":"Equals","pos":[0,6]}]},{"pos":[21262,21263],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[21313,21319],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"pos":[21379,21380],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[21463,21469],"content":"Equals","needQuote":true,"nodes":[{"content":"Equals","pos":[0,6]}]},{"pos":[21536,21537],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[21587,21593],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"pos":[21653,21654],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[21868,21890],"content":"Equals(Object, Object)","needQuote":true,"nodes":[{"content":"Equals(Object, Object)","pos":[0,22]}]},{"pos":[22038,22044],"content":"Equals","needQuote":true,"nodes":[{"content":"Equals","pos":[0,6]}]},{"pos":[22111,22112],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[22162,22168],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"content":",","pos":[22229,22230]},{"pos":[22285,22291],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"pos":[22351,22352],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[22449,22455],"content":"Equals","needQuote":true,"nodes":[{"content":"Equals","pos":[0,6]}]},{"pos":[22522,22523],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[22573,22579],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"content":",","pos":[22640,22641]},{"pos":[22696,22702],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"pos":[22762,22763],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[23008,23039],"content":"ReferenceEquals(Object, Object)","needQuote":true,"nodes":[{"content":"ReferenceEquals(Object, Object)","pos":[0,31]}]},{"pos":[23205,23220],"content":"ReferenceEquals","needQuote":true,"nodes":[{"content":"ReferenceEquals","pos":[0,15]}]},{"pos":[23296,23297],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[23347,23353],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"content":",","pos":[23414,23415]},{"pos":[23470,23476],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"pos":[23536,23537],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[23643,23658],"content":"ReferenceEquals","needQuote":true,"nodes":[{"content":"ReferenceEquals","pos":[0,15]}]},{"pos":[23734,23735],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[23785,23791],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"content":",","pos":[23852,23853]},{"pos":[23908,23914],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"pos":[23974,23975],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[24205,24218],"content":"GetHashCode()","needQuote":true,"nodes":[{"content":"GetHashCode()","pos":[0,13]}]},{"pos":[24319,24330],"content":"GetHashCode","needQuote":true,"nodes":[{"content":"GetHashCode","pos":[0,11]}]},{"pos":[24402,24403],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[24430,24431],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[24504,24515],"content":"GetHashCode","needQuote":true,"nodes":[{"content":"GetHashCode","pos":[0,11]}]},{"pos":[24587,24588],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[24615,24616],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[24791,24800],"content":"GetType()","needQuote":true,"nodes":[{"content":"GetType()","pos":[0,9]}]},{"pos":[24893,24900],"content":"GetType","needQuote":true,"nodes":[{"content":"GetType","pos":[0,7]}]},{"pos":[24968,24969],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[24996,24997],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[25066,25073],"content":"GetType","needQuote":true,"nodes":[{"content":"GetType","pos":[0,7]}]},{"pos":[25141,25142],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[25169,25170],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[25345,25362],"content":"MemberwiseClone()","needQuote":true,"nodes":[{"content":"MemberwiseClone()","pos":[0,17]}]},{"pos":[25471,25486],"content":"MemberwiseClone","needQuote":true,"nodes":[{"content":"MemberwiseClone","pos":[0,15]}]},{"pos":[25562,25563],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[25590,25591],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[25668,25683],"content":"MemberwiseClone","needQuote":true,"nodes":[{"content":"MemberwiseClone","pos":[0,15]}]},{"pos":[25759,25760],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[25787,25788],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[25933,25939],"content":"System","needQuote":true,"nodes":[{"content":"System","pos":[0,6]}]},{"pos":[26083,26103],"content":"Partitioner<TSource>","needQuote":true,"nodes":[{"content":"Partitioner&lt;TSource&gt;","pos":[0,20],"source":"Partitioner<TSource>"}]},{"pos":[26349,26360],"content":"Partitioner","needQuote":true,"nodes":[{"content":"Partitioner","pos":[0,11]}]},{"pos":[26427,26428],"content":"<","needQuote":true,"nodes":[]},{"pos":[26455,26462],"content":"TSource","needQuote":true,"nodes":[{"content":"TSource","pos":[0,7]}]},{"pos":[26591,26602],"content":"Partitioner","needQuote":true,"nodes":[{"content":"Partitioner","pos":[0,11]}]},{"content":"(Of","pos":[26670,26673]},{"pos":[26707,26714],"content":"TSource","needQuote":true,"nodes":[{"content":"TSource","pos":[0,7]}]},{"pos":[26747,26748],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[27009,27034],"content":"SupportsDynamicPartitions","needQuote":true,"nodes":[{"content":"SupportsDynamicPartitions","pos":[0,25]}]},{"pos":[27503,27510],"content":"Boolean","needQuote":true,"nodes":[{"content":"Boolean","pos":[0,7]}]},{"pos":[27823,27845],"content":"GetDynamicPartitions()","needQuote":true,"nodes":[{"content":"GetDynamicPartitions()","pos":[0,22]}]},{"pos":[28123,28143],"content":"GetDynamicPartitions","needQuote":true,"nodes":[{"content":"GetDynamicPartitions","pos":[0,20]}]},{"pos":[28240,28241],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[28268,28269],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[28381,28401],"content":"GetDynamicPartitions","needQuote":true,"nodes":[{"content":"GetDynamicPartitions","pos":[0,20]}]},{"pos":[28501,28502],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[28529,28530],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[28912,28932],"content":"IEnumerable<TSource>","needQuote":true,"nodes":[{"content":"IEnumerable&lt;TSource&gt;","pos":[0,20],"source":"IEnumerable<TSource>"}]},{"pos":[29169,29180],"content":"IEnumerable","needQuote":true,"nodes":[{"content":"IEnumerable","pos":[0,11]}]},{"pos":[29265,29266],"content":"<","needQuote":true,"nodes":[]},{"pos":[29293,29300],"content":"TSource","needQuote":true,"nodes":[{"content":"TSource","pos":[0,7]}]},{"pos":[29426,29437],"content":"IEnumerable","needQuote":true,"nodes":[{"content":"IEnumerable","pos":[0,11]}]},{"content":"(Of","pos":[29523,29526]},{"pos":[29560,29567],"content":"TSource","needQuote":true,"nodes":[{"content":"TSource","pos":[0,7]}]},{"pos":[29600,29601],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[29857,29879],"content":"GetDynamicPartitions()","needQuote":true,"nodes":[{"content":"GetDynamicPartitions()","pos":[0,22]}]},{"pos":[30157,30177],"content":"GetDynamicPartitions","needQuote":true,"nodes":[{"content":"GetDynamicPartitions","pos":[0,20]}]},{"pos":[30274,30275],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[30302,30303],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[30415,30435],"content":"GetDynamicPartitions","needQuote":true,"nodes":[{"content":"GetDynamicPartitions","pos":[0,20]}]},{"pos":[30535,30536],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[30563,30564],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[30863,30877],"content":"IEnumerable<T>","needQuote":true,"nodes":[{"content":"IEnumerable&lt;T&gt;","pos":[0,14],"source":"IEnumerable<T>"}]},{"pos":[31096,31107],"content":"IEnumerable","needQuote":true,"nodes":[{"content":"IEnumerable","pos":[0,11]}]},{"pos":[31171,31172],"content":"<","needQuote":true,"nodes":[]},{"pos":[31199,31200],"content":"T","needQuote":true,"nodes":[{"content":"T","pos":[0,1]}]},{"pos":[31320,31331],"content":"IEnumerable","needQuote":true,"nodes":[{"content":"IEnumerable","pos":[0,11]}]},{"content":"(Of","pos":[31396,31399]},{"pos":[31433,31434],"content":"T","needQuote":true,"nodes":[{"content":"T","pos":[0,1]}]},{"pos":[31461,31462],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[31665,31691],"content":"System.Collections.Generic","needQuote":true,"nodes":[{"content":"System.Collections.Generic","pos":[0,26]}]},{"pos":[32027,32068],"content":"IEnumerable<KeyValuePair<Int64, TSource>>","needQuote":true,"nodes":[{"content":"IEnumerable&lt;KeyValuePair&lt;Int64, TSource&gt;&gt;","pos":[0,41],"source":"IEnumerable<KeyValuePair<Int64, TSource>>"}]},{"pos":[32442,32453],"content":"IEnumerable","needQuote":true,"nodes":[{"content":"IEnumerable","pos":[0,11]}]},{"pos":[32538,32539],"content":"<","needQuote":true,"nodes":[]},{"pos":[32617,32629],"content":"KeyValuePair","needQuote":true,"nodes":[{"content":"KeyValuePair","pos":[0,12]}]},{"pos":[32715,32716],"content":"<","needQuote":true,"nodes":[]},{"pos":[32765,32770],"content":"Int64","needQuote":true,"nodes":[{"content":"Int64","pos":[0,5]}]},{"content":",","pos":[32830,32831]},{"pos":[32863,32870],"content":"TSource","needQuote":true,"nodes":[{"content":"TSource","pos":[0,7]}]},{"pos":[33028,33039],"content":"IEnumerable","needQuote":true,"nodes":[{"content":"IEnumerable","pos":[0,11]}]},{"content":"(Of","pos":[33125,33128]},{"pos":[33213,33225],"content":"KeyValuePair","needQuote":true,"nodes":[{"content":"KeyValuePair","pos":[0,12]}]},{"content":"(Of","pos":[33312,33315]},{"pos":[33371,33376],"content":"Int64","needQuote":true,"nodes":[{"content":"Int64","pos":[0,5]}]},{"content":",","pos":[33436,33437]},{"pos":[33469,33476],"content":"TSource","needQuote":true,"nodes":[{"content":"TSource","pos":[0,7]}]},{"pos":[33509,33510],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[33537,33538],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[33857,33862],"content":"Int32","needQuote":true,"nodes":[{"content":"Int32","pos":[0,5]}]},{"pos":[34177,34225],"content":"IList<IEnumerator<KeyValuePair<Int64, TSource>>>","needQuote":true,"nodes":[{"content":"IList&lt;IEnumerator&lt;KeyValuePair&lt;Int64, TSource&gt;&gt;&gt;","pos":[0,48],"source":"IList<IEnumerator<KeyValuePair<Int64, TSource>>>"}]},{"pos":[34674,34679],"content":"IList","needQuote":true,"nodes":[{"content":"IList","pos":[0,5]}]},{"pos":[34758,34759],"content":"<","needQuote":true,"nodes":[]},{"pos":[34836,34847],"content":"IEnumerator","needQuote":true,"nodes":[{"content":"IEnumerator","pos":[0,11]}]},{"pos":[34932,34933],"content":"<","needQuote":true,"nodes":[]},{"pos":[35011,35023],"content":"KeyValuePair","needQuote":true,"nodes":[{"content":"KeyValuePair","pos":[0,12]}]},{"pos":[35109,35110],"content":"<","needQuote":true,"nodes":[]},{"pos":[35159,35164],"content":"Int64","needQuote":true,"nodes":[{"content":"Int64","pos":[0,5]}]},{"content":",","pos":[35224,35225]},{"pos":[35257,35264],"content":"TSource","needQuote":true,"nodes":[{"content":"TSource","pos":[0,7]}]},{"pos":[35448,35453],"content":"IList","needQuote":true,"nodes":[{"content":"IList","pos":[0,5]}]},{"content":"(Of","pos":[35533,35536]},{"pos":[35620,35631],"content":"IEnumerator","needQuote":true,"nodes":[{"content":"IEnumerator","pos":[0,11]}]},{"content":"(Of","pos":[35717,35720]},{"pos":[35805,35817],"content":"KeyValuePair","needQuote":true,"nodes":[{"content":"KeyValuePair","pos":[0,12]}]},{"content":"(Of","pos":[35904,35907]},{"pos":[35963,35968],"content":"Int64","needQuote":true,"nodes":[{"content":"Int64","pos":[0,5]}]},{"content":",","pos":[36028,36029]},{"pos":[36061,36068],"content":"TSource","needQuote":true,"nodes":[{"content":"TSource","pos":[0,7]}]},{"pos":[36101,36102],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[36129,36130],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[36157,36158],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[36533,36541],"content":"IList<T>","needQuote":true,"nodes":[{"content":"IList&lt;T&gt;","pos":[0,8],"source":"IList<T>"}]},{"pos":[36736,36741],"content":"IList","needQuote":true,"nodes":[{"content":"IList","pos":[0,5]}]},{"pos":[36799,36800],"content":"<","needQuote":true,"nodes":[]},{"pos":[36827,36828],"content":"T","needQuote":true,"nodes":[{"content":"T","pos":[0,1]}]},{"pos":[36942,36947],"content":"IList","needQuote":true,"nodes":[{"content":"IList","pos":[0,5]}]},{"content":"(Of","pos":[37006,37009]},{"pos":[37043,37044],"content":"T","needQuote":true,"nodes":[{"content":"T","pos":[0,1]}]},{"pos":[37071,37072],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[37440,37460],"content":"GetPartitions(Int32)","needQuote":true,"nodes":[{"content":"GetPartitions(Int32)","pos":[0,20]}]},{"pos":[37755,37768],"content":"GetPartitions","needQuote":true,"nodes":[{"content":"GetPartitions","pos":[0,13]}]},{"pos":[37858,37859],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[37908,37913],"content":"Int32","needQuote":true,"nodes":[{"content":"Int32","pos":[0,5]}]},{"pos":[37972,37973],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[38092,38105],"content":"GetPartitions","needQuote":true,"nodes":[{"content":"GetPartitions","pos":[0,13]}]},{"pos":[38198,38199],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[38248,38253],"content":"Int32","needQuote":true,"nodes":[{"content":"Int32","pos":[0,5]}]},{"pos":[38312,38313],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[38726,38753],"content":"IList<IEnumerator<TSource>>","needQuote":true,"nodes":[{"content":"IList&lt;IEnumerator&lt;TSource&gt;&gt;","pos":[0,27],"source":"IList<IEnumerator<TSource>>"}]},{"pos":[39065,39070],"content":"IList","needQuote":true,"nodes":[{"content":"IList","pos":[0,5]}]},{"pos":[39149,39150],"content":"<","needQuote":true,"nodes":[]},{"pos":[39227,39238],"content":"IEnumerator","needQuote":true,"nodes":[{"content":"IEnumerator","pos":[0,11]}]},{"pos":[39323,39324],"content":"<","needQuote":true,"nodes":[]},{"pos":[39351,39358],"content":"TSource","needQuote":true,"nodes":[{"content":"TSource","pos":[0,7]}]},{"pos":[39510,39515],"content":"IList","needQuote":true,"nodes":[{"content":"IList","pos":[0,5]}]},{"content":"(Of","pos":[39595,39598]},{"pos":[39682,39693],"content":"IEnumerator","needQuote":true,"nodes":[{"content":"IEnumerator","pos":[0,11]}]},{"content":"(Of","pos":[39779,39782]},{"pos":[39816,39823],"content":"TSource","needQuote":true,"nodes":[{"content":"TSource","pos":[0,7]}]},{"pos":[39856,39857],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[39884,39885],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[40197,40217],"content":"GetPartitions(Int32)","needQuote":true,"nodes":[{"content":"GetPartitions(Int32)","pos":[0,20]}]},{"pos":[40512,40525],"content":"GetPartitions","needQuote":true,"nodes":[{"content":"GetPartitions","pos":[0,13]}]},{"pos":[40615,40616],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[40665,40670],"content":"Int32","needQuote":true,"nodes":[{"content":"Int32","pos":[0,5]}]},{"pos":[40729,40730],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[40849,40862],"content":"GetPartitions","needQuote":true,"nodes":[{"content":"GetPartitions","pos":[0,13]}]},{"pos":[40955,40956],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[41005,41010],"content":"Int32","needQuote":true,"nodes":[{"content":"Int32","pos":[0,5]}]},{"pos":[41069,41070],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[41377,41398],"content":"NotSupportedException","needQuote":true,"nodes":[{"content":"NotSupportedException","pos":[0,21]}]}],"content":"items:\n- uid: System.Collections.Concurrent.OrderablePartitioner`1\n  commentId: T:System.Collections.Concurrent.OrderablePartitioner`1\n  id: OrderablePartitioner`1\n  parent: System.Collections.Concurrent\n  children:\n  - System.Collections.Concurrent.OrderablePartitioner`1.#ctor(System.Boolean,System.Boolean,System.Boolean)\n  - System.Collections.Concurrent.OrderablePartitioner`1.GetDynamicPartitions\n  - System.Collections.Concurrent.OrderablePartitioner`1.GetOrderableDynamicPartitions\n  - System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)\n  - System.Collections.Concurrent.OrderablePartitioner`1.GetPartitions(System.Int32)\n  - System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized\n  - System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedAcrossPartitions\n  - System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedInEachPartition\n  langs:\n  - csharp\n  - vb\n  name: OrderablePartitioner<TSource>\n  fullName: System.Collections.Concurrent.OrderablePartitioner<TSource>\n  type: Class\n  source:\n    remote:\n      path: src/mscorlib/src/System/Collections/Concurrent/OrderablePartitioner.cs\n      branch: master\n      repo: https://github.com/dotnet/coreclr.git\n    id: OrderablePartitioner\n    path: src/mscorlib/src/System/Collections/Concurrent/OrderablePartitioner.cs\n    startLine: 63\n  assemblies:\n  - System.Collections.Concurrent\n  namespace: System.Collections.Concurrent\n  summary: \"\\n<p>Represents a particular manner of splitting an orderable data source into multiple partitions.</p>\\n\"\n  syntax:\n    content: >-\n      [HostProtection(Synchronization = true, ExternalThreading = true)]\n\n      public abstract class OrderablePartitioner<TSource> : Partitioner<TSource>\n    content.vb: >-\n      <HostProtection(Synchronization:=True, ExternalThreading:=True)>\n\n      Public MustInherit Class OrderablePartitioner(Of TSource)\n          Inherits Partitioner(Of TSource)\n    typeParameters:\n    - id: TSource\n      description: \"\\n<p>Type of the elements in the collection.</p>\\n\"\n  inheritance:\n  - System.Object\n  - System.Collections.Concurrent.Partitioner{{TSource}}\n  inheritedMembers:\n  - System.Collections.Concurrent.Partitioner{{TSource}}.SupportsDynamicPartitions\n  - System.Object.ToString\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  modifiers.csharp:\n  - public\n  - abstract\n  - class\n  modifiers.vb:\n  - Public\n  - MustInherit\n  - Class\n  fullName.vb: System.Collections.Concurrent.OrderablePartitioner(Of TSource)\n  name.vb: OrderablePartitioner(Of TSource)\n  nameWithType: OrderablePartitioner<TSource>\n  nameWithType.vb: OrderablePartitioner(Of TSource)\n- uid: System.Collections.Concurrent.OrderablePartitioner`1.#ctor(System.Boolean,System.Boolean,System.Boolean)\n  commentId: M:System.Collections.Concurrent.OrderablePartitioner`1.#ctor(System.Boolean,System.Boolean,System.Boolean)\n  id: '#ctor(System.Boolean,System.Boolean,System.Boolean)'\n  parent: System.Collections.Concurrent.OrderablePartitioner`1\n  langs:\n  - csharp\n  - vb\n  name: OrderablePartitioner(Boolean, Boolean, Boolean)\n  fullName: System.Collections.Concurrent.OrderablePartitioner<TSource>.OrderablePartitioner(System.Boolean, System.Boolean, System.Boolean)\n  type: Constructor\n  source:\n    remote:\n      path: src/mscorlib/src/System/Collections/Concurrent/OrderablePartitioner.cs\n      branch: master\n      repo: https://github.com/dotnet/coreclr.git\n    id: .ctor\n    path: src/mscorlib/src/System/Collections/Concurrent/OrderablePartitioner.cs\n    startLine: 85\n  assemblies:\n  - System.Collections.Concurrent\n  namespace: System.Collections.Concurrent\n  summary: \"\\n<p>Called from constructors in derived classes to initialize the <xref href=\\\"System.Collections.Concurrent.OrderablePartitioner`1\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> class with the specified constraints on the index keys.</p>\\n\"\n  syntax:\n    content: protected OrderablePartitioner(bool keysOrderedInEachPartition, bool keysOrderedAcrossPartitions, bool keysNormalized)\n    content.vb: Protected Sub New(keysOrderedInEachPartition As Boolean, keysOrderedAcrossPartitions As Boolean, keysNormalized As Boolean)\n    parameters:\n    - id: keysOrderedInEachPartition\n      type: System.Boolean\n      description: \"\\n<p>Indicates whether the elements in each partition are yielded in the order of increasing keys.</p>\\n\"\n    - id: keysOrderedAcrossPartitions\n      type: System.Boolean\n      description: \"\\n<p>Indicates whether elements in an earlier partition always come before elements in a later partition. If true, each element in partition 0 has a smaller order key than any element in partition 1, each element in partition 1 has a smaller order key than any element in partition 2, and so on.</p>\\n\"\n    - id: keysNormalized\n      type: System.Boolean\n      description: \"\\n<p>Indicates whether keys are normalized. If true, all order keys are distinct integers in the range [0 .. numberOfElements-1]. If false, order keys must still be distinct, but only their relative order is considered, not their absolute values.</p>\\n\"\n  modifiers.csharp:\n  - protected\n  modifiers.vb:\n  - Protected\n  fullName.vb: System.Collections.Concurrent.OrderablePartitioner(Of TSource).OrderablePartitioner(System.Boolean, System.Boolean, System.Boolean)\n  nameWithType: OrderablePartitioner<TSource>.OrderablePartitioner(Boolean, Boolean, Boolean)\n  nameWithType.vb: OrderablePartitioner(Of TSource).OrderablePartitioner(Boolean, Boolean, Boolean)\n- uid: System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized\n  commentId: P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized\n  id: KeysNormalized\n  parent: System.Collections.Concurrent.OrderablePartitioner`1\n  langs:\n  - csharp\n  - vb\n  name: KeysNormalized\n  fullName: System.Collections.Concurrent.OrderablePartitioner<TSource>.KeysNormalized\n  type: Property\n  source:\n    remote:\n      path: src/mscorlib/src/System/Collections/Concurrent/OrderablePartitioner.cs\n      branch: master\n      repo: https://github.com/dotnet/coreclr.git\n    id: KeysNormalized\n    path: src/mscorlib/src/System/Collections/Concurrent/OrderablePartitioner.cs\n    startLine: 157\n  assemblies:\n  - System.Collections.Concurrent\n  namespace: System.Collections.Concurrent\n  summary: \"\\n<p>Gets whether order keys are normalized.</p>\\n\"\n  syntax:\n    content: public bool KeysNormalized { get; }\n    content.vb: Public ReadOnly Property KeysNormalized As Boolean\n    parameters: []\n    return:\n      type: System.Boolean\n      description: \"\\n<p>true if the keys are normalized; otherwise false.</p>\\n\"\n  modifiers.csharp:\n  - public\n  - get\n  modifiers.vb:\n  - Public\n  - ReadOnly\n  fullName.vb: System.Collections.Concurrent.OrderablePartitioner(Of TSource).KeysNormalized\n  nameWithType: OrderablePartitioner<TSource>.KeysNormalized\n  nameWithType.vb: OrderablePartitioner(Of TSource).KeysNormalized\n- uid: System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedAcrossPartitions\n  commentId: P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedAcrossPartitions\n  id: KeysOrderedAcrossPartitions\n  parent: System.Collections.Concurrent.OrderablePartitioner`1\n  langs:\n  - csharp\n  - vb\n  name: KeysOrderedAcrossPartitions\n  fullName: System.Collections.Concurrent.OrderablePartitioner<TSource>.KeysOrderedAcrossPartitions\n  type: Property\n  source:\n    remote:\n      path: src/mscorlib/src/System/Collections/Concurrent/OrderablePartitioner.cs\n      branch: master\n      repo: https://github.com/dotnet/coreclr.git\n    id: KeysOrderedAcrossPartitions\n    path: src/mscorlib/src/System/Collections/Concurrent/OrderablePartitioner.cs\n    startLine: 147\n  assemblies:\n  - System.Collections.Concurrent\n  namespace: System.Collections.Concurrent\n  summary: \"\\n<p>Gets whether elements in an earlier partition always come before elements in a later partition.</p>\\n\"\n  syntax:\n    content: public bool KeysOrderedAcrossPartitions { get; }\n    content.vb: Public ReadOnly Property KeysOrderedAcrossPartitions As Boolean\n    parameters: []\n    return:\n      type: System.Boolean\n      description: \"\\n<p>true if the elements in an earlier partition always come before elements in a later partition; otherwise false.</p>\\n\"\n  modifiers.csharp:\n  - public\n  - get\n  modifiers.vb:\n  - Public\n  - ReadOnly\n  fullName.vb: System.Collections.Concurrent.OrderablePartitioner(Of TSource).KeysOrderedAcrossPartitions\n  nameWithType: OrderablePartitioner<TSource>.KeysOrderedAcrossPartitions\n  nameWithType.vb: OrderablePartitioner(Of TSource).KeysOrderedAcrossPartitions\n- uid: System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedInEachPartition\n  commentId: P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedInEachPartition\n  id: KeysOrderedInEachPartition\n  parent: System.Collections.Concurrent.OrderablePartitioner`1\n  langs:\n  - csharp\n  - vb\n  name: KeysOrderedInEachPartition\n  fullName: System.Collections.Concurrent.OrderablePartitioner<TSource>.KeysOrderedInEachPartition\n  type: Property\n  source:\n    remote:\n      path: src/mscorlib/src/System/Collections/Concurrent/OrderablePartitioner.cs\n      branch: master\n      repo: https://github.com/dotnet/coreclr.git\n    id: KeysOrderedInEachPartition\n    path: src/mscorlib/src/System/Collections/Concurrent/OrderablePartitioner.cs\n    startLine: 137\n  assemblies:\n  - System.Collections.Concurrent\n  namespace: System.Collections.Concurrent\n  summary: \"\\n<p>Gets whether elements in each partition are yielded in the order of increasing keys.</p>\\n\"\n  syntax:\n    content: public bool KeysOrderedInEachPartition { get; }\n    content.vb: Public ReadOnly Property KeysOrderedInEachPartition As Boolean\n    parameters: []\n    return:\n      type: System.Boolean\n      description: \"\\n<p>true if the elements in each partition are yielded in the order of increasing keys; otherwise false.</p>\\n\"\n  modifiers.csharp:\n  - public\n  - get\n  modifiers.vb:\n  - Public\n  - ReadOnly\n  fullName.vb: System.Collections.Concurrent.OrderablePartitioner(Of TSource).KeysOrderedInEachPartition\n  nameWithType: OrderablePartitioner<TSource>.KeysOrderedInEachPartition\n  nameWithType.vb: OrderablePartitioner(Of TSource).KeysOrderedInEachPartition\n- uid: System.Collections.Concurrent.OrderablePartitioner`1.GetDynamicPartitions\n  commentId: M:System.Collections.Concurrent.OrderablePartitioner`1.GetDynamicPartitions\n  id: GetDynamicPartitions\n  parent: System.Collections.Concurrent.OrderablePartitioner`1\n  langs:\n  - csharp\n  - vb\n  name: GetDynamicPartitions()\n  fullName: System.Collections.Concurrent.OrderablePartitioner<TSource>.GetDynamicPartitions()\n  type: Method\n  source:\n    remote:\n      path: src/mscorlib/src/System/Collections/Concurrent/OrderablePartitioner.cs\n      branch: master\n      repo: https://github.com/dotnet/coreclr.git\n    id: GetDynamicPartitions\n    path: src/mscorlib/src/System/Collections/Concurrent/OrderablePartitioner.cs\n    startLine: 209\n  assemblies:\n  - System.Collections.Concurrent\n  namespace: System.Collections.Concurrent\n  summary: \"\\n<p>Creates an object that can partition the underlying collection into a variable number of partitions.</p>\\n\"\n  syntax:\n    content: public override IEnumerable<TSource> GetDynamicPartitions()\n    content.vb: Public Overrides Function GetDynamicPartitions As IEnumerable(Of TSource)\n    return:\n      type: System.Collections.Generic.IEnumerable{{TSource}}\n      description: \"\\n<p>An object that can create partitions over the underlying data source.</p>\\n\"\n  overridden: System.Collections.Concurrent.Partitioner{{TSource}}.GetDynamicPartitions\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: \"\\n<p>Dynamic partitioning is not supported by the base class. It must be implemented in derived classes.</p>\\n\"\n  modifiers.csharp:\n  - public\n  - override\n  modifiers.vb:\n  - Public\n  - Overrides\n  fullName.vb: System.Collections.Concurrent.OrderablePartitioner(Of TSource).GetDynamicPartitions()\n  nameWithType: OrderablePartitioner<TSource>.GetDynamicPartitions()\n  nameWithType.vb: OrderablePartitioner(Of TSource).GetDynamicPartitions()\n- uid: System.Collections.Concurrent.OrderablePartitioner`1.GetOrderableDynamicPartitions\n  commentId: M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderableDynamicPartitions\n  id: GetOrderableDynamicPartitions\n  parent: System.Collections.Concurrent.OrderablePartitioner`1\n  langs:\n  - csharp\n  - vb\n  name: GetOrderableDynamicPartitions()\n  fullName: System.Collections.Concurrent.OrderablePartitioner<TSource>.GetOrderableDynamicPartitions()\n  type: Method\n  source:\n    remote:\n      path: src/mscorlib/src/System/Collections/Concurrent/OrderablePartitioner.cs\n      branch: master\n      repo: https://github.com/dotnet/coreclr.git\n    id: GetOrderableDynamicPartitions\n    path: src/mscorlib/src/System/Collections/Concurrent/OrderablePartitioner.cs\n    startLine: 129\n  assemblies:\n  - System.Collections.Concurrent\n  namespace: System.Collections.Concurrent\n  summary: \"\\n<p>Creates an object that can partition the underlying collection into a variable number of partitions.</p>\\n\"\n  syntax:\n    content: public virtual IEnumerable<KeyValuePair<long, TSource>> GetOrderableDynamicPartitions()\n    content.vb: Public Overridable Function GetOrderableDynamicPartitions As IEnumerable(Of KeyValuePair(Of Long, TSource))\n    return:\n      type: System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Int64,{TSource}}}\n      description: \"\\n<p>An object that can create partitions over the underlying data source.</p>\\n\"\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: \"\\n<p>Dynamic partitioning is not supported by this partitioner.</p>\\n\"\n  modifiers.csharp:\n  - public\n  - virtual\n  modifiers.vb:\n  - Public\n  - Overridable\n  fullName.vb: System.Collections.Concurrent.OrderablePartitioner(Of TSource).GetOrderableDynamicPartitions()\n  nameWithType: OrderablePartitioner<TSource>.GetOrderableDynamicPartitions()\n  nameWithType.vb: OrderablePartitioner(Of TSource).GetOrderableDynamicPartitions()\n- uid: System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)\n  commentId: M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)\n  id: GetOrderablePartitions(System.Int32)\n  parent: System.Collections.Concurrent.OrderablePartitioner`1\n  langs:\n  - csharp\n  - vb\n  name: GetOrderablePartitions(Int32)\n  fullName: System.Collections.Concurrent.OrderablePartitioner<TSource>.GetOrderablePartitions(System.Int32)\n  type: Method\n  source:\n    remote:\n      path: src/mscorlib/src/System/Collections/Concurrent/OrderablePartitioner.cs\n      branch: master\n      repo: https://github.com/dotnet/coreclr.git\n    id: GetOrderablePartitions\n    path: src/mscorlib/src/System/Collections/Concurrent/OrderablePartitioner.cs\n    startLine: 102\n  assemblies:\n  - System.Collections.Concurrent\n  namespace: System.Collections.Concurrent\n  summary: \"\\n<p>Partitions the underlying collection into the specified number of orderable partitions.</p>\\n\"\n  syntax:\n    content: public abstract IList<IEnumerator<KeyValuePair<long, TSource>>> GetOrderablePartitions(int partitionCount)\n    content.vb: Public MustOverride Function GetOrderablePartitions(partitionCount As Integer) As IList(Of IEnumerator(Of KeyValuePair(Of Long, TSource)))\n    parameters:\n    - id: partitionCount\n      type: System.Int32\n      description: \"\\n<p>The number of partitions to create.</p>\\n\"\n    return:\n      type: System.Collections.Generic.IList{System.Collections.Generic.IEnumerator{System.Collections.Generic.KeyValuePair{System.Int64,{TSource}}}}\n      description: \"\\n<p>A list containing <em>partitionCount</em> enumerators.</p>\\n\"\n  modifiers.csharp:\n  - public\n  - abstract\n  modifiers.vb:\n  - Public\n  - MustOverride\n  fullName.vb: System.Collections.Concurrent.OrderablePartitioner(Of TSource).GetOrderablePartitions(System.Int32)\n  nameWithType: OrderablePartitioner<TSource>.GetOrderablePartitions(Int32)\n  nameWithType.vb: OrderablePartitioner(Of TSource).GetOrderablePartitions(Int32)\n- uid: System.Collections.Concurrent.OrderablePartitioner`1.GetPartitions(System.Int32)\n  commentId: M:System.Collections.Concurrent.OrderablePartitioner`1.GetPartitions(System.Int32)\n  id: GetPartitions(System.Int32)\n  parent: System.Collections.Concurrent.OrderablePartitioner`1\n  langs:\n  - csharp\n  - vb\n  name: GetPartitions(Int32)\n  fullName: System.Collections.Concurrent.OrderablePartitioner<TSource>.GetPartitions(System.Int32)\n  type: Method\n  source:\n    remote:\n      path: src/mscorlib/src/System/Collections/Concurrent/OrderablePartitioner.cs\n      branch: master\n      repo: https://github.com/dotnet/coreclr.git\n    id: GetPartitions\n    path: src/mscorlib/src/System/Collections/Concurrent/OrderablePartitioner.cs\n    startLine: 168\n  assemblies:\n  - System.Collections.Concurrent\n  namespace: System.Collections.Concurrent\n  summary: \"\\n<p>Partitions the underlying collection into the given number of ordered partitions.</p>\\n\"\n  syntax:\n    content: public override IList<IEnumerator<TSource>> GetPartitions(int partitionCount)\n    content.vb: Public Overrides Function GetPartitions(partitionCount As Integer) As IList(Of IEnumerator(Of TSource))\n    parameters:\n    - id: partitionCount\n      type: System.Int32\n      description: \"\\n<p>The number of partitions to create.</p>\\n\"\n    return:\n      type: System.Collections.Generic.IList{System.Collections.Generic.IEnumerator{{TSource}}}\n      description: \"\\n<p>A list containing <em>partitionCount</em> enumerators.</p>\\n\"\n  overridden: System.Collections.Concurrent.Partitioner{{TSource}}.GetPartitions(System.Int32)\n  modifiers.csharp:\n  - public\n  - override\n  modifiers.vb:\n  - Public\n  - Overrides\n  fullName.vb: System.Collections.Concurrent.OrderablePartitioner(Of TSource).GetPartitions(System.Int32)\n  nameWithType: OrderablePartitioner<TSource>.GetPartitions(Int32)\n  nameWithType.vb: OrderablePartitioner(Of TSource).GetPartitions(Int32)\nreferences:\n- uid: System.Collections.Concurrent\n  isExternal: false\n  name: System.Collections.Concurrent\n  fullName: System.Collections.Concurrent\n  nameWithType: System.Collections.Concurrent\n  commentId: N:System.Collections.Concurrent\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  fullName: System.Object\n  nameWithType: Object\n  commentId: T:System.Object\n- uid: System.Collections.Concurrent.Partitioner{{TSource}}\n  parent: System.Collections.Concurrent\n  definition: System.Collections.Concurrent.Partitioner`1\n  name: Partitioner<TSource>\n  fullName: System.Collections.Concurrent.Partitioner<TSource>\n  fullname.vb: System.Collections.Concurrent.Partitioner(Of TSource)\n  name.vb: Partitioner(Of TSource)\n  spec.csharp:\n  - uid: System.Collections.Concurrent.Partitioner`1\n    name: Partitioner\n    fullName: System.Collections.Concurrent.Partitioner\n  - name: <\n    fullName: <\n  - name: TSource\n    fullName: TSource\n  - name: '>'\n    fullName: '>'\n  spec.vb:\n  - uid: System.Collections.Concurrent.Partitioner`1\n    name: Partitioner\n    fullName: System.Collections.Concurrent.Partitioner\n  - name: '(Of '\n    fullName: '(Of '\n  - name: TSource\n    fullName: TSource\n  - name: )\n    fullName: )\n  nameWithType: Partitioner<TSource>\n  nameWithType.vb: Partitioner(Of TSource)\n  commentId: T:System.Collections.Concurrent.Partitioner{``0}\n- uid: System.Collections.Concurrent.Partitioner{{TSource}}.SupportsDynamicPartitions\n  parent: System.Collections.Concurrent.Partitioner{{TSource}}\n  definition: System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions\n  name: SupportsDynamicPartitions\n  fullName: System.Collections.Concurrent.Partitioner<TSource>.SupportsDynamicPartitions\n  fullname.vb: System.Collections.Concurrent.Partitioner(Of TSource).SupportsDynamicPartitions\n  nameWithType: Partitioner<TSource>.SupportsDynamicPartitions\n  nameWithType.vb: Partitioner(Of TSource).SupportsDynamicPartitions\n  commentId: P:System.Collections.Concurrent.Partitioner{`0}.SupportsDynamicPartitions\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: true\n  name: ToString()\n  fullName: System.Object.ToString()\n  spec.csharp:\n  - uid: System.Object.ToString\n    name: ToString\n    fullName: System.Object.ToString\n    isExternal: true\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Object.ToString\n    name: ToString\n    fullName: System.Object.ToString\n    isExternal: true\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  nameWithType: Object.ToString()\n  commentId: M:System.Object.ToString\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: true\n  name: Equals(Object)\n  fullName: System.Object.Equals(System.Object)\n  spec.csharp:\n  - uid: System.Object.Equals(System.Object)\n    name: Equals\n    fullName: System.Object.Equals\n    isExternal: true\n  - name: (\n    fullName: (\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Object.Equals(System.Object)\n    name: Equals\n    fullName: System.Object.Equals\n    isExternal: true\n  - name: (\n    fullName: (\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: )\n    fullName: )\n  nameWithType: Object.Equals(Object)\n  commentId: M:System.Object.Equals(System.Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: true\n  name: Equals(Object, Object)\n  fullName: System.Object.Equals(System.Object, System.Object)\n  spec.csharp:\n  - uid: System.Object.Equals(System.Object,System.Object)\n    name: Equals\n    fullName: System.Object.Equals\n    isExternal: true\n  - name: (\n    fullName: (\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: ', '\n    fullName: ', '\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Object.Equals(System.Object,System.Object)\n    name: Equals\n    fullName: System.Object.Equals\n    isExternal: true\n  - name: (\n    fullName: (\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: ', '\n    fullName: ', '\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: )\n    fullName: )\n  nameWithType: Object.Equals(Object, Object)\n  commentId: M:System.Object.Equals(System.Object,System.Object)\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: true\n  name: ReferenceEquals(Object, Object)\n  fullName: System.Object.ReferenceEquals(System.Object, System.Object)\n  spec.csharp:\n  - uid: System.Object.ReferenceEquals(System.Object,System.Object)\n    name: ReferenceEquals\n    fullName: System.Object.ReferenceEquals\n    isExternal: true\n  - name: (\n    fullName: (\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: ', '\n    fullName: ', '\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Object.ReferenceEquals(System.Object,System.Object)\n    name: ReferenceEquals\n    fullName: System.Object.ReferenceEquals\n    isExternal: true\n  - name: (\n    fullName: (\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: ', '\n    fullName: ', '\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: )\n    fullName: )\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  commentId: M:System.Object.ReferenceEquals(System.Object,System.Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: true\n  name: GetHashCode()\n  fullName: System.Object.GetHashCode()\n  spec.csharp:\n  - uid: System.Object.GetHashCode\n    name: GetHashCode\n    fullName: System.Object.GetHashCode\n    isExternal: true\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Object.GetHashCode\n    name: GetHashCode\n    fullName: System.Object.GetHashCode\n    isExternal: true\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  nameWithType: Object.GetHashCode()\n  commentId: M:System.Object.GetHashCode\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: true\n  name: GetType()\n  fullName: System.Object.GetType()\n  spec.csharp:\n  - uid: System.Object.GetType\n    name: GetType\n    fullName: System.Object.GetType\n    isExternal: true\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Object.GetType\n    name: GetType\n    fullName: System.Object.GetType\n    isExternal: true\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  nameWithType: Object.GetType()\n  commentId: M:System.Object.GetType\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: true\n  name: MemberwiseClone()\n  fullName: System.Object.MemberwiseClone()\n  spec.csharp:\n  - uid: System.Object.MemberwiseClone\n    name: MemberwiseClone\n    fullName: System.Object.MemberwiseClone\n    isExternal: true\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Object.MemberwiseClone\n    name: MemberwiseClone\n    fullName: System.Object.MemberwiseClone\n    isExternal: true\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  nameWithType: Object.MemberwiseClone()\n  commentId: M:System.Object.MemberwiseClone\n- uid: System\n  isExternal: false\n  name: System\n  fullName: System\n  nameWithType: System\n  commentId: N:System\n- uid: System.Collections.Concurrent.Partitioner`1\n  isExternal: false\n  name: Partitioner<TSource>\n  fullName: System.Collections.Concurrent.Partitioner<TSource>\n  fullname.vb: System.Collections.Concurrent.Partitioner(Of TSource)\n  name.vb: Partitioner(Of TSource)\n  spec.csharp:\n  - uid: System.Collections.Concurrent.Partitioner`1\n    name: Partitioner\n    fullName: System.Collections.Concurrent.Partitioner\n  - name: <\n    fullName: <\n  - name: TSource\n    fullName: TSource\n  - name: '>'\n    fullName: '>'\n  spec.vb:\n  - uid: System.Collections.Concurrent.Partitioner`1\n    name: Partitioner\n    fullName: System.Collections.Concurrent.Partitioner\n  - name: '(Of '\n    fullName: '(Of '\n  - name: TSource\n    fullName: TSource\n  - name: )\n    fullName: )\n  nameWithType: Partitioner<TSource>\n  nameWithType.vb: Partitioner(Of TSource)\n  commentId: T:System.Collections.Concurrent.Partitioner`1\n- uid: System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions\n  isExternal: false\n  name: SupportsDynamicPartitions\n  fullName: System.Collections.Concurrent.Partitioner<TSource>.SupportsDynamicPartitions\n  fullname.vb: System.Collections.Concurrent.Partitioner(Of TSource).SupportsDynamicPartitions\n  nameWithType: Partitioner<TSource>.SupportsDynamicPartitions\n  nameWithType.vb: Partitioner(Of TSource).SupportsDynamicPartitions\n  commentId: P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  fullName: System.Boolean\n  nameWithType: Boolean\n  commentId: T:System.Boolean\n- uid: System.Collections.Concurrent.Partitioner{{TSource}}.GetDynamicPartitions\n  parent: System.Collections.Concurrent.Partitioner{{TSource}}\n  definition: System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions\n  name: GetDynamicPartitions()\n  fullName: System.Collections.Concurrent.Partitioner<TSource>.GetDynamicPartitions()\n  fullname.vb: System.Collections.Concurrent.Partitioner(Of TSource).GetDynamicPartitions()\n  spec.csharp:\n  - uid: System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions\n    name: GetDynamicPartitions\n    fullName: System.Collections.Concurrent.Partitioner<TSource>.GetDynamicPartitions\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions\n    name: GetDynamicPartitions\n    fullName: System.Collections.Concurrent.Partitioner(Of TSource).GetDynamicPartitions\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  nameWithType: Partitioner<TSource>.GetDynamicPartitions()\n  nameWithType.vb: Partitioner(Of TSource).GetDynamicPartitions()\n  commentId: M:System.Collections.Concurrent.Partitioner{`0}.GetDynamicPartitions\n- uid: System.Collections.Generic.IEnumerable{{TSource}}\n  parent: System.Collections.Generic\n  definition: System.Collections.Generic.IEnumerable`1\n  name: IEnumerable<TSource>\n  fullName: System.Collections.Generic.IEnumerable<TSource>\n  fullname.vb: System.Collections.Generic.IEnumerable(Of TSource)\n  name.vb: IEnumerable(Of TSource)\n  spec.csharp:\n  - uid: System.Collections.Generic.IEnumerable`1\n    name: IEnumerable\n    fullName: System.Collections.Generic.IEnumerable\n    isExternal: true\n  - name: <\n    fullName: <\n  - name: TSource\n    fullName: TSource\n  - name: '>'\n    fullName: '>'\n  spec.vb:\n  - uid: System.Collections.Generic.IEnumerable`1\n    name: IEnumerable\n    fullName: System.Collections.Generic.IEnumerable\n    isExternal: true\n  - name: '(Of '\n    fullName: '(Of '\n  - name: TSource\n    fullName: TSource\n  - name: )\n    fullName: )\n  nameWithType: IEnumerable<TSource>\n  nameWithType.vb: IEnumerable(Of TSource)\n  commentId: T:System.Collections.Generic.IEnumerable{``0}\n- uid: System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions\n  isExternal: false\n  name: GetDynamicPartitions()\n  fullName: System.Collections.Concurrent.Partitioner<TSource>.GetDynamicPartitions()\n  fullname.vb: System.Collections.Concurrent.Partitioner(Of TSource).GetDynamicPartitions()\n  spec.csharp:\n  - uid: System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions\n    name: GetDynamicPartitions\n    fullName: System.Collections.Concurrent.Partitioner<TSource>.GetDynamicPartitions\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions\n    name: GetDynamicPartitions\n    fullName: System.Collections.Concurrent.Partitioner(Of TSource).GetDynamicPartitions\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  nameWithType: Partitioner<TSource>.GetDynamicPartitions()\n  nameWithType.vb: Partitioner(Of TSource).GetDynamicPartitions()\n  commentId: M:System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions\n- uid: System.Collections.Generic.IEnumerable`1\n  isExternal: false\n  name: IEnumerable<T>\n  fullName: System.Collections.Generic.IEnumerable<T>\n  fullname.vb: System.Collections.Generic.IEnumerable(Of T)\n  name.vb: IEnumerable(Of T)\n  spec.csharp:\n  - uid: System.Collections.Generic.IEnumerable`1\n    name: IEnumerable\n    fullName: System.Collections.Generic.IEnumerable\n  - name: <\n    fullName: <\n  - name: T\n    fullName: T\n  - name: '>'\n    fullName: '>'\n  spec.vb:\n  - uid: System.Collections.Generic.IEnumerable`1\n    name: IEnumerable\n    fullName: System.Collections.Generic.IEnumerable\n  - name: '(Of '\n    fullName: '(Of '\n  - name: T\n    fullName: T\n  - name: )\n    fullName: )\n  nameWithType: IEnumerable<T>\n  nameWithType.vb: IEnumerable(Of T)\n  commentId: T:System.Collections.Generic.IEnumerable`1\n- uid: System.Collections.Generic\n  isExternal: false\n  name: System.Collections.Generic\n  fullName: System.Collections.Generic\n  nameWithType: System.Collections.Generic\n  commentId: N:System.Collections.Generic\n- uid: System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Int64,{TSource}}}\n  parent: System.Collections.Generic\n  definition: System.Collections.Generic.IEnumerable`1\n  name: IEnumerable<KeyValuePair<Int64, TSource>>\n  fullName: System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.Int64, TSource>>\n  fullname.vb: System.Collections.Generic.IEnumerable(Of System.Collections.Generic.KeyValuePair(Of System.Int64, TSource))\n  name.vb: IEnumerable(Of KeyValuePair(Of Int64, TSource))\n  spec.csharp:\n  - uid: System.Collections.Generic.IEnumerable`1\n    name: IEnumerable\n    fullName: System.Collections.Generic.IEnumerable\n    isExternal: true\n  - name: <\n    fullName: <\n  - uid: System.Collections.Generic.KeyValuePair`2\n    name: KeyValuePair\n    fullName: System.Collections.Generic.KeyValuePair\n    isExternal: true\n  - name: <\n    fullName: <\n  - uid: System.Int64\n    name: Int64\n    fullName: System.Int64\n    isExternal: true\n  - name: ', '\n    fullName: ', '\n  - name: TSource\n    fullName: TSource\n  - name: '>'\n    fullName: '>'\n  - name: '>'\n    fullName: '>'\n  spec.vb:\n  - uid: System.Collections.Generic.IEnumerable`1\n    name: IEnumerable\n    fullName: System.Collections.Generic.IEnumerable\n    isExternal: true\n  - name: '(Of '\n    fullName: '(Of '\n  - uid: System.Collections.Generic.KeyValuePair`2\n    name: KeyValuePair\n    fullName: System.Collections.Generic.KeyValuePair\n    isExternal: true\n  - name: '(Of '\n    fullName: '(Of '\n  - uid: System.Int64\n    name: Int64\n    fullName: System.Int64\n    isExternal: true\n  - name: ', '\n    fullName: ', '\n  - name: TSource\n    fullName: TSource\n  - name: )\n    fullName: )\n  - name: )\n    fullName: )\n  nameWithType: IEnumerable<KeyValuePair<Int64, TSource>>\n  nameWithType.vb: IEnumerable(Of KeyValuePair(Of Int64, TSource))\n  commentId: T:System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Int64,`0}}\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  fullName: System.Int32\n  nameWithType: Int32\n  commentId: T:System.Int32\n- uid: System.Collections.Generic.IList{System.Collections.Generic.IEnumerator{System.Collections.Generic.KeyValuePair{System.Int64,{TSource}}}}\n  parent: System.Collections.Generic\n  definition: System.Collections.Generic.IList`1\n  name: IList<IEnumerator<KeyValuePair<Int64, TSource>>>\n  fullName: System.Collections.Generic.IList<System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<System.Int64, TSource>>>\n  fullname.vb: System.Collections.Generic.IList(Of System.Collections.Generic.IEnumerator(Of System.Collections.Generic.KeyValuePair(Of System.Int64, TSource)))\n  name.vb: IList(Of IEnumerator(Of KeyValuePair(Of Int64, TSource)))\n  spec.csharp:\n  - uid: System.Collections.Generic.IList`1\n    name: IList\n    fullName: System.Collections.Generic.IList\n    isExternal: true\n  - name: <\n    fullName: <\n  - uid: System.Collections.Generic.IEnumerator`1\n    name: IEnumerator\n    fullName: System.Collections.Generic.IEnumerator\n    isExternal: true\n  - name: <\n    fullName: <\n  - uid: System.Collections.Generic.KeyValuePair`2\n    name: KeyValuePair\n    fullName: System.Collections.Generic.KeyValuePair\n    isExternal: true\n  - name: <\n    fullName: <\n  - uid: System.Int64\n    name: Int64\n    fullName: System.Int64\n    isExternal: true\n  - name: ', '\n    fullName: ', '\n  - name: TSource\n    fullName: TSource\n  - name: '>'\n    fullName: '>'\n  - name: '>'\n    fullName: '>'\n  - name: '>'\n    fullName: '>'\n  spec.vb:\n  - uid: System.Collections.Generic.IList`1\n    name: IList\n    fullName: System.Collections.Generic.IList\n    isExternal: true\n  - name: '(Of '\n    fullName: '(Of '\n  - uid: System.Collections.Generic.IEnumerator`1\n    name: IEnumerator\n    fullName: System.Collections.Generic.IEnumerator\n    isExternal: true\n  - name: '(Of '\n    fullName: '(Of '\n  - uid: System.Collections.Generic.KeyValuePair`2\n    name: KeyValuePair\n    fullName: System.Collections.Generic.KeyValuePair\n    isExternal: true\n  - name: '(Of '\n    fullName: '(Of '\n  - uid: System.Int64\n    name: Int64\n    fullName: System.Int64\n    isExternal: true\n  - name: ', '\n    fullName: ', '\n  - name: TSource\n    fullName: TSource\n  - name: )\n    fullName: )\n  - name: )\n    fullName: )\n  - name: )\n    fullName: )\n  nameWithType: IList<IEnumerator<KeyValuePair<Int64, TSource>>>\n  nameWithType.vb: IList(Of IEnumerator(Of KeyValuePair(Of Int64, TSource)))\n  commentId: T:System.Collections.Generic.IList{System.Collections.Generic.IEnumerator{System.Collections.Generic.KeyValuePair{System.Int64,`0}}}\n- uid: System.Collections.Generic.IList`1\n  isExternal: false\n  name: IList<T>\n  fullName: System.Collections.Generic.IList<T>\n  fullname.vb: System.Collections.Generic.IList(Of T)\n  name.vb: IList(Of T)\n  spec.csharp:\n  - uid: System.Collections.Generic.IList`1\n    name: IList\n    fullName: System.Collections.Generic.IList\n  - name: <\n    fullName: <\n  - name: T\n    fullName: T\n  - name: '>'\n    fullName: '>'\n  spec.vb:\n  - uid: System.Collections.Generic.IList`1\n    name: IList\n    fullName: System.Collections.Generic.IList\n  - name: '(Of '\n    fullName: '(Of '\n  - name: T\n    fullName: T\n  - name: )\n    fullName: )\n  nameWithType: IList<T>\n  nameWithType.vb: IList(Of T)\n  commentId: T:System.Collections.Generic.IList`1\n- uid: System.Collections.Concurrent.Partitioner{{TSource}}.GetPartitions(System.Int32)\n  parent: System.Collections.Concurrent.Partitioner{{TSource}}\n  definition: System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)\n  name: GetPartitions(Int32)\n  fullName: System.Collections.Concurrent.Partitioner<TSource>.GetPartitions(System.Int32)\n  fullname.vb: System.Collections.Concurrent.Partitioner(Of TSource).GetPartitions(System.Int32)\n  spec.csharp:\n  - uid: System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)\n    name: GetPartitions\n    fullName: System.Collections.Concurrent.Partitioner<TSource>.GetPartitions\n  - name: (\n    fullName: (\n  - uid: System.Int32\n    name: Int32\n    fullName: System.Int32\n    isExternal: true\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)\n    name: GetPartitions\n    fullName: System.Collections.Concurrent.Partitioner(Of TSource).GetPartitions\n  - name: (\n    fullName: (\n  - uid: System.Int32\n    name: Int32\n    fullName: System.Int32\n    isExternal: true\n  - name: )\n    fullName: )\n  nameWithType: Partitioner<TSource>.GetPartitions(Int32)\n  nameWithType.vb: Partitioner(Of TSource).GetPartitions(Int32)\n  commentId: M:System.Collections.Concurrent.Partitioner{`0}.GetPartitions(System.Int32)\n- uid: System.Collections.Generic.IList{System.Collections.Generic.IEnumerator{{TSource}}}\n  parent: System.Collections.Generic\n  definition: System.Collections.Generic.IList`1\n  name: IList<IEnumerator<TSource>>\n  fullName: System.Collections.Generic.IList<System.Collections.Generic.IEnumerator<TSource>>\n  fullname.vb: System.Collections.Generic.IList(Of System.Collections.Generic.IEnumerator(Of TSource))\n  name.vb: IList(Of IEnumerator(Of TSource))\n  spec.csharp:\n  - uid: System.Collections.Generic.IList`1\n    name: IList\n    fullName: System.Collections.Generic.IList\n    isExternal: true\n  - name: <\n    fullName: <\n  - uid: System.Collections.Generic.IEnumerator`1\n    name: IEnumerator\n    fullName: System.Collections.Generic.IEnumerator\n    isExternal: true\n  - name: <\n    fullName: <\n  - name: TSource\n    fullName: TSource\n  - name: '>'\n    fullName: '>'\n  - name: '>'\n    fullName: '>'\n  spec.vb:\n  - uid: System.Collections.Generic.IList`1\n    name: IList\n    fullName: System.Collections.Generic.IList\n    isExternal: true\n  - name: '(Of '\n    fullName: '(Of '\n  - uid: System.Collections.Generic.IEnumerator`1\n    name: IEnumerator\n    fullName: System.Collections.Generic.IEnumerator\n    isExternal: true\n  - name: '(Of '\n    fullName: '(Of '\n  - name: TSource\n    fullName: TSource\n  - name: )\n    fullName: )\n  - name: )\n    fullName: )\n  nameWithType: IList<IEnumerator<TSource>>\n  nameWithType.vb: IList(Of IEnumerator(Of TSource))\n  commentId: T:System.Collections.Generic.IList{System.Collections.Generic.IEnumerator{`0}}\n- uid: System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)\n  isExternal: true\n  name: GetPartitions(Int32)\n  fullName: System.Collections.Concurrent.Partitioner<TSource>.GetPartitions(System.Int32)\n  fullname.vb: System.Collections.Concurrent.Partitioner(Of TSource).GetPartitions(System.Int32)\n  spec.csharp:\n  - uid: System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)\n    name: GetPartitions\n    fullName: System.Collections.Concurrent.Partitioner<TSource>.GetPartitions\n  - name: (\n    fullName: (\n  - uid: System.Int32\n    name: Int32\n    fullName: System.Int32\n    isExternal: true\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)\n    name: GetPartitions\n    fullName: System.Collections.Concurrent.Partitioner(Of TSource).GetPartitions\n  - name: (\n    fullName: (\n  - uid: System.Int32\n    name: Int32\n    fullName: System.Int32\n    isExternal: true\n  - name: )\n    fullName: )\n  nameWithType: Partitioner<TSource>.GetPartitions(Int32)\n  nameWithType.vb: Partitioner(Of TSource).GetPartitions(Int32)\n  commentId: M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)\n- uid: System.NotSupportedException\n  parent: System\n  isExternal: false\n  name: NotSupportedException\n  fullName: System.NotSupportedException\n  nameWithType: NotSupportedException\n  commentId: T:System.NotSupportedException\n"}