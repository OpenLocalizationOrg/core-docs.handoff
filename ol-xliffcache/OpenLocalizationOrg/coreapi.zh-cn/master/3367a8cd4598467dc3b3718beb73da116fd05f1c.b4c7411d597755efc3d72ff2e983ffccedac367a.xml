{"nodes":[{"pos":[1013,1024],"content":"Partitioner","needQuote":true,"nodes":[{"content":"Partitioner","pos":[0,11]}]},{"pos":[2560,2580],"content":"Create(Int32, Int32)","needQuote":true,"nodes":[{"content":"Create(Int32, Int32)","pos":[0,20]}]},{"content":"\\n&lt;p&gt;The lower, inclusive bound of the range.&lt;/p&gt;\\n","pos":[3499,3550],"source":"\\n<p>The lower, inclusive bound of the range.</p>\\n"},{"content":"\\n&lt;p&gt;The upper, exclusive bound of the range.&lt;/p&gt;\\n","pos":[3619,3670],"source":"\\n<p>The upper, exclusive bound of the range.</p>\\n"},{"content":"\\n&lt;p&gt;A partitioner.&lt;/p&gt;\\n","pos":[3808,3833],"source":"\\n<p>A partitioner.</p>\\n"},{"content":"\\n&lt;p&gt;The &lt;em&gt;toExclusive&lt;/em&gt; argument is less than or equal to the &lt;em&gt;fromInclusive&lt;/em&gt; argument.&lt;/p&gt;\\n","pos":[3964,4070],"source":"\\n<p>The <em>toExclusive</em> argument is less than or equal to the <em>fromInclusive</em> argument.</p>\\n"},{"pos":[4541,4568],"content":"Create(Int32, Int32, Int32)","needQuote":true,"nodes":[{"content":"Create(Int32, Int32, Int32)","pos":[0,27]}]},{"content":"\\n&lt;p&gt;The lower, inclusive bound of the range.&lt;/p&gt;\\n","pos":[5538,5589],"source":"\\n<p>The lower, inclusive bound of the range.</p>\\n"},{"content":"\\n&lt;p&gt;The upper, exclusive bound of the range.&lt;/p&gt;\\n","pos":[5658,5709],"source":"\\n<p>The upper, exclusive bound of the range.</p>\\n"},{"content":"\\n&lt;p&gt;The size of each subrange.&lt;/p&gt;\\n","pos":[5776,5813],"source":"\\n<p>The size of each subrange.</p>\\n"},{"content":"\\n&lt;p&gt;A partitioner.&lt;/p&gt;\\n","pos":[5951,5976],"source":"\\n<p>A partitioner.</p>\\n"},{"content":"\\n&lt;p&gt;The &lt;em&gt;toExclusive&lt;/em&gt; argument is less than or equal to the &lt;em&gt;fromInclusive&lt;/em&gt; argument.&lt;/p&gt;\\n&lt;p&gt;-or-&lt;/p&gt;\\n&lt;p&gt;The &lt;em&gt;rangeSize&lt;/em&gt; argument is less than or equal to 0.&lt;/p&gt;\\n","pos":[6107,6294],"source":"\\n<p>The <em>toExclusive</em> argument is less than or equal to the <em>fromInclusive</em> argument.</p>\\n<p>-or-</p>\\n<p>The <em>rangeSize</em> argument is less than or equal to 0.</p>\\n"},{"pos":[6733,6753],"content":"Create(Int64, Int64)","needQuote":true,"nodes":[{"content":"Create(Int64, Int64)","pos":[0,20]}]},{"content":"\\n&lt;p&gt;The lower, inclusive bound of the range.&lt;/p&gt;\\n","pos":[7664,7715],"source":"\\n<p>The lower, inclusive bound of the range.</p>\\n"},{"content":"\\n&lt;p&gt;The upper, exclusive bound of the range.&lt;/p&gt;\\n","pos":[7784,7835],"source":"\\n<p>The upper, exclusive bound of the range.</p>\\n"},{"content":"\\n&lt;p&gt;A partitioner.&lt;/p&gt;\\n","pos":[7973,7998],"source":"\\n<p>A partitioner.</p>\\n"},{"content":"\\n&lt;p&gt;The &lt;em&gt;toExclusive&lt;/em&gt; argument is less than or equal to the &lt;em&gt;fromInclusive&lt;/em&gt; argument.&lt;/p&gt;\\n","pos":[8129,8235],"source":"\\n<p>The <em>toExclusive</em> argument is less than or equal to the <em>fromInclusive</em> argument.</p>\\n"},{"pos":[8706,8733],"content":"Create(Int64, Int64, Int64)","needQuote":true,"nodes":[{"content":"Create(Int64, Int64, Int64)","pos":[0,27]}]},{"content":"\\n&lt;p&gt;The lower, inclusive bound of the range.&lt;/p&gt;\\n","pos":[9693,9744],"source":"\\n<p>The lower, inclusive bound of the range.</p>\\n"},{"content":"\\n&lt;p&gt;The upper, exclusive bound of the range.&lt;/p&gt;\\n","pos":[9813,9864],"source":"\\n<p>The upper, exclusive bound of the range.</p>\\n"},{"content":"\\n&lt;p&gt;The size of each subrange.&lt;/p&gt;\\n","pos":[9931,9968],"source":"\\n<p>The size of each subrange.</p>\\n"},{"content":"\\n&lt;p&gt;A partitioner.&lt;/p&gt;\\n","pos":[10106,10131],"source":"\\n<p>A partitioner.</p>\\n"},{"content":"\\n&lt;p&gt;The &lt;em&gt;toExclusive&lt;/em&gt; argument is less than or equal to the &lt;em&gt;fromInclusive&lt;/em&gt; argument.&lt;/p&gt;\\n&lt;p&gt;-or-&lt;/p&gt;\\n&lt;p&gt;The &lt;em&gt;rangeSize&lt;/em&gt; argument is less than or equal to 0.&lt;/p&gt;\\n","pos":[10262,10449],"source":"\\n<p>The <em>toExclusive</em> argument is less than or equal to the <em>fromInclusive</em> argument.</p>\\n<p>-or-</p>\\n<p>The <em>rangeSize</em> argument is less than or equal to 0.</p>\\n"},{"pos":[10882,10917],"content":"Create<TSource>(TSource[], Boolean)","needQuote":true,"nodes":[{"content":"Create&lt;TSource&gt;(TSource[], Boolean)","pos":[0,35],"source":"Create<TSource>(TSource[], Boolean)"}]},{"content":"\\n&lt;p&gt;The array to be partitioned.&lt;/p&gt;\\n","pos":[11887,11926],"source":"\\n<p>The array to be partitioned.</p>\\n"},{"content":"\\n&lt;p&gt;A Boolean value that indicates whether the created partitioner should dynamically load balance between partitions rather than statically partition.&lt;/p&gt;\\n&lt;p&gt;&lt;/p&gt;\\n","pos":[11997,12164],"source":"\\n<p>A Boolean value that indicates whether the created partitioner should dynamically load balance between partitions rather than statically partition.</p>\\n<p></p>\\n"},{"content":"\\n&lt;p&gt;Type of the elements in source array.&lt;/p&gt;\\n","pos":[12224,12272],"source":"\\n<p>Type of the elements in source array.</p>\\n"},{"content":"\\n&lt;p&gt;An orderable partitioner based on the input array.&lt;/p&gt;\\n","pos":[12380,12441],"source":"\\n<p>An orderable partitioner based on the input array.</p>\\n"},{"pos":[13174,13211],"content":"Create<TSource>(IEnumerable<TSource>)","needQuote":true,"nodes":[{"content":"Create&lt;TSource&gt;(IEnumerable&lt;TSource&gt;)","pos":[0,37],"source":"Create<TSource>(IEnumerable<TSource>)"}]},{"content":"\\n&lt;p&gt;The enumerable to be partitioned.&lt;/p&gt;\\n","pos":[14253,14297],"source":"\\n<p>The enumerable to be partitioned.</p>\\n"},{"content":"\\n&lt;p&gt;Type of the elements in source enumerable.&lt;/p&gt;\\n","pos":[14357,14410],"source":"\\n<p>Type of the elements in source enumerable.</p>\\n"},{"content":"\\n&lt;p&gt;An orderable partitioner based on the input array.&lt;/p&gt;\\n","pos":[14518,14579],"source":"\\n<p>An orderable partitioner based on the input array.</p>\\n"},{"pos":[15526,15593],"content":"Create<TSource>(IEnumerable<TSource>, EnumerablePartitionerOptions)","needQuote":true,"nodes":[{"content":"Create&lt;TSource&gt;(IEnumerable&lt;TSource&gt;, EnumerablePartitionerOptions)","pos":[0,67],"source":"Create<TSource>(IEnumerable<TSource>, EnumerablePartitionerOptions)"}]},{"content":"\\n&lt;p&gt;The enumerable to be partitioned.&lt;/p&gt;\\n","pos":[16796,16840],"source":"\\n<p>The enumerable to be partitioned.</p>\\n"},{"content":"\\n&lt;p&gt;Options to control the buffering behavior of the partitioner.&lt;/p&gt;\\n","pos":[16962,17034],"source":"\\n<p>Options to control the buffering behavior of the partitioner.</p>\\n"},{"content":"\\n&lt;p&gt;Type of the elements in source enumerable.&lt;/p&gt;\\n","pos":[17094,17147],"source":"\\n<p>Type of the elements in source enumerable.</p>\\n"},{"content":"\\n&lt;p&gt;An orderable partitioner based on the input array.&lt;/p&gt;\\n","pos":[17255,17316],"source":"\\n<p>An orderable partitioner based on the input array.</p>\\n"},{"pos":[18596,18636],"content":"Create<TSource>(IList<TSource>, Boolean)","needQuote":true,"nodes":[{"content":"Create&lt;TSource&gt;(IList&lt;TSource&gt;, Boolean)","pos":[0,40],"source":"Create<TSource>(IList<TSource>, Boolean)"}]},{"content":"\\n&lt;p&gt;The list to be partitioned.&lt;/p&gt;\\n","pos":[19700,19738],"source":"\\n<p>The list to be partitioned.</p>\\n"},{"content":"\\n&lt;p&gt;A Boolean value that indicates whether the created partitioner should dynamically load balance between partitions rather than statically partition.&lt;/p&gt;\\n&lt;p&gt;&lt;/p&gt;\\n","pos":[19809,19976],"source":"\\n<p>A Boolean value that indicates whether the created partitioner should dynamically load balance between partitions rather than statically partition.</p>\\n<p></p>\\n"},{"content":"\\n&lt;p&gt;Type of the elements in source list.&lt;/p&gt;\\n","pos":[20036,20083],"source":"\\n<p>Type of the elements in source list.</p>\\n"},{"content":"\\n&lt;p&gt;An orderable partitioner based on the input list.&lt;/p&gt;\\n","pos":[20191,20251],"source":"\\n<p>An orderable partitioner based on the input list.</p>\\n"},{"pos":[20753,20782],"content":"System.Collections.Concurrent","needQuote":true,"nodes":[{"content":"System.Collections.Concurrent","pos":[0,29]}]},{"pos":[20982,20988],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"pos":[21148,21158],"content":"ToString()","needQuote":true,"nodes":[{"content":"ToString()","pos":[0,10]}]},{"pos":[21253,21261],"content":"ToString","needQuote":true,"nodes":[{"content":"ToString","pos":[0,8]}]},{"pos":[21330,21331],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[21358,21359],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[21429,21437],"content":"ToString","needQuote":true,"nodes":[{"content":"ToString","pos":[0,8]}]},{"pos":[21506,21507],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[21534,21535],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[21718,21732],"content":"Equals(Object)","needQuote":true,"nodes":[{"content":"Equals(Object)","pos":[0,14]}]},{"pos":[21851,21857],"content":"Equals","needQuote":true,"nodes":[{"content":"Equals","pos":[0,6]}]},{"pos":[21924,21925],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[21975,21981],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"pos":[22041,22042],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[22125,22131],"content":"Equals","needQuote":true,"nodes":[{"content":"Equals","pos":[0,6]}]},{"pos":[22198,22199],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[22249,22255],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"pos":[22315,22316],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[22530,22552],"content":"Equals(Object, Object)","needQuote":true,"nodes":[{"content":"Equals(Object, Object)","pos":[0,22]}]},{"pos":[22700,22706],"content":"Equals","needQuote":true,"nodes":[{"content":"Equals","pos":[0,6]}]},{"pos":[22773,22774],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[22824,22830],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"content":",","pos":[22891,22892]},{"pos":[22947,22953],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"pos":[23013,23014],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[23111,23117],"content":"Equals","needQuote":true,"nodes":[{"content":"Equals","pos":[0,6]}]},{"pos":[23184,23185],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[23235,23241],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"content":",","pos":[23302,23303]},{"pos":[23358,23364],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"pos":[23424,23425],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[23670,23701],"content":"ReferenceEquals(Object, Object)","needQuote":true,"nodes":[{"content":"ReferenceEquals(Object, Object)","pos":[0,31]}]},{"pos":[23867,23882],"content":"ReferenceEquals","needQuote":true,"nodes":[{"content":"ReferenceEquals","pos":[0,15]}]},{"pos":[23958,23959],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[24009,24015],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"content":",","pos":[24076,24077]},{"pos":[24132,24138],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"pos":[24198,24199],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[24305,24320],"content":"ReferenceEquals","needQuote":true,"nodes":[{"content":"ReferenceEquals","pos":[0,15]}]},{"pos":[24396,24397],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[24447,24453],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"content":",","pos":[24514,24515]},{"pos":[24570,24576],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"pos":[24636,24637],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[24867,24880],"content":"GetHashCode()","needQuote":true,"nodes":[{"content":"GetHashCode()","pos":[0,13]}]},{"pos":[24981,24992],"content":"GetHashCode","needQuote":true,"nodes":[{"content":"GetHashCode","pos":[0,11]}]},{"pos":[25064,25065],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[25092,25093],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[25166,25177],"content":"GetHashCode","needQuote":true,"nodes":[{"content":"GetHashCode","pos":[0,11]}]},{"pos":[25249,25250],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[25277,25278],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[25453,25462],"content":"GetType()","needQuote":true,"nodes":[{"content":"GetType()","pos":[0,9]}]},{"pos":[25555,25562],"content":"GetType","needQuote":true,"nodes":[{"content":"GetType","pos":[0,7]}]},{"pos":[25630,25631],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[25658,25659],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[25728,25735],"content":"GetType","needQuote":true,"nodes":[{"content":"GetType","pos":[0,7]}]},{"pos":[25803,25804],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[25831,25832],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[26007,26024],"content":"MemberwiseClone()","needQuote":true,"nodes":[{"content":"MemberwiseClone()","pos":[0,17]}]},{"pos":[26133,26148],"content":"MemberwiseClone","needQuote":true,"nodes":[{"content":"MemberwiseClone","pos":[0,15]}]},{"pos":[26224,26225],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[26252,26253],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[26330,26345],"content":"MemberwiseClone","needQuote":true,"nodes":[{"content":"MemberwiseClone","pos":[0,15]}]},{"pos":[26421,26422],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[26449,26450],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[26595,26601],"content":"System","needQuote":true,"nodes":[{"content":"System","pos":[0,6]}]},{"pos":[26731,26736],"content":"Int32","needQuote":true,"nodes":[{"content":"Int32","pos":[0,5]}]},{"pos":[27026,27067],"content":"OrderablePartitioner<Tuple<Int32, Int32>>","needQuote":true,"nodes":[{"content":"OrderablePartitioner&lt;Tuple&lt;Int32, Int32&gt;&gt;","pos":[0,41],"source":"OrderablePartitioner<Tuple<Int32, Int32>>"}]},{"pos":[27433,27453],"content":"OrderablePartitioner","needQuote":true,"nodes":[{"content":"OrderablePartitioner","pos":[0,20]}]},{"pos":[27529,27530],"content":"<","needQuote":true,"nodes":[]},{"pos":[27581,27586],"content":"Tuple","needQuote":true,"nodes":[{"content":"Tuple","pos":[0,5]}]},{"pos":[27645,27646],"content":"<","needQuote":true,"nodes":[]},{"pos":[27695,27700],"content":"Int32","needQuote":true,"nodes":[{"content":"Int32","pos":[0,5]}]},{"content":",","pos":[27760,27761]},{"pos":[27815,27820],"content":"Int32","needQuote":true,"nodes":[{"content":"Int32","pos":[0,5]}]},{"pos":[28016,28036],"content":"OrderablePartitioner","needQuote":true,"nodes":[{"content":"OrderablePartitioner","pos":[0,20]}]},{"content":"(Of","pos":[28113,28116]},{"pos":[28174,28179],"content":"Tuple","needQuote":true,"nodes":[{"content":"Tuple","pos":[0,5]}]},{"content":"(Of","pos":[28239,28242]},{"pos":[28298,28303],"content":"Int32","needQuote":true,"nodes":[{"content":"Int32","pos":[0,5]}]},{"content":",","pos":[28363,28364]},{"pos":[28418,28423],"content":"Int32","needQuote":true,"nodes":[{"content":"Int32","pos":[0,5]}]},{"pos":[28482,28483],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[28510,28511],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[28848,28877],"content":"OrderablePartitioner<TSource>","needQuote":true,"nodes":[{"content":"OrderablePartitioner&lt;TSource&gt;","pos":[0,29],"source":"OrderablePartitioner<TSource>"}]},{"pos":[29159,29179],"content":"OrderablePartitioner","needQuote":true,"nodes":[{"content":"OrderablePartitioner","pos":[0,20]}]},{"pos":[29255,29256],"content":"<","needQuote":true,"nodes":[]},{"pos":[29283,29290],"content":"TSource","needQuote":true,"nodes":[{"content":"TSource","pos":[0,7]}]},{"pos":[29428,29448],"content":"OrderablePartitioner","needQuote":true,"nodes":[{"content":"OrderablePartitioner","pos":[0,20]}]},{"content":"(Of","pos":[29525,29528]},{"pos":[29562,29569],"content":"TSource","needQuote":true,"nodes":[{"content":"TSource","pos":[0,7]}]},{"pos":[29602,29603],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[29851,29856],"content":"Int64","needQuote":true,"nodes":[{"content":"Int64","pos":[0,5]}]},{"pos":[30146,30187],"content":"OrderablePartitioner<Tuple<Int64, Int64>>","needQuote":true,"nodes":[{"content":"OrderablePartitioner&lt;Tuple&lt;Int64, Int64&gt;&gt;","pos":[0,41],"source":"OrderablePartitioner<Tuple<Int64, Int64>>"}]},{"pos":[30553,30573],"content":"OrderablePartitioner","needQuote":true,"nodes":[{"content":"OrderablePartitioner","pos":[0,20]}]},{"pos":[30649,30650],"content":"<","needQuote":true,"nodes":[]},{"pos":[30701,30706],"content":"Tuple","needQuote":true,"nodes":[{"content":"Tuple","pos":[0,5]}]},{"pos":[30765,30766],"content":"<","needQuote":true,"nodes":[]},{"pos":[30815,30820],"content":"Int64","needQuote":true,"nodes":[{"content":"Int64","pos":[0,5]}]},{"content":",","pos":[30880,30881]},{"pos":[30935,30940],"content":"Int64","needQuote":true,"nodes":[{"content":"Int64","pos":[0,5]}]},{"pos":[31136,31156],"content":"OrderablePartitioner","needQuote":true,"nodes":[{"content":"OrderablePartitioner","pos":[0,20]}]},{"content":"(Of","pos":[31233,31236]},{"pos":[31294,31299],"content":"Tuple","needQuote":true,"nodes":[{"content":"Tuple","pos":[0,5]}]},{"content":"(Of","pos":[31359,31362]},{"pos":[31418,31423],"content":"Int64","needQuote":true,"nodes":[{"content":"Int64","pos":[0,5]}]},{"content":",","pos":[31483,31484]},{"pos":[31538,31543],"content":"Int64","needQuote":true,"nodes":[{"content":"Int64","pos":[0,5]}]},{"pos":[31602,31603],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[31630,31631],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[31909,31918],"content":"TSource[]","needQuote":true,"nodes":[{"content":"TSource[]","pos":[0,9]}]},{"pos":[32012,32019],"content":"TSource","needQuote":true,"nodes":[{"content":"TSource","pos":[0,7]}]},{"content":"[]","pos":[32053,32055]},{"pos":[32097,32104],"content":"TSource","needQuote":true,"nodes":[{"content":"TSource","pos":[0,7]}]},{"pos":[32137,32139],"content":"()","needQuote":true,"nodes":[{"content":"()","pos":[0,2]}]},{"pos":[32279,32286],"content":"Boolean","needQuote":true,"nodes":[{"content":"Boolean","pos":[0,7]}]},{"pos":[32552,32581],"content":"OrderablePartitioner<TSource>","needQuote":true,"nodes":[{"content":"OrderablePartitioner&lt;TSource&gt;","pos":[0,29],"source":"OrderablePartitioner<TSource>"}]},{"pos":[32863,32883],"content":"OrderablePartitioner","needQuote":true,"nodes":[{"content":"OrderablePartitioner","pos":[0,20]}]},{"pos":[32959,32960],"content":"<","needQuote":true,"nodes":[]},{"pos":[32987,32994],"content":"TSource","needQuote":true,"nodes":[{"content":"TSource","pos":[0,7]}]},{"pos":[33132,33152],"content":"OrderablePartitioner","needQuote":true,"nodes":[{"content":"OrderablePartitioner","pos":[0,20]}]},{"content":"(Of","pos":[33229,33232]},{"pos":[33266,33273],"content":"TSource","needQuote":true,"nodes":[{"content":"TSource","pos":[0,7]}]},{"pos":[33306,33307],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[33650,33670],"content":"IEnumerable<TSource>","needQuote":true,"nodes":[{"content":"IEnumerable&lt;TSource&gt;","pos":[0,20],"source":"IEnumerable<TSource>"}]},{"pos":[33907,33918],"content":"IEnumerable","needQuote":true,"nodes":[{"content":"IEnumerable","pos":[0,11]}]},{"pos":[34003,34004],"content":"<","needQuote":true,"nodes":[]},{"pos":[34031,34038],"content":"TSource","needQuote":true,"nodes":[{"content":"TSource","pos":[0,7]}]},{"pos":[34164,34175],"content":"IEnumerable","needQuote":true,"nodes":[{"content":"IEnumerable","pos":[0,11]}]},{"content":"(Of","pos":[34261,34264]},{"pos":[34298,34305],"content":"TSource","needQuote":true,"nodes":[{"content":"TSource","pos":[0,7]}]},{"pos":[34338,34339],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[34571,34585],"content":"IEnumerable<T>","needQuote":true,"nodes":[{"content":"IEnumerable&lt;T&gt;","pos":[0,14],"source":"IEnumerable<T>"}]},{"pos":[34804,34815],"content":"IEnumerable","needQuote":true,"nodes":[{"content":"IEnumerable","pos":[0,11]}]},{"pos":[34879,34880],"content":"<","needQuote":true,"nodes":[]},{"pos":[34907,34908],"content":"T","needQuote":true,"nodes":[{"content":"T","pos":[0,1]}]},{"pos":[35028,35039],"content":"IEnumerable","needQuote":true,"nodes":[{"content":"IEnumerable","pos":[0,11]}]},{"content":"(Of","pos":[35104,35107]},{"pos":[35141,35142],"content":"T","needQuote":true,"nodes":[{"content":"T","pos":[0,1]}]},{"pos":[35169,35170],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[35373,35399],"content":"System.Collections.Generic","needQuote":true,"nodes":[{"content":"System.Collections.Generic","pos":[0,26]}]},{"pos":[35658,35686],"content":"EnumerablePartitionerOptions","needQuote":true,"nodes":[{"content":"EnumerablePartitionerOptions","pos":[0,28]}]},{"pos":[36022,36036],"content":"IList<TSource>","needQuote":true,"nodes":[{"content":"IList&lt;TSource&gt;","pos":[0,14],"source":"IList<TSource>"}]},{"pos":[36249,36254],"content":"IList","needQuote":true,"nodes":[{"content":"IList","pos":[0,5]}]},{"pos":[36333,36334],"content":"<","needQuote":true,"nodes":[]},{"pos":[36361,36368],"content":"TSource","needQuote":true,"nodes":[{"content":"TSource","pos":[0,7]}]},{"pos":[36488,36493],"content":"IList","needQuote":true,"nodes":[{"content":"IList","pos":[0,5]}]},{"content":"(Of","pos":[36573,36576]},{"pos":[36610,36617],"content":"TSource","needQuote":true,"nodes":[{"content":"TSource","pos":[0,7]}]},{"pos":[36650,36651],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[36859,36867],"content":"IList<T>","needQuote":true,"nodes":[{"content":"IList&lt;T&gt;","pos":[0,8],"source":"IList<T>"}]},{"pos":[37062,37067],"content":"IList","needQuote":true,"nodes":[{"content":"IList","pos":[0,5]}]},{"pos":[37125,37126],"content":"<","needQuote":true,"nodes":[]},{"pos":[37153,37154],"content":"T","needQuote":true,"nodes":[{"content":"T","pos":[0,1]}]},{"pos":[37268,37273],"content":"IList","needQuote":true,"nodes":[{"content":"IList","pos":[0,5]}]},{"content":"(Of","pos":[37332,37335]},{"pos":[37369,37370],"content":"T","needQuote":true,"nodes":[{"content":"T","pos":[0,1]}]},{"pos":[37397,37398],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[37591,37618],"content":"ArgumentOutOfRangeException","needQuote":true,"nodes":[{"content":"ArgumentOutOfRangeException","pos":[0,27]}]}],"content":"items:\n- uid: System.Collections.Concurrent.Partitioner\n  commentId: T:System.Collections.Concurrent.Partitioner\n  id: Partitioner\n  parent: System.Collections.Concurrent\n  children:\n  - System.Collections.Concurrent.Partitioner.Create(System.Int32,System.Int32)\n  - System.Collections.Concurrent.Partitioner.Create(System.Int32,System.Int32,System.Int32)\n  - System.Collections.Concurrent.Partitioner.Create(System.Int64,System.Int64)\n  - System.Collections.Concurrent.Partitioner.Create(System.Int64,System.Int64,System.Int64)\n  - System.Collections.Concurrent.Partitioner.Create``1(``0[],System.Boolean)\n  - System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IEnumerable{``0})\n  - System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Concurrent.EnumerablePartitionerOptions)\n  - System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IList{``0},System.Boolean)\n  langs:\n  - csharp\n  - vb\n  name: Partitioner\n  fullName: System.Collections.Concurrent.Partitioner\n  type: Class\n  source:\n    remote:\n      path: src/mscorlib/src/System/Collections/Concurrent/PartitionerStatic.cs\n      branch: master\n      repo: https://github.com/dotnet/coreclr.git\n    id: Partitioner\n    path: src/mscorlib/src/System/Collections/Concurrent/PartitionerStatic.cs\n    startLine: 73\n  assemblies:\n  - System.Collections.Concurrent\n  namespace: System.Collections.Concurrent\n  summary: \"\\n<p>Provides common partitioning strategies for arrays, lists, and enumerables.</p>\\n\"\n  syntax:\n    content: >-\n      [HostProtection(Synchronization = true, ExternalThreading = true)]\n\n      public class Partitioner\n    content.vb: >-\n      <HostProtection(Synchronization:=True, ExternalThreading:=True)>\n\n      Public Class Partitioner\n  inheritance:\n  - System.Object\n  inheritedMembers:\n  - System.Object.ToString\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  modifiers.csharp:\n  - public\n  - class\n  modifiers.vb:\n  - Public\n  - Class\n  nameWithType: Partitioner\n- uid: System.Collections.Concurrent.Partitioner.Create(System.Int32,System.Int32)\n  commentId: M:System.Collections.Concurrent.Partitioner.Create(System.Int32,System.Int32)\n  id: Create(System.Int32,System.Int32)\n  parent: System.Collections.Concurrent.Partitioner\n  langs:\n  - csharp\n  - vb\n  name: Create(Int32, Int32)\n  fullName: System.Collections.Concurrent.Partitioner.Create(System.Int32, System.Int32)\n  type: Method\n  source:\n    remote:\n      path: src/mscorlib/src/System/Collections/Concurrent/PartitionerStatic.cs\n      branch: master\n      repo: https://github.com/dotnet/coreclr.git\n    id: Create\n    path: src/mscorlib/src/System/Collections/Concurrent/PartitionerStatic.cs\n    startLine: 246\n  assemblies:\n  - System.Collections.Concurrent\n  namespace: System.Collections.Concurrent\n  summary: \"\\n<p>Creates a partitioner that chunks the user-specified range.</p>\\n\"\n  syntax:\n    content: public static OrderablePartitioner<Tuple<int, int>> Create(int fromInclusive, int toExclusive)\n    content.vb: Public Shared Function Create(fromInclusive As Integer, toExclusive As Integer) As OrderablePartitioner(Of Tuple(Of Integer, Integer))\n    parameters:\n    - id: fromInclusive\n      type: System.Int32\n      description: \"\\n<p>The lower, inclusive bound of the range.</p>\\n\"\n    - id: toExclusive\n      type: System.Int32\n      description: \"\\n<p>The upper, exclusive bound of the range.</p>\\n\"\n    return:\n      type: System.Collections.Concurrent.OrderablePartitioner{System.Tuple{System.Int32,System.Int32}}\n      description: \"\\n<p>A partitioner.</p>\\n\"\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"\\n<p>The <em>toExclusive</em> argument is less than or equal to the <em>fromInclusive</em> argument.</p>\\n\"\n  modifiers.csharp:\n  - public\n  - static\n  modifiers.vb:\n  - Public\n  - Shared\n  nameWithType: Partitioner.Create(Int32, Int32)\n- uid: System.Collections.Concurrent.Partitioner.Create(System.Int32,System.Int32,System.Int32)\n  commentId: M:System.Collections.Concurrent.Partitioner.Create(System.Int32,System.Int32,System.Int32)\n  id: Create(System.Int32,System.Int32,System.Int32)\n  parent: System.Collections.Concurrent.Partitioner\n  langs:\n  - csharp\n  - vb\n  name: Create(Int32, Int32, Int32)\n  fullName: System.Collections.Concurrent.Partitioner.Create(System.Int32, System.Int32, System.Int32)\n  type: Method\n  source:\n    remote:\n      path: src/mscorlib/src/System/Collections/Concurrent/PartitionerStatic.cs\n      branch: master\n      repo: https://github.com/dotnet/coreclr.git\n    id: Create\n    path: src/mscorlib/src/System/Collections/Concurrent/PartitionerStatic.cs\n    startLine: 269\n  assemblies:\n  - System.Collections.Concurrent\n  namespace: System.Collections.Concurrent\n  summary: \"\\n<p>Creates a partitioner that chunks the user-specified range.</p>\\n\"\n  syntax:\n    content: public static OrderablePartitioner<Tuple<int, int>> Create(int fromInclusive, int toExclusive, int rangeSize)\n    content.vb: Public Shared Function Create(fromInclusive As Integer, toExclusive As Integer, rangeSize As Integer) As OrderablePartitioner(Of Tuple(Of Integer, Integer))\n    parameters:\n    - id: fromInclusive\n      type: System.Int32\n      description: \"\\n<p>The lower, inclusive bound of the range.</p>\\n\"\n    - id: toExclusive\n      type: System.Int32\n      description: \"\\n<p>The upper, exclusive bound of the range.</p>\\n\"\n    - id: rangeSize\n      type: System.Int32\n      description: \"\\n<p>The size of each subrange.</p>\\n\"\n    return:\n      type: System.Collections.Concurrent.OrderablePartitioner{System.Tuple{System.Int32,System.Int32}}\n      description: \"\\n<p>A partitioner.</p>\\n\"\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"\\n<p>The <em>toExclusive</em> argument is less than or equal to the <em>fromInclusive</em> argument.</p>\\n<p>-or-</p>\\n<p>The <em>rangeSize</em> argument is less than or equal to 0.</p>\\n\"\n  modifiers.csharp:\n  - public\n  - static\n  modifiers.vb:\n  - Public\n  - Shared\n  nameWithType: Partitioner.Create(Int32, Int32, Int32)\n- uid: System.Collections.Concurrent.Partitioner.Create(System.Int64,System.Int64)\n  commentId: M:System.Collections.Concurrent.Partitioner.Create(System.Int64,System.Int64)\n  id: Create(System.Int64,System.Int64)\n  parent: System.Collections.Concurrent.Partitioner\n  langs:\n  - csharp\n  - vb\n  name: Create(Int64, Int64)\n  fullName: System.Collections.Concurrent.Partitioner.Create(System.Int64, System.Int64)\n  type: Method\n  source:\n    remote:\n      path: src/mscorlib/src/System/Collections/Concurrent/PartitionerStatic.cs\n      branch: master\n      repo: https://github.com/dotnet/coreclr.git\n    id: Create\n    path: src/mscorlib/src/System/Collections/Concurrent/PartitionerStatic.cs\n    startLine: 189\n  assemblies:\n  - System.Collections.Concurrent\n  namespace: System.Collections.Concurrent\n  summary: \"\\n<p>Creates a partitioner that chunks the user-specified range.</p>\\n\"\n  syntax:\n    content: public static OrderablePartitioner<Tuple<long, long>> Create(long fromInclusive, long toExclusive)\n    content.vb: Public Shared Function Create(fromInclusive As Long, toExclusive As Long) As OrderablePartitioner(Of Tuple(Of Long, Long))\n    parameters:\n    - id: fromInclusive\n      type: System.Int64\n      description: \"\\n<p>The lower, inclusive bound of the range.</p>\\n\"\n    - id: toExclusive\n      type: System.Int64\n      description: \"\\n<p>The upper, exclusive bound of the range.</p>\\n\"\n    return:\n      type: System.Collections.Concurrent.OrderablePartitioner{System.Tuple{System.Int64,System.Int64}}\n      description: \"\\n<p>A partitioner.</p>\\n\"\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"\\n<p>The <em>toExclusive</em> argument is less than or equal to the <em>fromInclusive</em> argument.</p>\\n\"\n  modifiers.csharp:\n  - public\n  - static\n  modifiers.vb:\n  - Public\n  - Shared\n  nameWithType: Partitioner.Create(Int64, Int64)\n- uid: System.Collections.Concurrent.Partitioner.Create(System.Int64,System.Int64,System.Int64)\n  commentId: M:System.Collections.Concurrent.Partitioner.Create(System.Int64,System.Int64,System.Int64)\n  id: Create(System.Int64,System.Int64,System.Int64)\n  parent: System.Collections.Concurrent.Partitioner\n  langs:\n  - csharp\n  - vb\n  name: Create(Int64, Int64, Int64)\n  fullName: System.Collections.Concurrent.Partitioner.Create(System.Int64, System.Int64, System.Int64)\n  type: Method\n  source:\n    remote:\n      path: src/mscorlib/src/System/Collections/Concurrent/PartitionerStatic.cs\n      branch: master\n      repo: https://github.com/dotnet/coreclr.git\n    id: Create\n    path: src/mscorlib/src/System/Collections/Concurrent/PartitionerStatic.cs\n    startLine: 212\n  assemblies:\n  - System.Collections.Concurrent\n  namespace: System.Collections.Concurrent\n  summary: \"\\n<p>Creates a partitioner that chunks the user-specified range.</p>\\n\"\n  syntax:\n    content: public static OrderablePartitioner<Tuple<long, long>> Create(long fromInclusive, long toExclusive, long rangeSize)\n    content.vb: Public Shared Function Create(fromInclusive As Long, toExclusive As Long, rangeSize As Long) As OrderablePartitioner(Of Tuple(Of Long, Long))\n    parameters:\n    - id: fromInclusive\n      type: System.Int64\n      description: \"\\n<p>The lower, inclusive bound of the range.</p>\\n\"\n    - id: toExclusive\n      type: System.Int64\n      description: \"\\n<p>The upper, exclusive bound of the range.</p>\\n\"\n    - id: rangeSize\n      type: System.Int64\n      description: \"\\n<p>The size of each subrange.</p>\\n\"\n    return:\n      type: System.Collections.Concurrent.OrderablePartitioner{System.Tuple{System.Int64,System.Int64}}\n      description: \"\\n<p>A partitioner.</p>\\n\"\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"\\n<p>The <em>toExclusive</em> argument is less than or equal to the <em>fromInclusive</em> argument.</p>\\n<p>-or-</p>\\n<p>The <em>rangeSize</em> argument is less than or equal to 0.</p>\\n\"\n  modifiers.csharp:\n  - public\n  - static\n  modifiers.vb:\n  - Public\n  - Shared\n  nameWithType: Partitioner.Create(Int64, Int64, Int64)\n- uid: System.Collections.Concurrent.Partitioner.Create``1(``0[],System.Boolean)\n  commentId: M:System.Collections.Concurrent.Partitioner.Create``1(``0[],System.Boolean)\n  id: Create``1(``0[],System.Boolean)\n  parent: System.Collections.Concurrent.Partitioner\n  langs:\n  - csharp\n  - vb\n  name: Create<TSource>(TSource[], Boolean)\n  fullName: System.Collections.Concurrent.Partitioner.Create<TSource>(TSource[], System.Boolean)\n  type: Method\n  source:\n    remote:\n      path: src/mscorlib/src/System/Collections/Concurrent/PartitionerStatic.cs\n      branch: master\n      repo: https://github.com/dotnet/coreclr.git\n    id: Create\n    path: src/mscorlib/src/System/Collections/Concurrent/PartitionerStatic.cs\n    startLine: 117\n  assemblies:\n  - System.Collections.Concurrent\n  namespace: System.Collections.Concurrent\n  summary: \"\\n<p>Creates an orderable partitioner from a <xref href=\\\"System.Array\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> instance.</p>\\n\"\n  syntax:\n    content: public static OrderablePartitioner<TSource> Create<TSource>(TSource[] array, bool loadBalance)\n    content.vb: Public Shared Function Create(Of TSource)(array As TSource(), loadBalance As Boolean) As OrderablePartitioner(Of TSource)\n    parameters:\n    - id: array\n      type: '{TSource}[]'\n      description: \"\\n<p>The array to be partitioned.</p>\\n\"\n    - id: loadBalance\n      type: System.Boolean\n      description: \"\\n<p>A Boolean value that indicates whether the created partitioner should dynamically load balance between partitions rather than statically partition.</p>\\n<p></p>\\n\"\n    typeParameters:\n    - id: TSource\n      description: \"\\n<p>Type of the elements in source array.</p>\\n\"\n    return:\n      type: System.Collections.Concurrent.OrderablePartitioner{{TSource}}\n      description: \"\\n<p>An orderable partitioner based on the input array.</p>\\n\"\n  modifiers.csharp:\n  - public\n  - static\n  modifiers.vb:\n  - Public\n  - Shared\n  fullName.vb: System.Collections.Concurrent.Partitioner.Create(Of TSource)(TSource(), System.Boolean)\n  name.vb: Create(Of TSource)(TSource(), Boolean)\n  nameWithType: Partitioner.Create<TSource>(TSource[], Boolean)\n  nameWithType.vb: Partitioner.Create(Of TSource)(TSource(), Boolean)\n- uid: System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IEnumerable{``0})\n  commentId: M:System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IEnumerable{``0})\n  id: Create``1(System.Collections.Generic.IEnumerable{``0})\n  parent: System.Collections.Concurrent.Partitioner\n  langs:\n  - csharp\n  - vb\n  name: Create<TSource>(IEnumerable<TSource>)\n  fullName: System.Collections.Concurrent.Partitioner.Create<TSource>(System.Collections.Generic.IEnumerable<TSource>)\n  type: Method\n  source:\n    remote:\n      path: src/mscorlib/src/System/Collections/Concurrent/PartitionerStatic.cs\n      branch: master\n      repo: https://github.com/dotnet/coreclr.git\n    id: Create\n    path: src/mscorlib/src/System/Collections/Concurrent/PartitionerStatic.cs\n    startLine: 148\n  assemblies:\n  - System.Collections.Concurrent\n  namespace: System.Collections.Concurrent\n  summary: \"\\n<p>Creates an orderable partitioner from a <xref href=\\\"System.Collections.Generic.IEnumerable`1\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> instance.</p>\\n\"\n  syntax:\n    content: public static OrderablePartitioner<TSource> Create<TSource>(IEnumerable<TSource> source)\n    content.vb: Public Shared Function Create(Of TSource)(source As IEnumerable(Of TSource)) As OrderablePartitioner(Of TSource)\n    parameters:\n    - id: source\n      type: System.Collections.Generic.IEnumerable{{TSource}}\n      description: \"\\n<p>The enumerable to be partitioned.</p>\\n\"\n    typeParameters:\n    - id: TSource\n      description: \"\\n<p>Type of the elements in source enumerable.</p>\\n\"\n    return:\n      type: System.Collections.Concurrent.OrderablePartitioner{{TSource}}\n      description: \"\\n<p>An orderable partitioner based on the input array.</p>\\n\"\n  modifiers.csharp:\n  - public\n  - static\n  modifiers.vb:\n  - Public\n  - Shared\n  fullName.vb: System.Collections.Concurrent.Partitioner.Create(Of TSource)(System.Collections.Generic.IEnumerable(Of TSource))\n  name.vb: Create(Of TSource)(IEnumerable(Of TSource))\n  nameWithType: Partitioner.Create<TSource>(IEnumerable<TSource>)\n  nameWithType.vb: Partitioner.Create(Of TSource)(IEnumerable(Of TSource))\n- uid: System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Concurrent.EnumerablePartitionerOptions)\n  commentId: M:System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Concurrent.EnumerablePartitionerOptions)\n  id: Create``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Concurrent.EnumerablePartitionerOptions)\n  parent: System.Collections.Concurrent.Partitioner\n  langs:\n  - csharp\n  - vb\n  name: Create<TSource>(IEnumerable<TSource>, EnumerablePartitionerOptions)\n  fullName: System.Collections.Concurrent.Partitioner.Create<TSource>(System.Collections.Generic.IEnumerable<TSource>, System.Collections.Concurrent.EnumerablePartitionerOptions)\n  type: Method\n  source:\n    remote:\n      path: src/mscorlib/src/System/Collections/Concurrent/PartitionerStatic.cs\n      branch: master\n      repo: https://github.com/dotnet/coreclr.git\n    id: Create\n    path: src/mscorlib/src/System/Collections/Concurrent/PartitionerStatic.cs\n    startLine: 170\n  assemblies:\n  - System.Collections.Concurrent\n  namespace: System.Collections.Concurrent\n  summary: \"\\n<p>Creates an orderable partitioner from a <xref href=\\\"System.Collections.Generic.IEnumerable`1\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> instance.</p>\\n\"\n  syntax:\n    content: public static OrderablePartitioner<TSource> Create<TSource>(IEnumerable<TSource> source, EnumerablePartitionerOptions partitionerOptions)\n    content.vb: Public Shared Function Create(Of TSource)(source As IEnumerable(Of TSource), partitionerOptions As EnumerablePartitionerOptions) As OrderablePartitioner(Of TSource)\n    parameters:\n    - id: source\n      type: System.Collections.Generic.IEnumerable{{TSource}}\n      description: \"\\n<p>The enumerable to be partitioned.</p>\\n\"\n    - id: partitionerOptions\n      type: System.Collections.Concurrent.EnumerablePartitionerOptions\n      description: \"\\n<p>Options to control the buffering behavior of the partitioner.</p>\\n\"\n    typeParameters:\n    - id: TSource\n      description: \"\\n<p>Type of the elements in source enumerable.</p>\\n\"\n    return:\n      type: System.Collections.Concurrent.OrderablePartitioner{{TSource}}\n      description: \"\\n<p>An orderable partitioner based on the input array.</p>\\n\"\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"\\n<p>The <em>partitionerOptions</em> argument specifies an invalid value for <xref href=\\\"System.Collections.Concurrent.EnumerablePartitionerOptions\\\" data-throw-if-not-resolved=\\\"false\\\"></xref>.</p>\\n\"\n  modifiers.csharp:\n  - public\n  - static\n  modifiers.vb:\n  - Public\n  - Shared\n  fullName.vb: System.Collections.Concurrent.Partitioner.Create(Of TSource)(System.Collections.Generic.IEnumerable(Of TSource), System.Collections.Concurrent.EnumerablePartitionerOptions)\n  name.vb: Create(Of TSource)(IEnumerable(Of TSource), EnumerablePartitionerOptions)\n  nameWithType: Partitioner.Create<TSource>(IEnumerable<TSource>, EnumerablePartitionerOptions)\n  nameWithType.vb: Partitioner.Create(Of TSource)(IEnumerable(Of TSource), EnumerablePartitionerOptions)\n- uid: System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IList{``0},System.Boolean)\n  commentId: M:System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IList{``0},System.Boolean)\n  id: Create``1(System.Collections.Generic.IList{``0},System.Boolean)\n  parent: System.Collections.Concurrent.Partitioner\n  langs:\n  - csharp\n  - vb\n  name: Create<TSource>(IList<TSource>, Boolean)\n  fullName: System.Collections.Concurrent.Partitioner.Create<TSource>(System.Collections.Generic.IList<TSource>, System.Boolean)\n  type: Method\n  source:\n    remote:\n      path: src/mscorlib/src/System/Collections/Concurrent/PartitionerStatic.cs\n      branch: master\n      repo: https://github.com/dotnet/coreclr.git\n    id: Create\n    path: src/mscorlib/src/System/Collections/Concurrent/PartitionerStatic.cs\n    startLine: 89\n  assemblies:\n  - System.Collections.Concurrent\n  namespace: System.Collections.Concurrent\n  summary: \"\\n<p>Creates an orderable partitioner from an <xref href=\\\"System.Collections.Generic.IList`1\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> instance.</p>\\n\"\n  syntax:\n    content: public static OrderablePartitioner<TSource> Create<TSource>(IList<TSource> list, bool loadBalance)\n    content.vb: Public Shared Function Create(Of TSource)(list As IList(Of TSource), loadBalance As Boolean) As OrderablePartitioner(Of TSource)\n    parameters:\n    - id: list\n      type: System.Collections.Generic.IList{{TSource}}\n      description: \"\\n<p>The list to be partitioned.</p>\\n\"\n    - id: loadBalance\n      type: System.Boolean\n      description: \"\\n<p>A Boolean value that indicates whether the created partitioner should dynamically load balance between partitions rather than statically partition.</p>\\n<p></p>\\n\"\n    typeParameters:\n    - id: TSource\n      description: \"\\n<p>Type of the elements in source list.</p>\\n\"\n    return:\n      type: System.Collections.Concurrent.OrderablePartitioner{{TSource}}\n      description: \"\\n<p>An orderable partitioner based on the input list.</p>\\n\"\n  modifiers.csharp:\n  - public\n  - static\n  modifiers.vb:\n  - Public\n  - Shared\n  fullName.vb: System.Collections.Concurrent.Partitioner.Create(Of TSource)(System.Collections.Generic.IList(Of TSource), System.Boolean)\n  name.vb: Create(Of TSource)(IList(Of TSource), Boolean)\n  nameWithType: Partitioner.Create<TSource>(IList<TSource>, Boolean)\n  nameWithType.vb: Partitioner.Create(Of TSource)(IList(Of TSource), Boolean)\nreferences:\n- uid: System.Collections.Concurrent\n  isExternal: false\n  name: System.Collections.Concurrent\n  fullName: System.Collections.Concurrent\n  nameWithType: System.Collections.Concurrent\n  commentId: N:System.Collections.Concurrent\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  fullName: System.Object\n  nameWithType: Object\n  commentId: T:System.Object\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: true\n  name: ToString()\n  fullName: System.Object.ToString()\n  spec.csharp:\n  - uid: System.Object.ToString\n    name: ToString\n    fullName: System.Object.ToString\n    isExternal: true\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Object.ToString\n    name: ToString\n    fullName: System.Object.ToString\n    isExternal: true\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  nameWithType: Object.ToString()\n  commentId: M:System.Object.ToString\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: true\n  name: Equals(Object)\n  fullName: System.Object.Equals(System.Object)\n  spec.csharp:\n  - uid: System.Object.Equals(System.Object)\n    name: Equals\n    fullName: System.Object.Equals\n    isExternal: true\n  - name: (\n    fullName: (\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Object.Equals(System.Object)\n    name: Equals\n    fullName: System.Object.Equals\n    isExternal: true\n  - name: (\n    fullName: (\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: )\n    fullName: )\n  nameWithType: Object.Equals(Object)\n  commentId: M:System.Object.Equals(System.Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: true\n  name: Equals(Object, Object)\n  fullName: System.Object.Equals(System.Object, System.Object)\n  spec.csharp:\n  - uid: System.Object.Equals(System.Object,System.Object)\n    name: Equals\n    fullName: System.Object.Equals\n    isExternal: true\n  - name: (\n    fullName: (\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: ', '\n    fullName: ', '\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Object.Equals(System.Object,System.Object)\n    name: Equals\n    fullName: System.Object.Equals\n    isExternal: true\n  - name: (\n    fullName: (\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: ', '\n    fullName: ', '\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: )\n    fullName: )\n  nameWithType: Object.Equals(Object, Object)\n  commentId: M:System.Object.Equals(System.Object,System.Object)\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: true\n  name: ReferenceEquals(Object, Object)\n  fullName: System.Object.ReferenceEquals(System.Object, System.Object)\n  spec.csharp:\n  - uid: System.Object.ReferenceEquals(System.Object,System.Object)\n    name: ReferenceEquals\n    fullName: System.Object.ReferenceEquals\n    isExternal: true\n  - name: (\n    fullName: (\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: ', '\n    fullName: ', '\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Object.ReferenceEquals(System.Object,System.Object)\n    name: ReferenceEquals\n    fullName: System.Object.ReferenceEquals\n    isExternal: true\n  - name: (\n    fullName: (\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: ', '\n    fullName: ', '\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: )\n    fullName: )\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  commentId: M:System.Object.ReferenceEquals(System.Object,System.Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: true\n  name: GetHashCode()\n  fullName: System.Object.GetHashCode()\n  spec.csharp:\n  - uid: System.Object.GetHashCode\n    name: GetHashCode\n    fullName: System.Object.GetHashCode\n    isExternal: true\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Object.GetHashCode\n    name: GetHashCode\n    fullName: System.Object.GetHashCode\n    isExternal: true\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  nameWithType: Object.GetHashCode()\n  commentId: M:System.Object.GetHashCode\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: true\n  name: GetType()\n  fullName: System.Object.GetType()\n  spec.csharp:\n  - uid: System.Object.GetType\n    name: GetType\n    fullName: System.Object.GetType\n    isExternal: true\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Object.GetType\n    name: GetType\n    fullName: System.Object.GetType\n    isExternal: true\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  nameWithType: Object.GetType()\n  commentId: M:System.Object.GetType\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: true\n  name: MemberwiseClone()\n  fullName: System.Object.MemberwiseClone()\n  spec.csharp:\n  - uid: System.Object.MemberwiseClone\n    name: MemberwiseClone\n    fullName: System.Object.MemberwiseClone\n    isExternal: true\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Object.MemberwiseClone\n    name: MemberwiseClone\n    fullName: System.Object.MemberwiseClone\n    isExternal: true\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  nameWithType: Object.MemberwiseClone()\n  commentId: M:System.Object.MemberwiseClone\n- uid: System\n  isExternal: false\n  name: System\n  fullName: System\n  nameWithType: System\n  commentId: N:System\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  fullName: System.Int32\n  nameWithType: Int32\n  commentId: T:System.Int32\n- uid: System.Collections.Concurrent.OrderablePartitioner{System.Tuple{System.Int32,System.Int32}}\n  parent: System.Collections.Concurrent\n  definition: System.Collections.Concurrent.OrderablePartitioner`1\n  name: OrderablePartitioner<Tuple<Int32, Int32>>\n  fullName: System.Collections.Concurrent.OrderablePartitioner<System.Tuple<System.Int32, System.Int32>>\n  fullname.vb: System.Collections.Concurrent.OrderablePartitioner(Of System.Tuple(Of System.Int32, System.Int32))\n  name.vb: OrderablePartitioner(Of Tuple(Of Int32, Int32))\n  spec.csharp:\n  - uid: System.Collections.Concurrent.OrderablePartitioner`1\n    name: OrderablePartitioner\n    fullName: System.Collections.Concurrent.OrderablePartitioner\n  - name: <\n    fullName: <\n  - uid: System.Tuple`2\n    name: Tuple\n    fullName: System.Tuple\n    isExternal: true\n  - name: <\n    fullName: <\n  - uid: System.Int32\n    name: Int32\n    fullName: System.Int32\n    isExternal: true\n  - name: ', '\n    fullName: ', '\n  - uid: System.Int32\n    name: Int32\n    fullName: System.Int32\n    isExternal: true\n  - name: '>'\n    fullName: '>'\n  - name: '>'\n    fullName: '>'\n  spec.vb:\n  - uid: System.Collections.Concurrent.OrderablePartitioner`1\n    name: OrderablePartitioner\n    fullName: System.Collections.Concurrent.OrderablePartitioner\n  - name: '(Of '\n    fullName: '(Of '\n  - uid: System.Tuple`2\n    name: Tuple\n    fullName: System.Tuple\n    isExternal: true\n  - name: '(Of '\n    fullName: '(Of '\n  - uid: System.Int32\n    name: Int32\n    fullName: System.Int32\n    isExternal: true\n  - name: ', '\n    fullName: ', '\n  - uid: System.Int32\n    name: Int32\n    fullName: System.Int32\n    isExternal: true\n  - name: )\n    fullName: )\n  - name: )\n    fullName: )\n  nameWithType: OrderablePartitioner<Tuple<Int32, Int32>>\n  nameWithType.vb: OrderablePartitioner(Of Tuple(Of Int32, Int32))\n  commentId: T:System.Collections.Concurrent.OrderablePartitioner{System.Tuple{System.Int32,System.Int32}}\n- uid: System.Collections.Concurrent.OrderablePartitioner`1\n  isExternal: false\n  name: OrderablePartitioner<TSource>\n  fullName: System.Collections.Concurrent.OrderablePartitioner<TSource>\n  fullname.vb: System.Collections.Concurrent.OrderablePartitioner(Of TSource)\n  name.vb: OrderablePartitioner(Of TSource)\n  spec.csharp:\n  - uid: System.Collections.Concurrent.OrderablePartitioner`1\n    name: OrderablePartitioner\n    fullName: System.Collections.Concurrent.OrderablePartitioner\n  - name: <\n    fullName: <\n  - name: TSource\n    fullName: TSource\n  - name: '>'\n    fullName: '>'\n  spec.vb:\n  - uid: System.Collections.Concurrent.OrderablePartitioner`1\n    name: OrderablePartitioner\n    fullName: System.Collections.Concurrent.OrderablePartitioner\n  - name: '(Of '\n    fullName: '(Of '\n  - name: TSource\n    fullName: TSource\n  - name: )\n    fullName: )\n  nameWithType: OrderablePartitioner<TSource>\n  nameWithType.vb: OrderablePartitioner(Of TSource)\n  commentId: T:System.Collections.Concurrent.OrderablePartitioner`1\n- uid: System.Int64\n  parent: System\n  isExternal: false\n  name: Int64\n  fullName: System.Int64\n  nameWithType: Int64\n  commentId: T:System.Int64\n- uid: System.Collections.Concurrent.OrderablePartitioner{System.Tuple{System.Int64,System.Int64}}\n  parent: System.Collections.Concurrent\n  definition: System.Collections.Concurrent.OrderablePartitioner`1\n  name: OrderablePartitioner<Tuple<Int64, Int64>>\n  fullName: System.Collections.Concurrent.OrderablePartitioner<System.Tuple<System.Int64, System.Int64>>\n  fullname.vb: System.Collections.Concurrent.OrderablePartitioner(Of System.Tuple(Of System.Int64, System.Int64))\n  name.vb: OrderablePartitioner(Of Tuple(Of Int64, Int64))\n  spec.csharp:\n  - uid: System.Collections.Concurrent.OrderablePartitioner`1\n    name: OrderablePartitioner\n    fullName: System.Collections.Concurrent.OrderablePartitioner\n  - name: <\n    fullName: <\n  - uid: System.Tuple`2\n    name: Tuple\n    fullName: System.Tuple\n    isExternal: true\n  - name: <\n    fullName: <\n  - uid: System.Int64\n    name: Int64\n    fullName: System.Int64\n    isExternal: true\n  - name: ', '\n    fullName: ', '\n  - uid: System.Int64\n    name: Int64\n    fullName: System.Int64\n    isExternal: true\n  - name: '>'\n    fullName: '>'\n  - name: '>'\n    fullName: '>'\n  spec.vb:\n  - uid: System.Collections.Concurrent.OrderablePartitioner`1\n    name: OrderablePartitioner\n    fullName: System.Collections.Concurrent.OrderablePartitioner\n  - name: '(Of '\n    fullName: '(Of '\n  - uid: System.Tuple`2\n    name: Tuple\n    fullName: System.Tuple\n    isExternal: true\n  - name: '(Of '\n    fullName: '(Of '\n  - uid: System.Int64\n    name: Int64\n    fullName: System.Int64\n    isExternal: true\n  - name: ', '\n    fullName: ', '\n  - uid: System.Int64\n    name: Int64\n    fullName: System.Int64\n    isExternal: true\n  - name: )\n    fullName: )\n  - name: )\n    fullName: )\n  nameWithType: OrderablePartitioner<Tuple<Int64, Int64>>\n  nameWithType.vb: OrderablePartitioner(Of Tuple(Of Int64, Int64))\n  commentId: T:System.Collections.Concurrent.OrderablePartitioner{System.Tuple{System.Int64,System.Int64}}\n- uid: '{TSource}[]'\n  name: TSource[]\n  fullName: TSource[]\n  fullname.vb: TSource()\n  name.vb: TSource()\n  spec.csharp:\n  - name: TSource\n    fullName: TSource\n  - name: '[]'\n    fullName: '[]'\n  spec.vb:\n  - name: TSource\n    fullName: TSource\n  - name: ()\n    fullName: ()\n  nameWithType: TSource[]\n  nameWithType.vb: TSource()\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  fullName: System.Boolean\n  nameWithType: Boolean\n  commentId: T:System.Boolean\n- uid: System.Collections.Concurrent.OrderablePartitioner{{TSource}}\n  parent: System.Collections.Concurrent\n  definition: System.Collections.Concurrent.OrderablePartitioner`1\n  name: OrderablePartitioner<TSource>\n  fullName: System.Collections.Concurrent.OrderablePartitioner<TSource>\n  fullname.vb: System.Collections.Concurrent.OrderablePartitioner(Of TSource)\n  name.vb: OrderablePartitioner(Of TSource)\n  spec.csharp:\n  - uid: System.Collections.Concurrent.OrderablePartitioner`1\n    name: OrderablePartitioner\n    fullName: System.Collections.Concurrent.OrderablePartitioner\n  - name: <\n    fullName: <\n  - name: TSource\n    fullName: TSource\n  - name: '>'\n    fullName: '>'\n  spec.vb:\n  - uid: System.Collections.Concurrent.OrderablePartitioner`1\n    name: OrderablePartitioner\n    fullName: System.Collections.Concurrent.OrderablePartitioner\n  - name: '(Of '\n    fullName: '(Of '\n  - name: TSource\n    fullName: TSource\n  - name: )\n    fullName: )\n  nameWithType: OrderablePartitioner<TSource>\n  nameWithType.vb: OrderablePartitioner(Of TSource)\n  commentId: T:System.Collections.Concurrent.OrderablePartitioner{``0}\n- uid: System.Collections.Generic.IEnumerable{{TSource}}\n  parent: System.Collections.Generic\n  definition: System.Collections.Generic.IEnumerable`1\n  name: IEnumerable<TSource>\n  fullName: System.Collections.Generic.IEnumerable<TSource>\n  fullname.vb: System.Collections.Generic.IEnumerable(Of TSource)\n  name.vb: IEnumerable(Of TSource)\n  spec.csharp:\n  - uid: System.Collections.Generic.IEnumerable`1\n    name: IEnumerable\n    fullName: System.Collections.Generic.IEnumerable\n    isExternal: true\n  - name: <\n    fullName: <\n  - name: TSource\n    fullName: TSource\n  - name: '>'\n    fullName: '>'\n  spec.vb:\n  - uid: System.Collections.Generic.IEnumerable`1\n    name: IEnumerable\n    fullName: System.Collections.Generic.IEnumerable\n    isExternal: true\n  - name: '(Of '\n    fullName: '(Of '\n  - name: TSource\n    fullName: TSource\n  - name: )\n    fullName: )\n  nameWithType: IEnumerable<TSource>\n  nameWithType.vb: IEnumerable(Of TSource)\n  commentId: T:System.Collections.Generic.IEnumerable{``0}\n- uid: System.Collections.Generic.IEnumerable`1\n  isExternal: false\n  name: IEnumerable<T>\n  fullName: System.Collections.Generic.IEnumerable<T>\n  fullname.vb: System.Collections.Generic.IEnumerable(Of T)\n  name.vb: IEnumerable(Of T)\n  spec.csharp:\n  - uid: System.Collections.Generic.IEnumerable`1\n    name: IEnumerable\n    fullName: System.Collections.Generic.IEnumerable\n  - name: <\n    fullName: <\n  - name: T\n    fullName: T\n  - name: '>'\n    fullName: '>'\n  spec.vb:\n  - uid: System.Collections.Generic.IEnumerable`1\n    name: IEnumerable\n    fullName: System.Collections.Generic.IEnumerable\n  - name: '(Of '\n    fullName: '(Of '\n  - name: T\n    fullName: T\n  - name: )\n    fullName: )\n  nameWithType: IEnumerable<T>\n  nameWithType.vb: IEnumerable(Of T)\n  commentId: T:System.Collections.Generic.IEnumerable`1\n- uid: System.Collections.Generic\n  isExternal: false\n  name: System.Collections.Generic\n  fullName: System.Collections.Generic\n  nameWithType: System.Collections.Generic\n  commentId: N:System.Collections.Generic\n- uid: System.Collections.Concurrent.EnumerablePartitionerOptions\n  parent: System.Collections.Concurrent\n  isExternal: false\n  name: EnumerablePartitionerOptions\n  fullName: System.Collections.Concurrent.EnumerablePartitionerOptions\n  nameWithType: EnumerablePartitionerOptions\n  commentId: T:System.Collections.Concurrent.EnumerablePartitionerOptions\n- uid: System.Collections.Generic.IList{{TSource}}\n  parent: System.Collections.Generic\n  definition: System.Collections.Generic.IList`1\n  name: IList<TSource>\n  fullName: System.Collections.Generic.IList<TSource>\n  fullname.vb: System.Collections.Generic.IList(Of TSource)\n  name.vb: IList(Of TSource)\n  spec.csharp:\n  - uid: System.Collections.Generic.IList`1\n    name: IList\n    fullName: System.Collections.Generic.IList\n    isExternal: true\n  - name: <\n    fullName: <\n  - name: TSource\n    fullName: TSource\n  - name: '>'\n    fullName: '>'\n  spec.vb:\n  - uid: System.Collections.Generic.IList`1\n    name: IList\n    fullName: System.Collections.Generic.IList\n    isExternal: true\n  - name: '(Of '\n    fullName: '(Of '\n  - name: TSource\n    fullName: TSource\n  - name: )\n    fullName: )\n  nameWithType: IList<TSource>\n  nameWithType.vb: IList(Of TSource)\n  commentId: T:System.Collections.Generic.IList{``0}\n- uid: System.Collections.Generic.IList`1\n  isExternal: false\n  name: IList<T>\n  fullName: System.Collections.Generic.IList<T>\n  fullname.vb: System.Collections.Generic.IList(Of T)\n  name.vb: IList(Of T)\n  spec.csharp:\n  - uid: System.Collections.Generic.IList`1\n    name: IList\n    fullName: System.Collections.Generic.IList\n  - name: <\n    fullName: <\n  - name: T\n    fullName: T\n  - name: '>'\n    fullName: '>'\n  spec.vb:\n  - uid: System.Collections.Generic.IList`1\n    name: IList\n    fullName: System.Collections.Generic.IList\n  - name: '(Of '\n    fullName: '(Of '\n  - name: T\n    fullName: T\n  - name: )\n    fullName: )\n  nameWithType: IList<T>\n  nameWithType.vb: IList(Of T)\n  commentId: T:System.Collections.Generic.IList`1\n- uid: System.ArgumentOutOfRangeException\n  isExternal: false\n  name: ArgumentOutOfRangeException\n  fullName: System.ArgumentOutOfRangeException\n  nameWithType: ArgumentOutOfRangeException\n  commentId: T:System.ArgumentOutOfRangeException\n"}