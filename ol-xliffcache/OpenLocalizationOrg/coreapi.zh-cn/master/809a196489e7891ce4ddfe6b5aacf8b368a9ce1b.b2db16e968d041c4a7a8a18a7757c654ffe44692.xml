{"nodes":[{"pos":[1886,1906],"content":"ReaderWriterLockSlim","needQuote":true,"nodes":[{"content":"ReaderWriterLockSlim","pos":[0,20]}]},{"pos":[3297,3319],"content":"ReaderWriterLockSlim()","needQuote":true,"nodes":[{"content":"ReaderWriterLockSlim()","pos":[0,22]}]},{"pos":[4542,4583],"content":"ReaderWriterLockSlim(LockRecursionPolicy)","needQuote":true,"nodes":[{"content":"ReaderWriterLockSlim(LockRecursionPolicy)","pos":[0,41]}]},{"content":"\\n&lt;p&gt;One of the enumeration values that specifies the lock recursion policy.&lt;/p&gt;\\n","pos":[5486,5568],"source":"\\n<p>One of the enumeration values that specifies the lock recursion policy.</p>\\n"},{"pos":[6192,6208],"content":"CurrentReadCount","needQuote":true,"nodes":[{"content":"CurrentReadCount","pos":[0,16]}]},{"content":"\\n&lt;p&gt;The number of unique threads that have entered the lock in read mode.&lt;/p&gt;\\n","pos":[6916,6996],"source":"\\n<p>The number of unique threads that have entered the lock in read mode.</p>\\n"},{"pos":[7363,7377],"content":"IsReadLockHeld","needQuote":true,"nodes":[{"content":"IsReadLockHeld","pos":[0,14]}]},{"content":"\\n&lt;p&gt;\\n&lt;strong&gt;true&lt;/strong&gt; if the current thread has entered read mode; otherwise, &lt;strong&gt;false&lt;/strong&gt;.&lt;/p&gt;\\n","pos":[8089,8203],"source":"\\n<p>\\n<strong>true</strong> if the current thread has entered read mode; otherwise, <strong>false</strong>.</p>\\n"},{"pos":[8601,8626],"content":"IsUpgradeableReadLockHeld","needQuote":true,"nodes":[{"content":"IsUpgradeableReadLockHeld","pos":[0,25]}]},{"content":"\\n&lt;p&gt;\\n&lt;strong&gt;true&lt;/strong&gt; if the current thread has entered upgradeable mode; otherwise, &lt;strong&gt;false&lt;/strong&gt;.&lt;/p&gt;\\n","pos":[9390,9511],"source":"\\n<p>\\n<strong>true</strong> if the current thread has entered upgradeable mode; otherwise, <strong>false</strong>.</p>\\n"},{"pos":[9890,9905],"content":"IsWriteLockHeld","needQuote":true,"nodes":[{"content":"IsWriteLockHeld","pos":[0,15]}]},{"content":"\\n&lt;p&gt;\\n&lt;strong&gt;true&lt;/strong&gt; if the current thread has entered write mode; otherwise, &lt;strong&gt;false&lt;/strong&gt;.&lt;/p&gt;\\n","pos":[10622,10737],"source":"\\n<p>\\n<strong>true</strong> if the current thread has entered write mode; otherwise, <strong>false</strong>.</p>\\n"},{"pos":[11106,11121],"content":"RecursionPolicy","needQuote":true,"nodes":[{"content":"RecursionPolicy","pos":[0,15]}]},{"content":"\\n&lt;p&gt;One of the enumeration values that specifies the lock recursion policy.&lt;/p&gt;\\n","pos":[11967,12049],"source":"\\n<p>One of the enumeration values that specifies the lock recursion policy.</p>\\n"},{"pos":[12545,12563],"content":"RecursiveReadCount","needQuote":true,"nodes":[{"content":"RecursiveReadCount","pos":[0,18]}]},{"content":"\\n&lt;p&gt;0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or n if the thread has entered the lock recursively n - 1 times.&lt;/p&gt;\\n","pos":[13308,13515],"source":"\\n<p>0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or n if the thread has entered the lock recursively n - 1 times.</p>\\n"},{"pos":[13905,13926],"content":"RecursiveUpgradeCount","needQuote":true,"nodes":[{"content":"RecursiveUpgradeCount","pos":[0,21]}]},{"content":"\\n&lt;p&gt;0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or n if the thread has entered upgradeable mode recursively n - 1 times.&lt;/p&gt;\\n","pos":[14690,14912],"source":"\\n<p>0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or n if the thread has entered upgradeable mode recursively n - 1 times.</p>\\n"},{"pos":[15299,15318],"content":"RecursiveWriteCount","needQuote":true,"nodes":[{"content":"RecursiveWriteCount","pos":[0,19]}]},{"content":"\\n&lt;p&gt;0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or n if the thread has entered write mode recursively n - 1 times.&lt;/p&gt;\\n","pos":[16068,16272],"source":"\\n<p>0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or n if the thread has entered write mode recursively n - 1 times.</p>\\n"},{"pos":[16648,16664],"content":"WaitingReadCount","needQuote":true,"nodes":[{"content":"WaitingReadCount","pos":[0,16]}]},{"content":"\\n&lt;p&gt;The total number of threads that are waiting to enter read mode.&lt;/p&gt;\\n","pos":[17373,17448],"source":"\\n<p>The total number of threads that are waiting to enter read mode.</p>\\n"},{"pos":[17830,17849],"content":"WaitingUpgradeCount","needQuote":true,"nodes":[{"content":"WaitingUpgradeCount","pos":[0,19]}]},{"content":"\\n&lt;p&gt;The total number of threads that are waiting to enter upgradeable mode.&lt;/p&gt;\\n","pos":[18577,18659],"source":"\\n<p>The total number of threads that are waiting to enter upgradeable mode.</p>\\n"},{"pos":[19038,19055],"content":"WaitingWriteCount","needQuote":true,"nodes":[{"content":"WaitingWriteCount","pos":[0,17]}]},{"content":"\\n&lt;p&gt;The total number of threads that are waiting to enter write mode.&lt;/p&gt;\\n","pos":[19769,19845],"source":"\\n<p>The total number of threads that are waiting to enter write mode.</p>\\n"},{"pos":[20192,20201],"content":"Dispose()","needQuote":true,"nodes":[{"content":"Dispose()","pos":[0,9]}]},{"pos":[21857,21872],"content":"EnterReadLock()","needQuote":true,"nodes":[{"content":"EnterReadLock()","pos":[0,15]}]},{"pos":[24156,24182],"content":"EnterUpgradeableReadLock()","needQuote":true,"nodes":[{"content":"EnterUpgradeableReadLock()","pos":[0,26]}]},{"pos":[26132,26148],"content":"EnterWriteLock()","needQuote":true,"nodes":[{"content":"EnterWriteLock()","pos":[0,16]}]},{"pos":[28042,28056],"content":"ExitReadLock()","needQuote":true,"nodes":[{"content":"ExitReadLock()","pos":[0,14]}]},{"content":"\\n&lt;p&gt;The current thread has not entered the lock in read mode.","pos":[28810,28872],"source":"\\n<p>The current thread has not entered the lock in read mode."},{"content":"&lt;/p&gt;\\n","pos":[28873,28879],"source":" </p>\\n"},{"pos":[29250,29275],"content":"ExitUpgradeableReadLock()","needQuote":true,"nodes":[{"content":"ExitUpgradeableReadLock()","pos":[0,25]}]},{"content":"\\n&lt;p&gt;The current thread has not entered the lock in upgradeable mode.&lt;/p&gt;\\n","pos":[30087,30162],"source":"\\n<p>The current thread has not entered the lock in upgradeable mode.</p>\\n"},{"pos":[30514,30529],"content":"ExitWriteLock()","needQuote":true,"nodes":[{"content":"ExitWriteLock()","pos":[0,15]}]},{"content":"\\n&lt;p&gt;The current thread has not entered the lock in write mode.&lt;/p&gt;\\n","pos":[31289,31358],"source":"\\n<p>The current thread has not entered the lock in write mode.</p>\\n"},{"pos":[31751,31774],"content":"TryEnterReadLock(Int32)","needQuote":true,"nodes":[{"content":"TryEnterReadLock(Int32)","pos":[0,23]}]},{"content":"\\n&lt;p&gt;\\n&lt;strong&gt;true&lt;/strong&gt; if the calling thread entered read mode, otherwise, &lt;strong&gt;false&lt;/strong&gt;.&lt;/p&gt;\\n","pos":[32772,32882],"source":"\\n<p>\\n<strong>true</strong> if the calling thread entered read mode, otherwise, <strong>false</strong>.</p>\\n"},{"pos":[34482,34508],"content":"TryEnterReadLock(TimeSpan)","needQuote":true,"nodes":[{"content":"TryEnterReadLock(TimeSpan)","pos":[0,26]}]},{"content":"\\n&lt;p&gt;The interval to wait, or -1 milliseconds to wait indefinitely.","pos":[35243,35310],"source":"\\n<p>The interval to wait, or -1 milliseconds to wait indefinitely."},{"content":"&lt;/p&gt;\\n","pos":[35311,35317],"source":" </p>\\n"},{"content":"\\n&lt;p&gt;\\n&lt;strong&gt;true&lt;/strong&gt; if the calling thread entered read mode, otherwise, &lt;strong&gt;false&lt;/strong&gt;.&lt;/p&gt;\\n","pos":[35378,35488],"source":"\\n<p>\\n<strong>true</strong> if the calling thread entered read mode, otherwise, <strong>false</strong>.</p>\\n"},{"pos":[37184,37218],"content":"TryEnterUpgradeableReadLock(Int32)","needQuote":true,"nodes":[{"content":"TryEnterUpgradeableReadLock(Int32)","pos":[0,34]}]},{"content":"\\n&lt;p&gt;\\n&lt;strong&gt;true&lt;/strong&gt; if the calling thread entered upgradeable mode, otherwise, &lt;strong&gt;false&lt;/strong&gt;.&lt;/p&gt;\\n","pos":[38259,38376],"source":"\\n<p>\\n<strong>true</strong> if the calling thread entered upgradeable mode, otherwise, <strong>false</strong>.</p>\\n"},{"pos":[40194,40231],"content":"TryEnterUpgradeableReadLock(TimeSpan)","needQuote":true,"nodes":[{"content":"TryEnterUpgradeableReadLock(TimeSpan)","pos":[0,37]}]},{"content":"\\n&lt;p&gt;The interval to wait, or -1 milliseconds to wait indefinitely.&lt;/p&gt;\\n","pos":[41017,41090],"source":"\\n<p>The interval to wait, or -1 milliseconds to wait indefinitely.</p>\\n"},{"content":"\\n&lt;p&gt;\\n&lt;strong&gt;true&lt;/strong&gt; if the calling thread entered upgradeable mode, otherwise, &lt;strong&gt;false&lt;/strong&gt;.&lt;/p&gt;\\n","pos":[41151,41268],"source":"\\n<p>\\n<strong>true</strong> if the calling thread entered upgradeable mode, otherwise, <strong>false</strong>.</p>\\n"},{"pos":[43118,43142],"content":"TryEnterWriteLock(Int32)","needQuote":true,"nodes":[{"content":"TryEnterWriteLock(Int32)","pos":[0,24]}]},{"content":"\\n&lt;p&gt;\\n&lt;strong&gt;true&lt;/strong&gt; if the calling thread entered write mode, otherwise, &lt;strong&gt;false&lt;/strong&gt;.&lt;/p&gt;\\n","pos":[44137,44248],"source":"\\n<p>\\n<strong>true</strong> if the calling thread entered write mode, otherwise, <strong>false</strong>.</p>\\n"},{"pos":[46020,46047],"content":"TryEnterWriteLock(TimeSpan)","needQuote":true,"nodes":[{"content":"TryEnterWriteLock(TimeSpan)","pos":[0,27]}]},{"content":"\\n&lt;p&gt;The interval to wait, or -1 milliseconds to wait indefinitely.&lt;/p&gt;\\n","pos":[46787,46860],"source":"\\n<p>The interval to wait, or -1 milliseconds to wait indefinitely.</p>\\n"},{"content":"\\n&lt;p&gt;\\n&lt;strong&gt;true&lt;/strong&gt; if the calling thread entered write mode, otherwise, &lt;strong&gt;false&lt;/strong&gt;.&lt;/p&gt;\\n","pos":[46921,47032],"source":"\\n<p>\\n<strong>true</strong> if the calling thread entered write mode, otherwise, <strong>false</strong>.</p>\\n"},{"pos":[48647,48663],"content":"System.Threading","needQuote":true,"nodes":[{"content":"System.Threading","pos":[0,16]}]},{"pos":[48824,48830],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"pos":[48980,48991],"content":"IDisposable","needQuote":true,"nodes":[{"content":"IDisposable","pos":[0,11]}]},{"pos":[49166,49176],"content":"ToString()","needQuote":true,"nodes":[{"content":"ToString()","pos":[0,10]}]},{"pos":[49271,49279],"content":"ToString","needQuote":true,"nodes":[{"content":"ToString","pos":[0,8]}]},{"pos":[49348,49349],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[49376,49377],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[49447,49455],"content":"ToString","needQuote":true,"nodes":[{"content":"ToString","pos":[0,8]}]},{"pos":[49524,49525],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[49552,49553],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[49736,49750],"content":"Equals(Object)","needQuote":true,"nodes":[{"content":"Equals(Object)","pos":[0,14]}]},{"pos":[49869,49875],"content":"Equals","needQuote":true,"nodes":[{"content":"Equals","pos":[0,6]}]},{"pos":[49942,49943],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[49993,49999],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"pos":[50059,50060],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[50143,50149],"content":"Equals","needQuote":true,"nodes":[{"content":"Equals","pos":[0,6]}]},{"pos":[50216,50217],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[50267,50273],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"pos":[50333,50334],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[50548,50570],"content":"Equals(Object, Object)","needQuote":true,"nodes":[{"content":"Equals(Object, Object)","pos":[0,22]}]},{"pos":[50718,50724],"content":"Equals","needQuote":true,"nodes":[{"content":"Equals","pos":[0,6]}]},{"pos":[50791,50792],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[50842,50848],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"content":",","pos":[50909,50910]},{"pos":[50965,50971],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"pos":[51031,51032],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[51129,51135],"content":"Equals","needQuote":true,"nodes":[{"content":"Equals","pos":[0,6]}]},{"pos":[51202,51203],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[51253,51259],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"content":",","pos":[51320,51321]},{"pos":[51376,51382],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"pos":[51442,51443],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[51688,51719],"content":"ReferenceEquals(Object, Object)","needQuote":true,"nodes":[{"content":"ReferenceEquals(Object, Object)","pos":[0,31]}]},{"pos":[51885,51900],"content":"ReferenceEquals","needQuote":true,"nodes":[{"content":"ReferenceEquals","pos":[0,15]}]},{"pos":[51976,51977],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[52027,52033],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"content":",","pos":[52094,52095]},{"pos":[52150,52156],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"pos":[52216,52217],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[52323,52338],"content":"ReferenceEquals","needQuote":true,"nodes":[{"content":"ReferenceEquals","pos":[0,15]}]},{"pos":[52414,52415],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[52465,52471],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"content":",","pos":[52532,52533]},{"pos":[52588,52594],"content":"Object","needQuote":true,"nodes":[{"content":"Object","pos":[0,6]}]},{"pos":[52654,52655],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[52885,52898],"content":"GetHashCode()","needQuote":true,"nodes":[{"content":"GetHashCode()","pos":[0,13]}]},{"pos":[52999,53010],"content":"GetHashCode","needQuote":true,"nodes":[{"content":"GetHashCode","pos":[0,11]}]},{"pos":[53082,53083],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[53110,53111],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[53184,53195],"content":"GetHashCode","needQuote":true,"nodes":[{"content":"GetHashCode","pos":[0,11]}]},{"pos":[53267,53268],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[53295,53296],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[53471,53480],"content":"GetType()","needQuote":true,"nodes":[{"content":"GetType()","pos":[0,9]}]},{"pos":[53573,53580],"content":"GetType","needQuote":true,"nodes":[{"content":"GetType","pos":[0,7]}]},{"pos":[53648,53649],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[53676,53677],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[53746,53753],"content":"GetType","needQuote":true,"nodes":[{"content":"GetType","pos":[0,7]}]},{"pos":[53821,53822],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[53849,53850],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[54025,54042],"content":"MemberwiseClone()","needQuote":true,"nodes":[{"content":"MemberwiseClone()","pos":[0,17]}]},{"pos":[54151,54166],"content":"MemberwiseClone","needQuote":true,"nodes":[{"content":"MemberwiseClone","pos":[0,15]}]},{"pos":[54242,54243],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[54270,54271],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[54348,54363],"content":"MemberwiseClone","needQuote":true,"nodes":[{"content":"MemberwiseClone","pos":[0,15]}]},{"pos":[54439,54440],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[54467,54468],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[54613,54619],"content":"System","needQuote":true,"nodes":[{"content":"System","pos":[0,6]}]},{"pos":[54783,54802],"content":"LockRecursionPolicy","needQuote":true,"nodes":[{"content":"LockRecursionPolicy","pos":[0,19]}]},{"pos":[55005,55010],"content":"Int32","needQuote":true,"nodes":[{"content":"Int32","pos":[0,5]}]},{"pos":[55153,55160],"content":"Boolean","needQuote":true,"nodes":[{"content":"Boolean","pos":[0,7]}]},{"pos":[55333,55342],"content":"Dispose()","needQuote":true,"nodes":[{"content":"Dispose()","pos":[0,9]}]},{"pos":[55445,55452],"content":"Dispose","needQuote":true,"nodes":[{"content":"Dispose","pos":[0,7]}]},{"pos":[55504,55505],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[55532,55533],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[55607,55614],"content":"Dispose","needQuote":true,"nodes":[{"content":"Dispose","pos":[0,7]}]},{"pos":[55666,55667],"content":"(","needQuote":true,"nodes":[{"content":"(","pos":[0,1]}]},{"pos":[55694,55695],"content":")","needQuote":true,"nodes":[{"content":")","pos":[0,1]}]},{"pos":[55860,55868],"content":"TimeSpan","needQuote":true,"nodes":[{"content":"TimeSpan","pos":[0,8]}]},{"pos":[56034,56062],"content":"SynchronizationLockException","needQuote":true,"nodes":[{"content":"SynchronizationLockException","pos":[0,28]}]},{"pos":[56302,56324],"content":"LockRecursionException","needQuote":true,"nodes":[{"content":"LockRecursionException","pos":[0,22]}]},{"pos":[56537,56560],"content":"ObjectDisposedException","needQuote":true,"nodes":[{"content":"ObjectDisposedException","pos":[0,23]}]},{"pos":[56760,56787],"content":"ArgumentOutOfRangeException","needQuote":true,"nodes":[{"content":"ArgumentOutOfRangeException","pos":[0,27]}]}],"content":"items:\n- uid: System.Threading.ReaderWriterLockSlim\n  commentId: T:System.Threading.ReaderWriterLockSlim\n  id: ReaderWriterLockSlim\n  parent: System.Threading\n  children:\n  - System.Threading.ReaderWriterLockSlim.#ctor\n  - System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)\n  - System.Threading.ReaderWriterLockSlim.CurrentReadCount\n  - System.Threading.ReaderWriterLockSlim.Dispose\n  - System.Threading.ReaderWriterLockSlim.EnterReadLock\n  - System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock\n  - System.Threading.ReaderWriterLockSlim.EnterWriteLock\n  - System.Threading.ReaderWriterLockSlim.ExitReadLock\n  - System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock\n  - System.Threading.ReaderWriterLockSlim.ExitWriteLock\n  - System.Threading.ReaderWriterLockSlim.IsReadLockHeld\n  - System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld\n  - System.Threading.ReaderWriterLockSlim.IsWriteLockHeld\n  - System.Threading.ReaderWriterLockSlim.RecursionPolicy\n  - System.Threading.ReaderWriterLockSlim.RecursiveReadCount\n  - System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount\n  - System.Threading.ReaderWriterLockSlim.RecursiveWriteCount\n  - System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)\n  - System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)\n  - System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)\n  - System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)\n  - System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)\n  - System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)\n  - System.Threading.ReaderWriterLockSlim.WaitingReadCount\n  - System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount\n  - System.Threading.ReaderWriterLockSlim.WaitingWriteCount\n  langs:\n  - csharp\n  - vb\n  name: ReaderWriterLockSlim\n  fullName: System.Threading.ReaderWriterLockSlim\n  type: Class\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: ReaderWriterLockSlim\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 215\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.</p>\\n\"\n  syntax:\n    content: 'public class ReaderWriterLockSlim : IDisposable'\n    content.vb: >-\n      Public Class ReaderWriterLockSlim\n          Implements IDisposable\n  inheritance:\n  - System.Object\n  implements:\n  - System.IDisposable\n  inheritedMembers:\n  - System.Object.ToString\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  modifiers.csharp:\n  - public\n  - class\n  modifiers.vb:\n  - Public\n  - Class\n  nameWithType: ReaderWriterLockSlim\n- uid: System.Threading.ReaderWriterLockSlim.#ctor\n  commentId: M:System.Threading.ReaderWriterLockSlim.#ctor\n  id: '#ctor'\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: ReaderWriterLockSlim()\n  fullName: System.Threading.ReaderWriterLockSlim.ReaderWriterLockSlim()\n  type: Constructor\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: .ctor\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 217\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Initializes a new instance of the <xref href=\\\"System.Threading.ReaderWriterLockSlim\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> class with default property values.</p>\\n\"\n  syntax:\n    content: public ReaderWriterLockSlim()\n    content.vb: Public Sub New\n  seealso:\n  - type: System.Threading.LockRecursionPolicy\n    commentId: T:System.Threading.LockRecursionPolicy\n  modifiers.csharp:\n  - public\n  modifiers.vb:\n  - Public\n  nameWithType: ReaderWriterLockSlim.ReaderWriterLockSlim()\n- uid: System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)\n  commentId: M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)\n  id: '#ctor(System.Threading.LockRecursionPolicy)'\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: ReaderWriterLockSlim(LockRecursionPolicy)\n  fullName: System.Threading.ReaderWriterLockSlim.ReaderWriterLockSlim(System.Threading.LockRecursionPolicy)\n  type: Constructor\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: .ctor\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 218\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Initializes a new instance of the <xref href=\\\"System.Threading.ReaderWriterLockSlim\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> class, specifying the lock recursion policy.</p>\\n\"\n  syntax:\n    content: public ReaderWriterLockSlim(LockRecursionPolicy recursionPolicy)\n    content.vb: Public Sub New(recursionPolicy As LockRecursionPolicy)\n    parameters:\n    - id: recursionPolicy\n      type: System.Threading.LockRecursionPolicy\n      description: \"\\n<p>One of the enumeration values that specifies the lock recursion policy.</p>\\n\"\n  seealso:\n  - type: System.Threading.LockRecursionPolicy\n    commentId: T:System.Threading.LockRecursionPolicy\n  - type: System.Threading.ReaderWriterLockSlim.RecursionPolicy\n    commentId: P:System.Threading.ReaderWriterLockSlim.RecursionPolicy\n  modifiers.csharp:\n  - public\n  modifiers.vb:\n  - Public\n  nameWithType: ReaderWriterLockSlim.ReaderWriterLockSlim(LockRecursionPolicy)\n- uid: System.Threading.ReaderWriterLockSlim.CurrentReadCount\n  commentId: P:System.Threading.ReaderWriterLockSlim.CurrentReadCount\n  id: CurrentReadCount\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: CurrentReadCount\n  fullName: System.Threading.ReaderWriterLockSlim.CurrentReadCount\n  type: Property\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: CurrentReadCount\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 219\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Gets the total number of unique threads that have entered the lock in read mode.</p>\\n\"\n  syntax:\n    content: public int CurrentReadCount { get; }\n    content.vb: Public ReadOnly Property CurrentReadCount As Integer\n    parameters: []\n    return:\n      type: System.Int32\n      description: \"\\n<p>The number of unique threads that have entered the lock in read mode.</p>\\n\"\n  modifiers.csharp:\n  - public\n  - get\n  modifiers.vb:\n  - Public\n  - ReadOnly\n  nameWithType: ReaderWriterLockSlim.CurrentReadCount\n- uid: System.Threading.ReaderWriterLockSlim.IsReadLockHeld\n  commentId: P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld\n  id: IsReadLockHeld\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: IsReadLockHeld\n  fullName: System.Threading.ReaderWriterLockSlim.IsReadLockHeld\n  type: Property\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: IsReadLockHeld\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 220\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Gets a value that indicates whether the current thread has entered the lock in read mode.</p>\\n\"\n  syntax:\n    content: public bool IsReadLockHeld { get; }\n    content.vb: Public ReadOnly Property IsReadLockHeld As Boolean\n    parameters: []\n    return:\n      type: System.Boolean\n      description: \"\\n<p>\\n<strong>true</strong> if the current thread has entered read mode; otherwise, <strong>false</strong>.</p>\\n\"\n  modifiers.csharp:\n  - public\n  - get\n  modifiers.vb:\n  - Public\n  - ReadOnly\n  nameWithType: ReaderWriterLockSlim.IsReadLockHeld\n- uid: System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld\n  commentId: P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld\n  id: IsUpgradeableReadLockHeld\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: IsUpgradeableReadLockHeld\n  fullName: System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld\n  type: Property\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: IsUpgradeableReadLockHeld\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 221\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Gets a value that indicates whether the current thread has entered the lock in upgradeable mode. </p>\\n\"\n  syntax:\n    content: public bool IsUpgradeableReadLockHeld { get; }\n    content.vb: Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean\n    parameters: []\n    return:\n      type: System.Boolean\n      description: \"\\n<p>\\n<strong>true</strong> if the current thread has entered upgradeable mode; otherwise, <strong>false</strong>.</p>\\n\"\n  modifiers.csharp:\n  - public\n  - get\n  modifiers.vb:\n  - Public\n  - ReadOnly\n  nameWithType: ReaderWriterLockSlim.IsUpgradeableReadLockHeld\n- uid: System.Threading.ReaderWriterLockSlim.IsWriteLockHeld\n  commentId: P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld\n  id: IsWriteLockHeld\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: IsWriteLockHeld\n  fullName: System.Threading.ReaderWriterLockSlim.IsWriteLockHeld\n  type: Property\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: IsWriteLockHeld\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 222\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Gets a value that indicates whether the current thread has entered the lock in write mode.</p>\\n\"\n  syntax:\n    content: public bool IsWriteLockHeld { get; }\n    content.vb: Public ReadOnly Property IsWriteLockHeld As Boolean\n    parameters: []\n    return:\n      type: System.Boolean\n      description: \"\\n<p>\\n<strong>true</strong> if the current thread has entered write mode; otherwise, <strong>false</strong>.</p>\\n\"\n  modifiers.csharp:\n  - public\n  - get\n  modifiers.vb:\n  - Public\n  - ReadOnly\n  nameWithType: ReaderWriterLockSlim.IsWriteLockHeld\n- uid: System.Threading.ReaderWriterLockSlim.RecursionPolicy\n  commentId: P:System.Threading.ReaderWriterLockSlim.RecursionPolicy\n  id: RecursionPolicy\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: RecursionPolicy\n  fullName: System.Threading.ReaderWriterLockSlim.RecursionPolicy\n  type: Property\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: RecursionPolicy\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 223\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Gets a value that indicates the recursion policy for the current <xref href=\\\"System.Threading.ReaderWriterLockSlim\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> object.</p>\\n\"\n  syntax:\n    content: public LockRecursionPolicy RecursionPolicy { get; }\n    content.vb: Public ReadOnly Property RecursionPolicy As LockRecursionPolicy\n    parameters: []\n    return:\n      type: System.Threading.LockRecursionPolicy\n      description: \"\\n<p>One of the enumeration values that specifies the lock recursion policy.</p>\\n\"\n  seealso:\n  - type: System.Threading.LockRecursionException\n    commentId: T:System.Threading.LockRecursionException\n  modifiers.csharp:\n  - public\n  - get\n  modifiers.vb:\n  - Public\n  - ReadOnly\n  nameWithType: ReaderWriterLockSlim.RecursionPolicy\n- uid: System.Threading.ReaderWriterLockSlim.RecursiveReadCount\n  commentId: P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount\n  id: RecursiveReadCount\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: RecursiveReadCount\n  fullName: System.Threading.ReaderWriterLockSlim.RecursiveReadCount\n  type: Property\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: RecursiveReadCount\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 224\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.</p>\\n\"\n  syntax:\n    content: public int RecursiveReadCount { get; }\n    content.vb: Public ReadOnly Property RecursiveReadCount As Integer\n    parameters: []\n    return:\n      type: System.Int32\n      description: \"\\n<p>0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or n if the thread has entered the lock recursively n - 1 times.</p>\\n\"\n  modifiers.csharp:\n  - public\n  - get\n  modifiers.vb:\n  - Public\n  - ReadOnly\n  nameWithType: ReaderWriterLockSlim.RecursiveReadCount\n- uid: System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount\n  commentId: P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount\n  id: RecursiveUpgradeCount\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: RecursiveUpgradeCount\n  fullName: System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount\n  type: Property\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: RecursiveUpgradeCount\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 225\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.</p>\\n\"\n  syntax:\n    content: public int RecursiveUpgradeCount { get; }\n    content.vb: Public ReadOnly Property RecursiveUpgradeCount As Integer\n    parameters: []\n    return:\n      type: System.Int32\n      description: \"\\n<p>0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or n if the thread has entered upgradeable mode recursively n - 1 times.</p>\\n\"\n  modifiers.csharp:\n  - public\n  - get\n  modifiers.vb:\n  - Public\n  - ReadOnly\n  nameWithType: ReaderWriterLockSlim.RecursiveUpgradeCount\n- uid: System.Threading.ReaderWriterLockSlim.RecursiveWriteCount\n  commentId: P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount\n  id: RecursiveWriteCount\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: RecursiveWriteCount\n  fullName: System.Threading.ReaderWriterLockSlim.RecursiveWriteCount\n  type: Property\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: RecursiveWriteCount\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 226\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.</p>\\n\"\n  syntax:\n    content: public int RecursiveWriteCount { get; }\n    content.vb: Public ReadOnly Property RecursiveWriteCount As Integer\n    parameters: []\n    return:\n      type: System.Int32\n      description: \"\\n<p>0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or n if the thread has entered write mode recursively n - 1 times.</p>\\n\"\n  modifiers.csharp:\n  - public\n  - get\n  modifiers.vb:\n  - Public\n  - ReadOnly\n  nameWithType: ReaderWriterLockSlim.RecursiveWriteCount\n- uid: System.Threading.ReaderWriterLockSlim.WaitingReadCount\n  commentId: P:System.Threading.ReaderWriterLockSlim.WaitingReadCount\n  id: WaitingReadCount\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: WaitingReadCount\n  fullName: System.Threading.ReaderWriterLockSlim.WaitingReadCount\n  type: Property\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: WaitingReadCount\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 227\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Gets the total number of threads that are waiting to enter the lock in read mode.</p>\\n\"\n  syntax:\n    content: public int WaitingReadCount { get; }\n    content.vb: Public ReadOnly Property WaitingReadCount As Integer\n    parameters: []\n    return:\n      type: System.Int32\n      description: \"\\n<p>The total number of threads that are waiting to enter read mode.</p>\\n\"\n  modifiers.csharp:\n  - public\n  - get\n  modifiers.vb:\n  - Public\n  - ReadOnly\n  nameWithType: ReaderWriterLockSlim.WaitingReadCount\n- uid: System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount\n  commentId: P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount\n  id: WaitingUpgradeCount\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: WaitingUpgradeCount\n  fullName: System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount\n  type: Property\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: WaitingUpgradeCount\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 228\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Gets the total number of threads that are waiting to enter the lock in upgradeable mode.</p>\\n\"\n  syntax:\n    content: public int WaitingUpgradeCount { get; }\n    content.vb: Public ReadOnly Property WaitingUpgradeCount As Integer\n    parameters: []\n    return:\n      type: System.Int32\n      description: \"\\n<p>The total number of threads that are waiting to enter upgradeable mode.</p>\\n\"\n  modifiers.csharp:\n  - public\n  - get\n  modifiers.vb:\n  - Public\n  - ReadOnly\n  nameWithType: ReaderWriterLockSlim.WaitingUpgradeCount\n- uid: System.Threading.ReaderWriterLockSlim.WaitingWriteCount\n  commentId: P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount\n  id: WaitingWriteCount\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: WaitingWriteCount\n  fullName: System.Threading.ReaderWriterLockSlim.WaitingWriteCount\n  type: Property\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: WaitingWriteCount\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 229\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Gets the total number of threads that are waiting to enter the lock in write mode.</p>\\n\"\n  syntax:\n    content: public int WaitingWriteCount { get; }\n    content.vb: Public ReadOnly Property WaitingWriteCount As Integer\n    parameters: []\n    return:\n      type: System.Int32\n      description: \"\\n<p>The total number of threads that are waiting to enter write mode.</p>\\n\"\n  modifiers.csharp:\n  - public\n  - get\n  modifiers.vb:\n  - Public\n  - ReadOnly\n  nameWithType: ReaderWriterLockSlim.WaitingWriteCount\n- uid: System.Threading.ReaderWriterLockSlim.Dispose\n  commentId: M:System.Threading.ReaderWriterLockSlim.Dispose\n  id: Dispose\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: Dispose()\n  fullName: System.Threading.ReaderWriterLockSlim.Dispose()\n  type: Method\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: Dispose\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 230\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Releases all resources used by the current instance of the <xref href=\\\"System.Threading.ReaderWriterLockSlim\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> class.</p>\\n\"\n  syntax:\n    content: public void Dispose()\n    content.vb: Public Sub Dispose\n  exceptions:\n  - type: System.Threading.SynchronizationLockException\n    commentId: T:System.Threading.SynchronizationLockException\n    description: \"\\n<p>\\n<xref href=\\\"System.Threading.ReaderWriterLockSlim.WaitingReadCount\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> is greater than zero. </p>\\n<p>-or-</p>\\n<p>\\n<xref href=\\\"System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> is greater than zero. </p>\\n<p>-or-</p>\\n<p>\\n<xref href=\\\"System.Threading.ReaderWriterLockSlim.WaitingWriteCount\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> is greater than zero. </p>\\n\"\n  implements:\n  - System.IDisposable.Dispose\n  modifiers.csharp:\n  - public\n  modifiers.vb:\n  - Public\n  nameWithType: ReaderWriterLockSlim.Dispose()\n- uid: System.Threading.ReaderWriterLockSlim.EnterReadLock\n  commentId: M:System.Threading.ReaderWriterLockSlim.EnterReadLock\n  id: EnterReadLock\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: EnterReadLock()\n  fullName: System.Threading.ReaderWriterLockSlim.EnterReadLock()\n  type: Method\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: EnterReadLock\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 231\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Tries to enter the lock in read mode.</p>\\n\"\n  syntax:\n    content: public void EnterReadLock()\n    content.vb: Public Sub EnterReadLock\n  exceptions:\n  - type: System.Threading.LockRecursionException\n    commentId: T:System.Threading.LockRecursionException\n    description: \"\\n<p>The current thread cannot acquire the write lock when it holds the read lock.</p>\\n<p>-or-</p>\\n<p>The <xref href=\\\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> property is <xref href=\\\"System.Threading.LockRecursionPolicy.NoRecursion\\\" data-throw-if-not-resolved=\\\"false\\\"></xref>, and the current thread has attempted to acquire the read lock when it already holds the read lock. </p>\\n<p>-or-</p>\\n<p>The <xref href=\\\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> property is <xref href=\\\"System.Threading.LockRecursionPolicy.NoRecursion\\\" data-throw-if-not-resolved=\\\"false\\\"></xref>, and the current thread has attempted to acquire the read lock when it already holds the write lock. </p>\\n<p>-or-</p>\\n<p>The recursion number would exceed the capacity of the counter. This limit is so large that applications should never encounter this exception. </p>\\n\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: \"\\n<p>The <xref href=\\\"System.Threading.ReaderWriterLockSlim\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> object has been disposed. </p>\\n\"\n  modifiers.csharp:\n  - public\n  modifiers.vb:\n  - Public\n  nameWithType: ReaderWriterLockSlim.EnterReadLock()\n- uid: System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock\n  commentId: M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock\n  id: EnterUpgradeableReadLock\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: EnterUpgradeableReadLock()\n  fullName: System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock()\n  type: Method\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: EnterUpgradeableReadLock\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 232\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Tries to enter the lock in upgradeable mode.</p>\\n\"\n  syntax:\n    content: public void EnterUpgradeableReadLock()\n    content.vb: Public Sub EnterUpgradeableReadLock\n  exceptions:\n  - type: System.Threading.LockRecursionException\n    commentId: T:System.Threading.LockRecursionException\n    description: \"\\n<p>The <xref href=\\\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> property is <xref href=\\\"System.Threading.LockRecursionPolicy.NoRecursion\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> and the current thread has already entered the lock in any mode. </p>\\n<p>-or-</p>\\n<p>The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock. </p>\\n<p>-or-</p>\\n<p>The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</p>\\n\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: \"\\n<p>The <xref href=\\\"System.Threading.ReaderWriterLockSlim\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> object has been disposed. </p>\\n\"\n  modifiers.csharp:\n  - public\n  modifiers.vb:\n  - Public\n  nameWithType: ReaderWriterLockSlim.EnterUpgradeableReadLock()\n- uid: System.Threading.ReaderWriterLockSlim.EnterWriteLock\n  commentId: M:System.Threading.ReaderWriterLockSlim.EnterWriteLock\n  id: EnterWriteLock\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: EnterWriteLock()\n  fullName: System.Threading.ReaderWriterLockSlim.EnterWriteLock()\n  type: Method\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: EnterWriteLock\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 233\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Tries to enter the lock in write mode.</p>\\n\"\n  syntax:\n    content: public void EnterWriteLock()\n    content.vb: Public Sub EnterWriteLock\n  exceptions:\n  - type: System.Threading.LockRecursionException\n    commentId: T:System.Threading.LockRecursionException\n    description: \"\\n<p>The <xref href=\\\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> property is <xref href=\\\"System.Threading.LockRecursionPolicy.NoRecursion\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> and the current thread has already entered the lock in any mode. </p>\\n<p>-or-</p>\\n<p>The current thread has entered read mode, so trying to enter the lock in write mode would create the possibility of a deadlock. </p>\\n<p>-or-</p>\\n<p>The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</p>\\n\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: \"\\n<p>The <xref href=\\\"System.Threading.ReaderWriterLockSlim\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> object has been disposed. </p>\\n\"\n  modifiers.csharp:\n  - public\n  modifiers.vb:\n  - Public\n  nameWithType: ReaderWriterLockSlim.EnterWriteLock()\n- uid: System.Threading.ReaderWriterLockSlim.ExitReadLock\n  commentId: M:System.Threading.ReaderWriterLockSlim.ExitReadLock\n  id: ExitReadLock\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: ExitReadLock()\n  fullName: System.Threading.ReaderWriterLockSlim.ExitReadLock()\n  type: Method\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: ExitReadLock\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 234\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).</p>\\n\"\n  syntax:\n    content: public void ExitReadLock()\n    content.vb: Public Sub ExitReadLock\n  exceptions:\n  - type: System.Threading.SynchronizationLockException\n    commentId: T:System.Threading.SynchronizationLockException\n    description: \"\\n<p>The current thread has not entered the lock in read mode. </p>\\n\"\n  modifiers.csharp:\n  - public\n  modifiers.vb:\n  - Public\n  nameWithType: ReaderWriterLockSlim.ExitReadLock()\n- uid: System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock\n  commentId: M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock\n  id: ExitUpgradeableReadLock\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: ExitUpgradeableReadLock()\n  fullName: System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock()\n  type: Method\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: ExitUpgradeableReadLock\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 235\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).</p>\\n\"\n  syntax:\n    content: public void ExitUpgradeableReadLock()\n    content.vb: Public Sub ExitUpgradeableReadLock\n  exceptions:\n  - type: System.Threading.SynchronizationLockException\n    commentId: T:System.Threading.SynchronizationLockException\n    description: \"\\n<p>The current thread has not entered the lock in upgradeable mode.</p>\\n\"\n  modifiers.csharp:\n  - public\n  modifiers.vb:\n  - Public\n  nameWithType: ReaderWriterLockSlim.ExitUpgradeableReadLock()\n- uid: System.Threading.ReaderWriterLockSlim.ExitWriteLock\n  commentId: M:System.Threading.ReaderWriterLockSlim.ExitWriteLock\n  id: ExitWriteLock\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: ExitWriteLock()\n  fullName: System.Threading.ReaderWriterLockSlim.ExitWriteLock()\n  type: Method\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: ExitWriteLock\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 236\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).</p>\\n\"\n  syntax:\n    content: public void ExitWriteLock()\n    content.vb: Public Sub ExitWriteLock\n  exceptions:\n  - type: System.Threading.SynchronizationLockException\n    commentId: T:System.Threading.SynchronizationLockException\n    description: \"\\n<p>The current thread has not entered the lock in write mode.</p>\\n\"\n  modifiers.csharp:\n  - public\n  modifiers.vb:\n  - Public\n  nameWithType: ReaderWriterLockSlim.ExitWriteLock()\n- uid: System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)\n  commentId: M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)\n  id: TryEnterReadLock(System.Int32)\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: TryEnterReadLock(Int32)\n  fullName: System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)\n  type: Method\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: TryEnterReadLock\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 237\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Tries to enter the lock in read mode, with an optional integer time-out.</p>\\n\"\n  syntax:\n    content: public bool TryEnterReadLock(int millisecondsTimeout)\n    content.vb: Public Function TryEnterReadLock(millisecondsTimeout As Integer) As Boolean\n    parameters:\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: \"\\n<p>The number of milliseconds to wait, or -1 (<xref href=\\\"System.Threading.Timeout.Infinite\\\" data-throw-if-not-resolved=\\\"false\\\"></xref>) to wait indefinitely.</p>\\n\"\n    return:\n      type: System.Boolean\n      description: \"\\n<p>\\n<strong>true</strong> if the calling thread entered read mode, otherwise, <strong>false</strong>.</p>\\n\"\n  exceptions:\n  - type: System.Threading.LockRecursionException\n    commentId: T:System.Threading.LockRecursionException\n    description: \"\\n<p>The <xref href=\\\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> property is <xref href=\\\"System.Threading.LockRecursionPolicy.NoRecursion\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> and the current thread has already entered the lock. </p>\\n<p>-or-</p>\\n<p>The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</p>\\n\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"\\n<p>The value of <em>millisecondsTimeout</em> is negative, but it is not equal to <xref href=\\\"System.Threading.Timeout.Infinite\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> (-1), which is the only negative value allowed.</p>\\n\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: \"\\n<p>The <xref href=\\\"System.Threading.ReaderWriterLockSlim\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> object has been disposed. </p>\\n\"\n  modifiers.csharp:\n  - public\n  modifiers.vb:\n  - Public\n  nameWithType: ReaderWriterLockSlim.TryEnterReadLock(Int32)\n- uid: System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)\n  commentId: M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)\n  id: TryEnterReadLock(System.TimeSpan)\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: TryEnterReadLock(TimeSpan)\n  fullName: System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)\n  type: Method\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: TryEnterReadLock\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 238\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Tries to enter the lock in read mode, with an optional time-out.</p>\\n\"\n  syntax:\n    content: public bool TryEnterReadLock(TimeSpan timeout)\n    content.vb: Public Function TryEnterReadLock(timeout As TimeSpan) As Boolean\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: \"\\n<p>The interval to wait, or -1 milliseconds to wait indefinitely. </p>\\n\"\n    return:\n      type: System.Boolean\n      description: \"\\n<p>\\n<strong>true</strong> if the calling thread entered read mode, otherwise, <strong>false</strong>.</p>\\n\"\n  exceptions:\n  - type: System.Threading.LockRecursionException\n    commentId: T:System.Threading.LockRecursionException\n    description: \"\\n<p>The <xref href=\\\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> property is <xref href=\\\"System.Threading.LockRecursionPolicy.NoRecursion\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> and the current thread has already entered the lock. </p>\\n<p>-or-</p>\\n<p>The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</p>\\n\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"\\n<p>The value of <em>timeout</em> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</p>\\n<p>-or-</p>\\n<p>The value of <em>timeout</em> is greater than <xref href=\\\"System.Int32.MaxValue\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> milliseconds. </p>\\n\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: \"\\n<p>The <xref href=\\\"System.Threading.ReaderWriterLockSlim\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> object has been disposed. </p>\\n\"\n  modifiers.csharp:\n  - public\n  modifiers.vb:\n  - Public\n  nameWithType: ReaderWriterLockSlim.TryEnterReadLock(TimeSpan)\n- uid: System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)\n  commentId: M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)\n  id: TryEnterUpgradeableReadLock(System.Int32)\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: TryEnterUpgradeableReadLock(Int32)\n  fullName: System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)\n  type: Method\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: TryEnterUpgradeableReadLock\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 239\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Tries to enter the lock in upgradeable mode, with an optional time-out.</p>\\n\"\n  syntax:\n    content: public bool TryEnterUpgradeableReadLock(int millisecondsTimeout)\n    content.vb: Public Function TryEnterUpgradeableReadLock(millisecondsTimeout As Integer) As Boolean\n    parameters:\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: \"\\n<p>The number of milliseconds to wait, or -1 (<xref href=\\\"System.Threading.Timeout.Infinite\\\" data-throw-if-not-resolved=\\\"false\\\"></xref>) to wait indefinitely.</p>\\n\"\n    return:\n      type: System.Boolean\n      description: \"\\n<p>\\n<strong>true</strong> if the calling thread entered upgradeable mode, otherwise, <strong>false</strong>.</p>\\n\"\n  exceptions:\n  - type: System.Threading.LockRecursionException\n    commentId: T:System.Threading.LockRecursionException\n    description: \"\\n<p>The <xref href=\\\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> property is <xref href=\\\"System.Threading.LockRecursionPolicy.NoRecursion\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> and the current thread has already entered the lock. </p>\\n<p>-or-</p>\\n<p>The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock. </p>\\n<p>-or-</p>\\n<p>The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</p>\\n\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"\\n<p>The value of <em>millisecondsTimeout</em> is negative, but it is not equal to <xref href=\\\"System.Threading.Timeout.Infinite\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> (-1), which is the only negative value allowed. </p>\\n\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: \"\\n<p>The <xref href=\\\"System.Threading.ReaderWriterLockSlim\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> object has been disposed. </p>\\n\"\n  modifiers.csharp:\n  - public\n  modifiers.vb:\n  - Public\n  nameWithType: ReaderWriterLockSlim.TryEnterUpgradeableReadLock(Int32)\n- uid: System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)\n  commentId: M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)\n  id: TryEnterUpgradeableReadLock(System.TimeSpan)\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: TryEnterUpgradeableReadLock(TimeSpan)\n  fullName: System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)\n  type: Method\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: TryEnterUpgradeableReadLock\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 240\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Tries to enter the lock in upgradeable mode, with an optional time-out.</p>\\n\"\n  syntax:\n    content: public bool TryEnterUpgradeableReadLock(TimeSpan timeout)\n    content.vb: Public Function TryEnterUpgradeableReadLock(timeout As TimeSpan) As Boolean\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: \"\\n<p>The interval to wait, or -1 milliseconds to wait indefinitely.</p>\\n\"\n    return:\n      type: System.Boolean\n      description: \"\\n<p>\\n<strong>true</strong> if the calling thread entered upgradeable mode, otherwise, <strong>false</strong>.</p>\\n\"\n  exceptions:\n  - type: System.Threading.LockRecursionException\n    commentId: T:System.Threading.LockRecursionException\n    description: \"\\n<p>The <xref href=\\\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> property is <xref href=\\\"System.Threading.LockRecursionPolicy.NoRecursion\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> and the current thread has already entered the lock. </p>\\n<p>-or-</p>\\n<p>The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock. </p>\\n<p>-or-</p>\\n<p>The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</p>\\n\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"\\n<p>The value of <em>timeout</em> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</p>\\n<p>-or-</p>\\n<p>The value of <em>timeout</em> is greater than <xref href=\\\"System.Int32.MaxValue\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> milliseconds. </p>\\n\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: \"\\n<p>The <xref href=\\\"System.Threading.ReaderWriterLockSlim\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> object has been disposed. </p>\\n\"\n  modifiers.csharp:\n  - public\n  modifiers.vb:\n  - Public\n  nameWithType: ReaderWriterLockSlim.TryEnterUpgradeableReadLock(TimeSpan)\n- uid: System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)\n  commentId: M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)\n  id: TryEnterWriteLock(System.Int32)\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: TryEnterWriteLock(Int32)\n  fullName: System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)\n  type: Method\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: TryEnterWriteLock\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 241\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Tries to enter the lock in write mode, with an optional time-out.</p>\\n\"\n  syntax:\n    content: public bool TryEnterWriteLock(int millisecondsTimeout)\n    content.vb: Public Function TryEnterWriteLock(millisecondsTimeout As Integer) As Boolean\n    parameters:\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: \"\\n<p>The number of milliseconds to wait, or -1 (<xref href=\\\"System.Threading.Timeout.Infinite\\\" data-throw-if-not-resolved=\\\"false\\\"></xref>) to wait indefinitely.</p>\\n\"\n    return:\n      type: System.Boolean\n      description: \"\\n<p>\\n<strong>true</strong> if the calling thread entered write mode, otherwise, <strong>false</strong>.</p>\\n\"\n  exceptions:\n  - type: System.Threading.LockRecursionException\n    commentId: T:System.Threading.LockRecursionException\n    description: \"\\n<p>The <xref href=\\\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> property is <xref href=\\\"System.Threading.LockRecursionPolicy.NoRecursion\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> and the current thread has already entered the lock. </p>\\n<p>-or-</p>\\n<p>The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock. </p>\\n<p>-or-</p>\\n<p>The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</p>\\n\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"\\n<p>The value of <em>millisecondsTimeout</em> is negative, but it is not equal to <xref href=\\\"System.Threading.Timeout.Infinite\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> (-1), which is the only negative value allowed. </p>\\n\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: \"\\n<p>The <xref href=\\\"System.Threading.ReaderWriterLockSlim\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> object has been disposed. </p>\\n\"\n  modifiers.csharp:\n  - public\n  modifiers.vb:\n  - Public\n  nameWithType: ReaderWriterLockSlim.TryEnterWriteLock(Int32)\n- uid: System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)\n  commentId: M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)\n  id: TryEnterWriteLock(System.TimeSpan)\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  - vb\n  name: TryEnterWriteLock(TimeSpan)\n  fullName: System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)\n  type: Method\n  source:\n    remote:\n      path: src/System.Threading/ref/System.Threading.cs\n      branch: master\n      repo: https://github.com/dotnet/corefx.git\n    id: TryEnterWriteLock\n    path: src/System.Threading/ref/System.Threading.cs\n    startLine: 242\n  assemblies:\n  - System.Threading\n  namespace: System.Threading\n  summary: \"\\n<p>Tries to enter the lock in write mode, with an optional time-out.</p>\\n\"\n  syntax:\n    content: public bool TryEnterWriteLock(TimeSpan timeout)\n    content.vb: Public Function TryEnterWriteLock(timeout As TimeSpan) As Boolean\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: \"\\n<p>The interval to wait, or -1 milliseconds to wait indefinitely.</p>\\n\"\n    return:\n      type: System.Boolean\n      description: \"\\n<p>\\n<strong>true</strong> if the calling thread entered write mode, otherwise, <strong>false</strong>.</p>\\n\"\n  exceptions:\n  - type: System.Threading.LockRecursionException\n    commentId: T:System.Threading.LockRecursionException\n    description: \"\\n<p>The <xref href=\\\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> property is <xref href=\\\"System.Threading.LockRecursionPolicy.NoRecursion\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> and the current thread has already entered the lock. </p>\\n<p>-or-</p>\\n<p>The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock. </p>\\n<p>-or-</p>\\n<p>The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</p>\\n\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"\\n<p>The value of <em>timeout</em> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</p>\\n<p>-or-</p>\\n<p>The value of <em>timeout</em> is greater than <xref href=\\\"System.Int32.MaxValue\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> milliseconds. </p>\\n\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: \"\\n<p>The <xref href=\\\"System.Threading.ReaderWriterLockSlim\\\" data-throw-if-not-resolved=\\\"false\\\"></xref> object has been disposed. </p>\\n\"\n  modifiers.csharp:\n  - public\n  modifiers.vb:\n  - Public\n  nameWithType: ReaderWriterLockSlim.TryEnterWriteLock(TimeSpan)\nreferences:\n- uid: System.Threading\n  isExternal: false\n  name: System.Threading\n  fullName: System.Threading\n  commentId: N:System.Threading\n  nameWithType: System.Threading\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  fullName: System.Object\n  commentId: T:System.Object\n  nameWithType: Object\n- uid: System.IDisposable\n  parent: System\n  isExternal: false\n  name: IDisposable\n  fullName: System.IDisposable\n  commentId: T:System.IDisposable\n  nameWithType: IDisposable\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: true\n  name: ToString()\n  fullName: System.Object.ToString()\n  spec.csharp:\n  - uid: System.Object.ToString\n    name: ToString\n    fullName: System.Object.ToString\n    isExternal: true\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Object.ToString\n    name: ToString\n    fullName: System.Object.ToString\n    isExternal: true\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  commentId: M:System.Object.ToString\n  nameWithType: Object.ToString()\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: true\n  name: Equals(Object)\n  fullName: System.Object.Equals(System.Object)\n  spec.csharp:\n  - uid: System.Object.Equals(System.Object)\n    name: Equals\n    fullName: System.Object.Equals\n    isExternal: true\n  - name: (\n    fullName: (\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Object.Equals(System.Object)\n    name: Equals\n    fullName: System.Object.Equals\n    isExternal: true\n  - name: (\n    fullName: (\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: )\n    fullName: )\n  commentId: M:System.Object.Equals(System.Object)\n  nameWithType: Object.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: true\n  name: Equals(Object, Object)\n  fullName: System.Object.Equals(System.Object, System.Object)\n  spec.csharp:\n  - uid: System.Object.Equals(System.Object,System.Object)\n    name: Equals\n    fullName: System.Object.Equals\n    isExternal: true\n  - name: (\n    fullName: (\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: ', '\n    fullName: ', '\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Object.Equals(System.Object,System.Object)\n    name: Equals\n    fullName: System.Object.Equals\n    isExternal: true\n  - name: (\n    fullName: (\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: ', '\n    fullName: ', '\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: )\n    fullName: )\n  commentId: M:System.Object.Equals(System.Object,System.Object)\n  nameWithType: Object.Equals(Object, Object)\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: true\n  name: ReferenceEquals(Object, Object)\n  fullName: System.Object.ReferenceEquals(System.Object, System.Object)\n  spec.csharp:\n  - uid: System.Object.ReferenceEquals(System.Object,System.Object)\n    name: ReferenceEquals\n    fullName: System.Object.ReferenceEquals\n    isExternal: true\n  - name: (\n    fullName: (\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: ', '\n    fullName: ', '\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Object.ReferenceEquals(System.Object,System.Object)\n    name: ReferenceEquals\n    fullName: System.Object.ReferenceEquals\n    isExternal: true\n  - name: (\n    fullName: (\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: ', '\n    fullName: ', '\n  - uid: System.Object\n    name: Object\n    fullName: System.Object\n    isExternal: true\n  - name: )\n    fullName: )\n  commentId: M:System.Object.ReferenceEquals(System.Object,System.Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: true\n  name: GetHashCode()\n  fullName: System.Object.GetHashCode()\n  spec.csharp:\n  - uid: System.Object.GetHashCode\n    name: GetHashCode\n    fullName: System.Object.GetHashCode\n    isExternal: true\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Object.GetHashCode\n    name: GetHashCode\n    fullName: System.Object.GetHashCode\n    isExternal: true\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  commentId: M:System.Object.GetHashCode\n  nameWithType: Object.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: true\n  name: GetType()\n  fullName: System.Object.GetType()\n  spec.csharp:\n  - uid: System.Object.GetType\n    name: GetType\n    fullName: System.Object.GetType\n    isExternal: true\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Object.GetType\n    name: GetType\n    fullName: System.Object.GetType\n    isExternal: true\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  commentId: M:System.Object.GetType\n  nameWithType: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: true\n  name: MemberwiseClone()\n  fullName: System.Object.MemberwiseClone()\n  spec.csharp:\n  - uid: System.Object.MemberwiseClone\n    name: MemberwiseClone\n    fullName: System.Object.MemberwiseClone\n    isExternal: true\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.Object.MemberwiseClone\n    name: MemberwiseClone\n    fullName: System.Object.MemberwiseClone\n    isExternal: true\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  commentId: M:System.Object.MemberwiseClone\n  nameWithType: Object.MemberwiseClone()\n- uid: System\n  isExternal: false\n  name: System\n  fullName: System\n  commentId: N:System\n  nameWithType: System\n- uid: System.Threading.LockRecursionPolicy\n  parent: System.Threading\n  isExternal: false\n  name: LockRecursionPolicy\n  fullName: System.Threading.LockRecursionPolicy\n  commentId: T:System.Threading.LockRecursionPolicy\n  nameWithType: LockRecursionPolicy\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  fullName: System.Int32\n  commentId: T:System.Int32\n  nameWithType: Int32\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  fullName: System.Boolean\n  commentId: T:System.Boolean\n  nameWithType: Boolean\n- uid: System.IDisposable.Dispose\n  parent: System.IDisposable\n  isExternal: false\n  name: Dispose()\n  fullName: System.IDisposable.Dispose()\n  spec.csharp:\n  - uid: System.IDisposable.Dispose\n    name: Dispose\n    fullName: System.IDisposable.Dispose\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  spec.vb:\n  - uid: System.IDisposable.Dispose\n    name: Dispose\n    fullName: System.IDisposable.Dispose\n  - name: (\n    fullName: (\n  - name: )\n    fullName: )\n  commentId: M:System.IDisposable.Dispose\n  nameWithType: IDisposable.Dispose()\n- uid: System.TimeSpan\n  parent: System\n  isExternal: false\n  name: TimeSpan\n  fullName: System.TimeSpan\n  commentId: T:System.TimeSpan\n  nameWithType: TimeSpan\n- uid: System.Threading.SynchronizationLockException\n  isExternal: false\n  name: SynchronizationLockException\n  fullName: System.Threading.SynchronizationLockException\n  nameWithType: SynchronizationLockException\n  commentId: T:System.Threading.SynchronizationLockException\n- uid: System.Threading.LockRecursionException\n  isExternal: false\n  name: LockRecursionException\n  fullName: System.Threading.LockRecursionException\n  nameWithType: LockRecursionException\n  commentId: T:System.Threading.LockRecursionException\n- uid: System.ObjectDisposedException\n  isExternal: false\n  name: ObjectDisposedException\n  fullName: System.ObjectDisposedException\n  nameWithType: ObjectDisposedException\n  commentId: T:System.ObjectDisposedException\n- uid: System.ArgumentOutOfRangeException\n  isExternal: false\n  name: ArgumentOutOfRangeException\n  fullName: System.ArgumentOutOfRangeException\n  nameWithType: ArgumentOutOfRangeException\n  commentId: T:System.ArgumentOutOfRangeException\n"}